/*****************************************************************************
 *   File        : test_HET_22.c
 *
 *   Description: Acceptance test for HET-22 which tests the SW keeps switching the pump off when
 * that is not needed, in an attempt to prevent the pump to reach dangerous vacuum levels
 *
 * Note: due to the way the autogenerated code is structured we cannot test if the HW
 * interface is correctly driven at PIN level by the SW API. This acceptance test
 * assumes that the relevant SW API's (MP_DisablePumpPWM and SetReferenceVoltageBoost)
 * do drive the HW correctly therefore we simple test if the SW API's are being
 * called when expected 
 *
 *****************************************************************************/
/* ***************************************************************************
 * This file is copyrighted by and the property of Smith & Nephew Medical Ltd.
 * It contains confidential and proprietary information. It must not be copied
 * (in whole or in part) or otherwise disclosed without prior written consent 
 * of the company. Any copies of this file (in whole or in part), made by any
 * method must also include a copy of this legend. 
 * 
 * (c) 2018, 2019 Smith & Nephew Medical Ltd.
 * 
 *************************************************************************** */

#include "unity.h"
#include "DeviceStatus.h"
#include "pic16lf1509.h"
#include "Application.h"

#include "MockAlertManager.h"
#include "MockLoggingManager.h"
#include "MockUIInterfaces.h"

#include "StateMachine.h"
#include "StateMachineCommon.h"
#include "StateMachinePumpDown.h"
#include "StateMachineShutdown.h"
#include "StateMachineIdle.h"
#include "StateMachineTherapyDelivery.h"
#include "StateMachineFault.h"
#include "StateMachineNre.h"

#include "StateMachinePOST.h"
#include "StateMachinePOST_internal.h"
#include "I2CEEPROM.h"
#include "Pump.h"
#include "Timer.h"


#include "MockHardwareInterface.h"
#include "MockPowerControl.h"
#include "MockPumpFrequencyTracker.h"
#include "MockLED.h"
#include "MockPushButton.h"
#include "MockPressure_Part1.h"
#include "MockTransmit.h"
#include "Mockadc.h"
#include "MockDutyCycle.h"
#include "MockBattery.h"
#include "Mocki2c.h"
#include "MockPerformanceLogger.h"
#include "MockWatchdog.h"
#include "Assert.h"

extern void TMR1_CallBack(void);

static bool_t PushButtonPress = FALSE;
static bool_t GreenLEDEnabled = FALSE;
static bool_t OrangeLEDEnabled = FALSE;
static uint32_t disablePumpPwmCount = 0;
static uint32_t switchoffVoltageBoostCount = 0;
static uint8_t boostDemand = 0;
static bool_t isShortPress = FALSE;
static bool_t isTargetIpdVacuumAchieved = FALSE;
static uint32_t enableExternalPeripheralsSupplyCount = 0;


static bool_t Stub_PushButton_IsPressed(int NumCall)
{
  return (PushButtonPress);
}

static void Stub_LED_SetGreen(bool_t on, int NumCall)
{
  GreenLEDEnabled = on;
}

static void Stub_LED_SetOrange(bool_t on, int NumCall)
{
  OrangeLEDEnabled = on;
}

static void Stub_MP_EnableExternalPeripheralsSupply(int NumCall)
{
  // this is called when the pump  is activated to provide power to the HBridge Current sensor (ADC)
  enableExternalPeripheralsSupplyCount++;
}

static void Stub_MP_DisablePumpPWM(int NumCall)
{
  disablePumpPwmCount++;
}

static void Stub_MP_SetReferenceVoltageBoost(uint8_t demand, int NumCall)
{
  if (VBOOST_REF_0V == demand)
  {
    switchoffVoltageBoostCount++;
  }
  boostDemand = demand;
}

bool_t Stub_PushButton_IsShortPress()
{
  return isShortPress;
}

bool_t  Stub_isTargetPumpDownVacuumAchieved(uint16_t Vacuum, int NumCall)
{
  return isTargetIpdVacuumAchieved;
}


void setUp(void)
{
  HardwareInterface_SystemInitialise_Ignore();
  HardwareInterface_EnableGlobalInterrupt_Ignore();
  HardwareInterface_DisableGlobalInterrupt_Ignore();
  HardwareInterface_EnablePeripheralInterrupt_Ignore();

  MP_DisableExternalPeripheralsSupply_Ignore();
  MP_DisableMainCircuitPower_Ignore();
  MP_EnableRelaxationOscillator_Ignore();

  SetInitialExternalPressure_Ignore();
  GetVacuum_IgnoreAndReturn(EC_OK_E); // to review
  InitPumpDownVacuum_Ignore();
  PumpFrequencyTracker_Optimise_IgnoreAndReturn(EC_OK_E);
  Battery_CheckVoltageBounds_IgnoreAndReturn(EC_OK_E);
  InitTherapyDeliveryVacuum_Ignore();
  DCHistoryReset_Ignore();
  MP_EnablePumpPWM_Ignore();
  AlertManager_Init_IgnoreAndReturn(EC_OK_E);
  AlertManager_Run_IgnoreAndReturn(EC_OK_E);
  LoggingManager_Init_Ignore();
  LoggingManager_Run_IgnoreAndReturn(EC_OK_E);
  PerformanceLogger_SetPumpDownDuration_Ignore();
  MP_SleepUntilWokenByRelaxationOscillator_Ignore();
  MP_DisablePeripheral_Ignore();
  MP_EnableMainCircuitPower_Ignore();
  MP_GetBoostDemand_IgnoreAndReturn(VBOOST_REF_29V);
  PushButton_ResetEvent_Ignore();
  PushButton_GetDepressedTickCount_IgnoreAndReturn(1);
  TX_Init_Ignore();
  I2C_Initialize_Ignore();
  Watchdog_Init_Ignore();
  Watchdog_Clear_Ignore();

  checkLEDSequenceCompleted_IgnoreAndReturn(FALSE);
  DCCalculateAll_Ignore();
  isTherapyDeliveryLeakDetected_IgnoreAndReturn(FALSE);
  isTargetTherapyDeliveryVacuumAchieved_IgnoreAndReturn(TRUE);
  DCPumpOffUpdate_Ignore();

  PushButtonPress = FALSE;
  GreenLEDEnabled = FALSE;
  OrangeLEDEnabled = FALSE;
  enableExternalPeripheralsSupplyCount = 0;
  disablePumpPwmCount = 0;
  switchoffVoltageBoostCount = 0;
  boostDemand = 0;
  isShortPress = FALSE;
  isTargetIpdVacuumAchieved = FALSE;

  PushButton_IsPressed_StubWithCallback(Stub_PushButton_IsPressed);
  PushButton_IsShortPress_StubWithCallback(Stub_PushButton_IsShortPress);
  isTargetPumpDownVacuumAchieved_StubWithCallback(Stub_isTargetPumpDownVacuumAchieved);
  LED_SetGreen_StubWithCallback(Stub_LED_SetGreen);
  LED_SetOrange_StubWithCallback(Stub_LED_SetOrange);
  MP_SetReferenceVoltageBoost_StubWithCallback(Stub_MP_SetReferenceVoltageBoost);
  MP_DisablePumpPWM_StubWithCallback(Stub_MP_DisablePumpPWM);
  MP_EnableExternalPeripheralsSupply_StubWithCallback(Stub_MP_EnableExternalPeripheralsSupply);
  
  //skip through POST
  PORTAbits.RA0 = 1;
  PORTAbits.RA1 = 0;
}

void tearDown(void)
{}

void test_PeriodicallyTurnThePumpOffAndDisableBoostVoltageCircuitToMakeSureThePumpIsDeactivatedWhenNotNeeded(void)
{
  PerformanceLogger_GetNRE_ExpectAndReturn(FALSE);
  Application_Init();

  //simulate first timer tick, no button pressed, no LED change transistion from POST to IDLE
  TMR1_CallBack();
  Application_Run();
  

  TEST_ASSERT_FALSE(GreenLEDEnabled);
  TEST_ASSERT_FALSE(OrangeLEDEnabled);
  TEST_ASSERT_EQUAL_INT(IDLE_E, DeviceStatus_GetState());

  // Setup the call to LED sequence 
  StartLEDSequence_Expect(LED_CTRL_PUMP_DOWN_E);

  //simulate 1 tick with button pressed and device goes into PUMP DOWN
  PushButtonPress = TRUE;
  
  isShortPress = TRUE;

  TMR1_CallBack();
  Application_Run();
  
  
  TEST_ASSERT_EQUAL_INT(PUMP_DOWN_E, DeviceStatus_GetState());
  
  //simulate 10 ticks in PUMP DOWN, target vacuum not achieved, the pump is disables for 5 times
  //(i.e. PWM disabled and Voltage Boost circuit switched off)
  PushButtonPress = FALSE;  
  isShortPress = FALSE;
  disablePumpPwmCount = 0;
  switchoffVoltageBoostCount = 0;
  enableExternalPeripheralsSupplyCount = 0;
  for (uint32_t i = 0; 10 > i; i++)
  {
    TMR1_CallBack();
    Application_Run();
    
  }
  
  TEST_ASSERT_EQUAL_INT(PUMP_DOWN_E, DeviceStatus_GetState());
  TEST_ASSERT_EQUAL_INT(5, disablePumpPwmCount);
  TEST_ASSERT_EQUAL_INT(5, switchoffVoltageBoostCount);
  TEST_ASSERT_EQUAL_INT(5, enableExternalPeripheralsSupplyCount);
  
  //simulate 1 tick where the target vacuum is achieved and device goes into THERAPY DELIVERY
  isTargetIpdVacuumAchieved = TRUE;

  uint32_t tickCount =  PUMP_DOWN_COUNT_TICK_DURATION;
  State_t expectedState = PUMP_DOWN_E;


  // Since the pump down last for 20 seconds we need to advance the time until
  // we reach therapy.
  // In this test the pressure will be met for the entire period 
  for (uint32_t i = 0; i < tickCount; i++)
  {

    if (i >= (PUMP_DOWN_COUNT_TICK_DURATION - 10 ))    // PUMP_DOWN_COUNT_TICK_DURATION = 20
    {
       expectedState   = THERAPY_DELIVERY_E;
    }

    TMR1_CallBack();
    Application_Run();
  
    isTargetIpdVacuumAchieved = TRUE;
    TEST_ASSERT_EQUAL_INT(expectedState, DeviceStatus_GetState());
  }

  // count is 0..204   205 in all 
  TEST_ASSERT_EQUAL_INT(204, disablePumpPwmCount);
  TEST_ASSERT_EQUAL_INT(204, switchoffVoltageBoostCount);
  TEST_ASSERT_EQUAL_INT(5, enableExternalPeripheralsSupplyCount);

  TEST_ASSERT_EQUAL_INT(THERAPY_DELIVERY_E, DeviceStatus_GetState());

  //simulate 10 ticks where the target vacuum is achieved, the pump is disables for 10 times
  //(i.e. PWM disabled and Voltage Boost circuit switched off)
  disablePumpPwmCount = 0;
  switchoffVoltageBoostCount = 0;
  enableExternalPeripheralsSupplyCount = 0;
  for (uint32_t i = 0; 10 > i; i++)
  {
    TMR1_CallBack();
    Application_Run();
    
  }

  TEST_ASSERT_EQUAL_INT(THERAPY_DELIVERY_E, DeviceStatus_GetState());
  TEST_ASSERT_EQUAL_INT(10, disablePumpPwmCount);
  TEST_ASSERT_EQUAL_INT(10, switchoffVoltageBoostCount);
  TEST_ASSERT_EQUAL_INT(0, enableExternalPeripheralsSupplyCount);

}

