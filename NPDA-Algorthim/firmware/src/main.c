/**
 * @file main.c
 * @author rzeller, voccoto Ltd
 * @brief Occuity NDPA test application and project entry point for testing on the PC and the PIC32MZ.
 * @version 0.3
 * @date 2020-09-17
 * 
 * @copyright Copyright (c) 2020
 * 
 * @note To compile optimised version on the pc use "gcc -o pic32 main.c ndpa.c ndpa_tools.c -Dx86 -lm -Ofast [-std=c89]"
 * @note To compile with debug info on the pc use "gcc -o pic32 main.c ndpa.c ndpa_tools.c -Dx86 -lm -g -O0 -fno-inline -DDEBUG [-std=c89]"
 * @note To compile for the PIC32MZ load the project from NDPA.X
 * @note The PIC version of the code outputs (printf) to a serial port on a connected device using the mini usb port of the device. Connection: 115200 baud,8 bit,1 stop, No parity, XON/OFF
 * 
 */

#include <stddef.h>
#include <stdbool.h>
#include <stdlib.h>
#ifndef x86
#include "definitions.h" // SYS function prototypes
#else
#include <time.h>
#include <sys/resource.h>

#include "./tools/conio.h"
#define LED1_Set()          printf("LED1-ON\n")
#define LED1_Clear()        printf("LED1-OFF\n")
#define SYS_Initialize(a)   printf("SYS-INIT\n")
#define SYS_Tasks()         printf("SYS-TASKS\n")
void __sleep() {struct timespec tim, tim2; tim.tv_sec = 0; tim.tv_nsec = 100,000,000; nanosleep(&tim , &tim2); }
bool SW1_Get() { if (kbhit()) {getchar(); return true; } __sleep(); return false; }
#endif
#include <string.h>
#include <stdio.h>

#include "ndpa.h"

/*
    const static data sets loaded into program memory (program memory on the device)
    See comments at the top of the header files
    Header files can be generated by the csv2header.c and csv2header-window.c applications in ./tools
    WARNING: Adjust MAX_BLOCKS, MAX_SCANS, MAX_POSITIONS, MAX_WINDOW_SIZE and USE_RESTRICTED_SCANS accordingly
*/
#if USE_RESTRICTED_SCANS
//    #include "test_data2.h"
//    #include "test_data3.h"
//    #include "test_data4.h"
//    #include "test_data5.h"
//    #include "test_data6.h"
//    #include "test_data7.h"
    // #include "test_data8.h"
// #include "test_data9-restricted.h"
    #include "test_data10.h" // Restricted version of test_data1.h with median data
#else
    #include "test_data1.h"
    // #include "test_data9-zero-pad.h"
    // #include "test_data9-min-pad.h"
#endif

/*
    Various platform dependent utilities
*/
#ifndef x86
    typedef uint32_t    tick_t;

    tick_t GetTick(void) {
        return _CP0_GET_COUNT();
    }
    float ElapsedMs(tick_t startCnt, tick_t endCnt) {
        float Cnt = endCnt - startCnt;
        return (1000.0*Cnt)/CORE_TIMER_FREQUENCY;
    }

    void core_init(void) { return ; }
#else
    typedef clock_t    tick_t;

    tick_t GetTick(void) {
        return clock();
    }
    float ElapsedMs(tick_t startCnt, tick_t endCnt) {
        return 1000.0*((double)(endCnt - startCnt)/CLOCKS_PER_SEC);
    }

    // Try to enable core dumps
    void core_init(void) {
        struct rlimit core_limit;
        core_limit.rlim_cur = RLIM_INFINITY;
        core_limit.rlim_max = RLIM_INFINITY;
        setrlimit(RLIMIT_CORE, &core_limit);
    }
#endif

int main (void) {
    int iret = 0;
    bool fOk = true;

    core_init();

    /* Initialize all modules */
    SYS_Initialize(NULL);

    LED1_Set();
    printf("\r\nNDPA Speed Test...\r\n\r\n");
    printf("\tBlock-count: %d\r\n", MAX_BLOCKS);
    printf("\tScans-per-block: %d\r\n", MAX_SCANS);
#if USE_RESTRICTED_SCANS
    printf("\tRestricted-window-size: %d\r\n", MAX_WINDOW_SIZE);
#endif
    printf("\tRaw-scan-size: %d\r\n\r\n", MAX_POSITIONS);

    printf("Initialising memory buffers...\r\n");
    ndpa_initialise();

    printf("Copying x0 data from static variables...\r\n");
    memcpy(__ndpa_x0, tst_x0, MAX_POSITIONS*sizeof(fptype));

    if (fOk) printf("\tPress red button to run a simulated measurement.\r\n");

#ifdef x86
    // Dumping input data into a csv, PC only
    FILE *f = fopen("calib-input-dump.csv", "wt");
    for (int i=0; i<MAX_POSITIONS; i++) fprintf(f, "%g\n", tst_x0[i]);
    fclose(f);
    f = fopen("scan-input-dump.csv", "wt");
    for (int i=0; i<MAX_WINDOW_SIZE; i++) {
        for (int s=0; s<MAX_BLOCKS*MAX_SCANS; s++) {
            fprintf(f, "%s%u", (s?", ":""), (unsigned)tst_y0[s*MAX_WINDOW_SIZE + i]);
        }
        fprintf(f, "\n");
    }
    fclose(f);
#endif

    while (true) {
        SYS_Tasks(); /* Maintain state machines of all polled MPLAB Harmony modules. */
        /* Press a key or SW1 on the device for a test run */
        if (fOk && !(SW1_Get())) {
            LED1_Clear();
            tick_t startCnt = GetTick();

            printf("\r\n\r\nStarting measurement...\r\n");
            if (!(iret = ndpa_measurement_start())) {
                word *ty0 = (word*)tst_y0;
                do {
                    printf("\tProcessing block %d...\r\n", __block_cnt);
                    if (!(iret = ndpa_block_start())) {
                        printf("\t\tProcessing %d scans of the file as one block...\r\n", MAX_SCANS);
#if USE_RESTRICTED_SCANS
                        printf("\t\tCopying offset data from static variable...\r\n");
                        memcpy(__ndpa_offsets, tst_offsets + __block_cnt*MAX_SCANS, MAX_SCANS*sizeof(word));
#endif
                        do {
                            // Get scan data from static buffer
                            memcpy(__ndpa_y0, ty0, MAX_WINDOW_SIZE*sizeof(word));
#if USE_RESTRICTED_SCANS
                            word scan_med = tst_medians[__block_cnt*MAX_SCANS + __scan_cnt];
#else
                            word scan_med = 0;
#endif
                            // Process scan
                            iret = ndpa_scan(scan_med);
                            if (iret) {
                                printf("\t\t\t~~~~~ ERROR: ndpa_scan() = %d in scan %u\r\n", iret, __scan_cnt - 1);
                            }
                            if (__scan_cnt == 1) {
                                printf("\t\tInterpolated-size = %d\r\n", __interpolated_size);
                            }
                            ty0 += MAX_WINDOW_SIZE;
                            if (ty0 >= (word*)tst_y0 + sizeof(tst_y0)/sizeof(word)) {
                                // Trying to use more scan then what we have will round-robin to the beginning of the data set and reuse the same data
                                // WARNING: This is only for speed testing
                                ty0 = (word*)tst_y0;
                            }
                        } while (__scan_cnt < MAX_SCANS);

#ifdef x86
                        // Dumping block averaged and/or convolved data into a csv PC only
                        // char sfn[32];
                        
                        // sprintf(sfn, "avg-data-%d.csv", __block_cnt);
                        // FILE *favg = fopen(sfn, "wt");
                        // for (int i=0; i<__interpolated_size; i++) fprintf(favg, "%g\n", __ndpa_avg[i]);
                        // fclose(favg);

                        // sprintf(sfn, "conv-data-%d.csv", __block_cnt);
                        // FILE *fconv = fopen(sfn, "wt");
                        // for (int i=0; i<__interpolated_size; i++) fprintf(fconv, "%g\n", __ndpa_conv[i]);
                        // fclose(fconv);
#endif

                        if ((iret = ndpa_block_end())) {
                            printf("\t\t~~~~~~ ERROR: ndpa_block_end() = %d\r\n", iret);
                        }
                        printf("\t\tNumber of valid scans used %d vs %d\r\n", __valid_scans, __scan_cnt);
                    }
                    else {
                        printf("ERROR: ndpa_block_start() = %d\r\n", iret);
                    }
                } while (__block_cnt < MAX_BLOCKS);

                if ((iret = ndpa_measurement_end())) {
                    printf("ERROR: ndpa_measurement_end() = %d\r\n", iret);
                }
            }
            else {
                printf("ERROR: ndpa_measurement_start() = %d\r\n", iret);
            }

            printf("\r\nDone.\r\n");
            printf("Elapsed time %f msec\r\n", ElapsedMs(startCnt, GetTick()));

            /* Wait till SW1 is released */
            while (!(SW1_Get()));
            LED1_Set();
        }
    }

    /* Execution should not come here during normal operation */

    return ( EXIT_FAILURE );
}


/*******************************************************************************
 End of File
*/
