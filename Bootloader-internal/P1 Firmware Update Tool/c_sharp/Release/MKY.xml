<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MKY</name>
    </assembly>
    <members>
        <member name="T:MKY.Collections.ICollectionEx">
            <summary>
            <see cref="T:System.Collections.ICollection"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.Collections.ICollectionEx.IsNullOrEmpty(System.Collections.ICollection)">
            <summary>
            Indicates whether the specified collection is <c>null</c> or empty.
            </summary>
            <param name="obj">The collection to test.</param>
            <remarks>
            Same syntax and semantic as <see cref="M:System.String.IsNullOrEmpty(System.String)"/>.
            </remarks>
            <returns>
            <c>true</c> if the collection is <c>null</c> or empty; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:MKY.Collections.Generic.Quadruple`4">
            <summary>
            Value quadruple.
            </summary>
            <typeparam name="T1">The first type of the quadruple.</typeparam>
            <typeparam name="T2">The second type of the quadruple.</typeparam>
            <typeparam name="T3">The third type of the quadruple.</typeparam>
            <typeparam name="T4">The forth type of the quadruple.</typeparam>
        </member>
        <member name="P:MKY.Collections.Generic.Quadruple`4.Value1">
            <summary>
            Gets or sets the first value.
            </summary>
            <value>The first value.</value>
        </member>
        <member name="P:MKY.Collections.Generic.Quadruple`4.Value2">
            <summary>
            Gets or sets the second value.
            </summary>
            <value>The second value.</value>
        </member>
        <member name="P:MKY.Collections.Generic.Quadruple`4.Value3">
            <summary>
            Gets or sets the third value.
            </summary>
            <value>The third value.</value>
        </member>
        <member name="P:MKY.Collections.Generic.Quadruple`4.Value4">
            <summary>
            Gets or sets the forth value.
            </summary>
            <value>The forth value.</value>
        </member>
        <member name="M:MKY.Collections.Generic.Quadruple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:ValueQuadruple`1"/> struct.
            </summary>
            <param name="value1">The first value.</param>
            <param name="value2">The second value.</param>
            <param name="value3">The third value.</param>
            <param name="value4">The forth value.</param>
        </member>
        <member name="M:MKY.Collections.Generic.Quadruple`4.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Generic.Quadruple`4.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Generic.Quadruple`4.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Collections.Generic.Quadruple`4.Equals(MKY.Collections.Generic.Quadruple{`0,`1,`2,`3})">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Generic.Quadruple`4.op_Equality(MKY.Collections.Generic.Quadruple{`0,`1,`2,`3},MKY.Collections.Generic.Quadruple{`0,`1,`2,`3})">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Collections.Generic.Quadruple`4.op_Inequality(MKY.Collections.Generic.Quadruple{`0,`1,`2,`3},MKY.Collections.Generic.Quadruple{`0,`1,`2,`3})">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.Collections.Generic.Triple`3">
            <summary>
            Value triple.
            </summary>
            <typeparam name="T1">The first type of the triple.</typeparam>
            <typeparam name="T2">The second type of the triple.</typeparam>
            <typeparam name="T3">The third type of the triple.</typeparam>
        </member>
        <member name="P:MKY.Collections.Generic.Triple`3.Value1">
            <summary>
            Gets or sets the first value.
            </summary>
            <value>The first value.</value>
        </member>
        <member name="P:MKY.Collections.Generic.Triple`3.Value2">
            <summary>
            Gets or sets the second value.
            </summary>
            <value>The second value.</value>
        </member>
        <member name="P:MKY.Collections.Generic.Triple`3.Value3">
            <summary>
            Gets or sets the third value.
            </summary>
            <value>The third value.</value>
        </member>
        <member name="M:MKY.Collections.Generic.Triple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:ValueTriple`1"/> struct.
            </summary>
            <param name="value1">The first value.</param>
            <param name="value2">The second value.</param>
            <param name="value3">The third value.</param>
        </member>
        <member name="M:MKY.Collections.Generic.Triple`3.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Generic.Triple`3.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Generic.Triple`3.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Collections.Generic.Triple`3.Equals(MKY.Collections.Generic.Triple{`0,`1,`2})">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Generic.Triple`3.op_Equality(MKY.Collections.Generic.Triple{`0,`1,`2},MKY.Collections.Generic.Triple{`0,`1,`2})">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Collections.Generic.Triple`3.op_Inequality(MKY.Collections.Generic.Triple{`0,`1,`2},MKY.Collections.Generic.Triple{`0,`1,`2})">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.Collections.Generic.Pair`2">
            <summary>
            Value pair.
            </summary>
            <typeparam name="T1">The first type of the pair.</typeparam>
            <typeparam name="T2">The second type of the pair.</typeparam>
        </member>
        <member name="P:MKY.Collections.Generic.Pair`2.Value1">
            <summary>
            Gets or sets the first value.
            </summary>
            <value>The first value.</value>
        </member>
        <member name="P:MKY.Collections.Generic.Pair`2.Value2">
            <summary>
            Gets or sets the second value.
            </summary>
            <value>The second value.</value>
        </member>
        <member name="M:MKY.Collections.Generic.Pair`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:ValuePair`1"/> struct.
            </summary>
            <param name="value1">The first value.</param>
            <param name="value2">The second value.</param>
        </member>
        <member name="M:MKY.Collections.Generic.Pair`2.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Generic.Pair`2.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Generic.Pair`2.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Collections.Generic.Pair`2.Equals(MKY.Collections.Generic.Pair{`0,`1})">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Generic.Pair`2.op_Equality(MKY.Collections.Generic.Pair{`0,`1},MKY.Collections.Generic.Pair{`0,`1})">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Collections.Generic.Pair`2.op_Inequality(MKY.Collections.Generic.Pair{`0,`1},MKY.Collections.Generic.Pair{`0,`1})">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.Collections.Generic.VarianceWorkaround">
            <summary>
            Variance workaround, allows casts of generics (e.g. List of device to List of object).
            </summary>
            <remarks>
            Taken from "C# Programming Guide" topic "Variance in Generic Types".
            </remarks>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.Add``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1})">
            <summary>
            Simple variance for single method, variance in one direction only.
            </summary>
            <typeparam name="S">IList source.</typeparam>
            <typeparam name="D">IList destination.</typeparam>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.Convert``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Variance for enumerator, variance in one direction only so type expressions are natural.
            </summary>
            <typeparam name="S">IEnumerable source.</typeparam>
            <typeparam name="D">IEnumerable destination.</typeparam>
        </member>
        <member name="T:MKY.Collections.Generic.VarianceWorkaround.EnumerableWrapper`2">
            <summary>
            Wrapper for enumerator variance.
            </summary>
            <typeparam name="S">IEnumerable source.</typeparam>
            <typeparam name="D">IEnumerable destination.</typeparam>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.EnumerableWrapper`2.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.EnumerableWrapper`2.GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.EnumerableWrapper`2.System#Collections#IEnumerable#GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.EnumerableWrapper`2.EnumeratorWrapper.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:MKY.Collections.Generic.VarianceWorkaround.EnumerableWrapper`2.EnumeratorWrapper.Dispose"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.Convert``2(System.Collections.Generic.ICollection{``0})">
            <summary>
            Variance for collection, variance in both directions, causes issues similar to existing array variance.
            </summary>
            <typeparam name="S">ICollection source.</typeparam>
            <typeparam name="D">ICollection destination.</typeparam>
        </member>
        <member name="T:MKY.Collections.Generic.VarianceWorkaround.CollectionWrapper`2">
            <summary>
            Wrapper for collection variance.
            </summary>
            <typeparam name="S">ICollection source.</typeparam>
            <typeparam name="D">ICollection destination.</typeparam>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.CollectionWrapper`2.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.CollectionWrapper`2.Add(`1)">
            <summary>
            Variance going the wrong way...
            ...can yield exceptions at runtime.
            </summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.CollectionWrapper`2.Clear">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.CollectionWrapper`2.Contains(`1)">
            <summary>
            Variance going the wrong way...
            ...but the semantics of the method yields reasonable semantics.
            </summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.CollectionWrapper`2.CopyTo(`1[],System.Int32)">
            <summary>
            Variance going the right way...
            </summary>
        </member>
        <member name="P:MKY.Collections.Generic.VarianceWorkaround.CollectionWrapper`2.Count">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Generic.VarianceWorkaround.CollectionWrapper`2.IsReadOnly">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.CollectionWrapper`2.Remove(`1)">
            <summary>
            Variance going the wrong way...
            ...but the semantics of the method yields reasonable semantics.
            </summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.Convert``2(System.Collections.Generic.IList{``0})">
            <summary>
            Variance for collection, variance in both directions, causes issues similar to existing array variance.
            </summary>
            <typeparam name="S">IList source.</typeparam>
            <typeparam name="D">IList destination.</typeparam>
        </member>
        <member name="T:MKY.Collections.Generic.VarianceWorkaround.ListWrapper`2">
            <summary>
            Wrapper for list variance.
            </summary>
            <typeparam name="S">IList source.</typeparam>
            <typeparam name="D">IList destination.</typeparam>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.ListWrapper`2.#ctor(System.Collections.Generic.IList{`0})">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.ListWrapper`2.IndexOf(`1)">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.ListWrapper`2.Insert(System.Int32,`1)">
            <summary>
            Variance the wrong way...
            ...can throw exceptions at runtime.
            </summary>
        </member>
        <member name="M:MKY.Collections.Generic.VarianceWorkaround.ListWrapper`2.RemoveAt(System.Int32)">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Generic.VarianceWorkaround.ListWrapper`2.Item(System.Int32)">
            <summary></summary>
        </member>
        <member name="T:MKY.Collections.ObjectModel.ReadOnlyCollectionEx">
            <summary>
            <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.Collections.ObjectModel.ReadOnlyCollectionEx.ItemsEqual``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Collections.ObjectModel.ReadOnlyCollection{``0})">
            <summary>
            Determines whether the two collections have value equality, i.e. all array items have
            value equality.
            </summary>
            <remarks>
            This method has intentionally been called "ItemsEqual()"...
            ...for similar naming as <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> and...
            ...to emphasize difference to "ReadOnlyCollection.Equals()" which is just "object.Equals()".
            </remarks>
            <returns>
            True if collections have value equality, otherwise false.
            </returns>
            <typeparam name="T">The type of the array's items.</typeparam>
        </member>
        <member name="T:MKY.Collections.Specialized.RecentItem`1">
            <summary>
            Item for collections like recent files, encapsulates an item with a time stamp.
            </summary>
            <typeparam name="T">The underlying type of the recent item.</typeparam>
        </member>
        <member name="P:MKY.Collections.Specialized.RecentItem`1.Item">
            <summary>
            The recent item.
            </summary>
            <remarks>
            Set is needed for XML serialization.
            </remarks>
        </member>
        <member name="P:MKY.Collections.Specialized.RecentItem`1.TimeStamp">
            <summary>
            The time stamp to the recent item.
            </summary>
            <remarks>
            Set is needed for XML serialization.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.#ctor">
            <remarks>
            Needed for XML serialization.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.#ctor(`0)">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.#ctor(`0,System.DateTime)">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Specialized.RecentItem`1.IsValid">
            <summary>
            Checks whether the item is valid.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.Equals(MKY.Collections.Specialized.RecentItem{`0})">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.op_Equality(MKY.Collections.Specialized.RecentItem{`0},MKY.Collections.Specialized.RecentItem{`0})">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.op_Inequality(MKY.Collections.Specialized.RecentItem{`0},MKY.Collections.Specialized.RecentItem{`0})">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.CompareTo(MKY.Collections.Specialized.RecentItem{`0})">
            <summary>
            Compares this instance to a specified object and returns an indication
            of their relative values.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.Compare``1(MKY.Collections.Specialized.RecentItem{``0},MKY.Collections.Specialized.RecentItem{``0})">
            <summary></summary>
            <typeparam name="MT">The underlying type of the recent item.</typeparam>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.op_LessThan(MKY.Collections.Specialized.RecentItem{`0},MKY.Collections.Specialized.RecentItem{`0})">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.op_GreaterThan(MKY.Collections.Specialized.RecentItem{`0},MKY.Collections.Specialized.RecentItem{`0})">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.op_LessThanOrEqual(MKY.Collections.Specialized.RecentItem{`0},MKY.Collections.Specialized.RecentItem{`0})">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.op_GreaterThanOrEqual(MKY.Collections.Specialized.RecentItem{`0},MKY.Collections.Specialized.RecentItem{`0})">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.op_Implicit(MKY.Collections.Specialized.RecentItem{`0})~`0">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItem`1.op_Implicit(`0)~MKY.Collections.Specialized.RecentItem{`0}">
            <summary></summary>
        </member>
        <member name="T:MKY.Collections.Specialized.HistogramOutOfBoundsBehavior">
            <summary>
            How the histogram shall be limited.
            </summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramOutOfBoundsBehavior.Ignore">
            <summary>
            Ignores items outside <see cref="P:MKY.Collections.Specialized.Histogram`1.Min"/> and <see cref="P:MKY.Collections.Specialized.Histogram`1.Max"/>
            in case <see cref="P:MKY.Collections.Specialized.Histogram`1.AutoAdjust"/> is <c>false</c>.
            </summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramOutOfBoundsBehavior.Throw">
            <summary>
            Throws an exception for items outside <see cref="P:MKY.Collections.Specialized.Histogram`1.Min"/> and <see cref="P:MKY.Collections.Specialized.Histogram`1.Max"/>
            in case <see cref="P:MKY.Collections.Specialized.Histogram`1.AutoAdjust"/> is <c>false</c>.
            </summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramOutOfBoundsBehavior.Adjust">
            <summary>
            Items outside <see cref="P:MKY.Collections.Specialized.Histogram`1.Min"/> and <see cref="P:MKY.Collections.Specialized.Histogram`1.Max"/> let the
            histogram adjust, this is the case when <see cref="P:MKY.Collections.Specialized.Histogram`1.AutoAdjust"/> is <c>true</c>.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.Histogram`1">
            <summary>
            Collection of items of a histogram.
            </summary>
            <typeparam name="T">The type of the items of the histogram.</typeparam>
        </member>
        <member name="F:MKY.Collections.Specialized.Histogram`1.DefaultOutOfBoundsBehavior">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.MaxBinCount">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.AutoAdjust">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.OutOfBoundsBehavior">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.Min">
            <summary>The value corresponding to the smallest item, as well as the lower limit of the first bin.</summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.Max">
            <summary>The value corresponding to the biggest item, as well as the upper limit of the last bin.</summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.BinSize">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.Items">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.BinCounts">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.BinValuesLowerLimit">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.BinValuesMidPoint">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.BinValuesUpperLimit">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.#ctor(`0,`0,System.Int32,MKY.Collections.Specialized.HistogramOutOfBoundsBehavior)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.Histogram`1"/> class with equally
            distributed bins, fixed to the given arguments.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.Histogram`1"/> class with equally
            distributed bins, automatically adjusting <see cref="P:MKY.Collections.Specialized.Histogram`1.BinSize"/> as well as
            <see cref="P:MKY.Collections.Specialized.Histogram`1.BinCount"/> up to <paramref name="maxBinCount"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.InitializeBins(System.Int32,System.Int32)">
            <summary></summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.BinCount">
            <summary>
            Gets the current number of bins.
            </summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.ValuesLowerLimit">
            <summary>
            Gets the current values of the bins.
            </summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.ValuesMidPoint">
            <summary>
            Gets the current values of the bins.
            </summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.ValuesUpperLimit">
            <summary>
            Gets the current values of the bins.
            </summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.Counts">
            <summary>
            Gets the current counts.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.CalculateBinSize(`0,`0,System.Int32)">
            <summary>
            Calculates the current size of a bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.CalculateBinCount(`0,`0,`0)">
            <summary>
            Calculates the current number of bins.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.CalculateBinValues(System.Int32,`0@,`0@,`0@)">
            <summary>
            Calculates the values of the given bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.GetIndex(`0)">
            <summary>
            Gets the index of the bin corresponding to <paramref name="item"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.IncrementBin(System.Int32)">
            <summary>
            Increments the corresponding bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.IncrementBin(`0)">
            <summary>
            Increments the corresponding bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.Add(`0)">
            <summary>
            Adds an item to the histogram.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds items to the histogram.
            </summary>
        </member>
        <member name="P:MKY.Collections.Specialized.Histogram`1.ItemCount">
            <summary>
            Gets the current number of items added by <see cref="M:MKY.Collections.Specialized.Histogram`1.Add(`0)"/> and <see cref="M:MKY.Collections.Specialized.Histogram`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.AdjustAsNeededAndIncrementBin(`0)">
            <summary>
            Lets the collection adjust as needed.
            </summary>
            <param name="item">
            The item just added that triggered calling this method.
            </param>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.IsWithinProximityOfBinValue(`0,System.Int32@)">
            <summary>
            Evaluates whether the value is within the proximity of a bin value.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.IsWithinProximityOfPreviouslyContainedItem(`0)">
            <summary>
            Evaluates whether the value is within the proximity of a previously contained item.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.AdjustByBinCountKeepingBinSizeAndIncrementBin(`0,`0,`0)">
            <summary>
            Adjusts the histogram by increasing <see cref="P:MKY.Collections.Specialized.Histogram`1.BinCount"/>, keeping <see cref="P:MKY.Collections.Specialized.Histogram`1.BinSize"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.AdjustByBinSizeAndReincrementBins(System.Int32)">
            <summary>
            Adjusts the histogram by increasing <see cref="P:MKY.Collections.Specialized.Histogram`1.BinSize"/>, keeping <see cref="P:MKY.Collections.Specialized.Histogram`1.Min"/> and <see cref="P:MKY.Collections.Specialized.Histogram`1.Max"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.Histogram`1.GetProximity(`0,`0@,`0@)">
            <summary>
            Gets the proximity around a <paramref name="value"/> in the histogram,
            taking <see cref="P:MKY.Collections.Specialized.Histogram`1.MaxBinCount"/> into account.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.HistogramInt32">
            <summary>
            Collection of items of type <see cref="T:System.Int32"/> of a histogram.
            </summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramInt32.DefaultMin">
            <summary></summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramInt32.DefaultMax">
            <summary></summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramInt32.DefaultBinCount">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt32.#ctor(System.Int32,System.Int32,System.Int32,MKY.Collections.Specialized.HistogramOutOfBoundsBehavior)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.HistogramInt32"/> class with equally
            distributed bins, fixed to the given arguments.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt32.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.HistogramInt32"/> class with equally
            distributed bins, automatically rearranging up to <paramref name="maxBinCount"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt32.CalculateBinSize(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the current size of a bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt32.CalculateBinCount(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the current number of bins.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt32.CalculateBinValues(System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Calculates the values of the given bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt32.GetIndex(System.Int32)">
            <summary>
            Gets the index of the bin corresponding to <paramref name="item"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt32.GetProximity(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Gets the proximity around a <paramref name="value"/> in the histogram,
            taking <see cref="P:MKY.Collections.Specialized.Histogram`1.MaxBinCount"/> into account.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.HistogramInt64">
            <summary>
            Collection of items of type <see cref="T:System.Int64"/> of a histogram.
            </summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramInt64.DefaultMin">
            <summary></summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramInt64.DefaultMax">
            <summary></summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramInt64.DefaultBinCount">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt64.#ctor(System.Int64,System.Int64,System.Int32,MKY.Collections.Specialized.HistogramOutOfBoundsBehavior)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.HistogramInt64"/> class with equally
            distributed bins, fixed to the given arguments.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt64.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.HistogramInt64"/> class with equally
            distributed bins, automatically rearranging up to <paramref name="maxBinCount"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt64.CalculateBinSize(System.Int64,System.Int64,System.Int32)">
            <summary>
            Calculates the current size of a bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt64.CalculateBinCount(System.Int64,System.Int64,System.Int64)">
            <summary>
            Calculates the current number of bins.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt64.CalculateBinValues(System.Int32,System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            Calculates the values of the given bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt64.GetIndex(System.Int64)">
            <summary>
            Gets the index of the bin corresponding to <paramref name="item"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramInt64.GetProximity(System.Int64,System.Int64@,System.Int64@)">
            <summary>
            Gets the proximity around a <paramref name="value"/> in the histogram,
            taking <see cref="P:MKY.Collections.Specialized.Histogram`1.MaxBinCount"/> into account.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.HistogramDouble">
            <summary>
            Collection of items of type <see cref="T:System.Double"/> of a histogram.
            </summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramDouble.DefaultMin">
            <summary></summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramDouble.DefaultMax">
            <summary></summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramDouble.DefaultBinCount">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDouble.#ctor(System.Double,System.Double,System.Int32,MKY.Collections.Specialized.HistogramOutOfBoundsBehavior)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.HistogramDouble"/> class with equally
            distributed bins, fixed to the given arguments.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDouble.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.HistogramDouble"/> class with equally
            distributed bins, automatically rearranging up to <paramref name="maxBinCount"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDouble.CalculateBinSize(System.Double,System.Double,System.Int32)">
            <summary>
            Calculates the current size of a bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDouble.CalculateBinCount(System.Double,System.Double,System.Double)">
            <summary>
            Calculates the current number of bins.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDouble.CalculateBinValues(System.Int32,System.Double@,System.Double@,System.Double@)">
            <summary>
            Calculates the values of the given bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDouble.GetIndex(System.Double)">
            <summary>
            Gets the index of the bin corresponding to <paramref name="item"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDouble.GetProximity(System.Double,System.Double@,System.Double@)">
            <summary>
            Gets the proximity around a <paramref name="value"/> in the histogram,
            taking <see cref="P:MKY.Collections.Specialized.Histogram`1.MaxBinCount"/> into account.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.HistogramDecimal">
            <summary>
            Collection of items of type <see cref="T:System.Decimal"/> of a histogram.
            </summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramDecimal.DefaultMin">
            <summary></summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramDecimal.DefaultMax">
            <summary></summary>
        </member>
        <member name="F:MKY.Collections.Specialized.HistogramDecimal.DefaultBinCount">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDecimal.#ctor(System.Decimal,System.Decimal,System.Int32,MKY.Collections.Specialized.HistogramOutOfBoundsBehavior)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.HistogramDecimal"/> class with equally
            distributed bins, fixed to the given arguments.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDecimal.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.HistogramDecimal"/> class with equally
            distributed bins, automatically rearranging up to <paramref name="maxBinCount"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDecimal.CalculateBinSize(System.Decimal,System.Decimal,System.Int32)">
            <summary>
            Calculates the current size of a bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDecimal.CalculateBinCount(System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Calculates the current number of bins.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDecimal.CalculateBinValues(System.Int32,System.Decimal@,System.Decimal@,System.Decimal@)">
            <summary>
            Calculates the values of the given bin.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDecimal.GetIndex(System.Decimal)">
            <summary>
            Gets the index of the bin corresponding to <paramref name="item"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.HistogramDecimal.GetProximity(System.Decimal,System.Decimal@,System.Decimal@)">
            <summary>
            Gets the proximity around a <paramref name="value"/> in the histogram,
            taking <see cref="P:MKY.Collections.Specialized.Histogram`1.MaxBinCount"/> into account.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.RecentItemCollection`1">
            <summary>
            Collection for recent items like recent files, provides methods to handle the recent items.
            </summary>
            <typeparam name="T">The underlying type of the recent item.</typeparam>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItemCollection`1.#ctor">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItemCollection`1.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItemCollection`1.#ctor(System.Collections.Generic.IEnumerable{MKY.Collections.Specialized.RecentItem{`0}})">
            <summary></summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItemCollection`1.Add(`0)">
            <summary>
            Adds the item to the collection. The item will be inserted at the beginning of
            the collection (least recent). If the collection already contains the specified number
            of items (<see cref="T:RecentItemCollection`1.Capacity"/>), the most recent item will
            be removed from the collection.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItemCollection`1.Add(MKY.Collections.Specialized.RecentItem{`0})">
            <summary>
            Adds the item to the collection. The item will be inserted at the location according
            to the time stamp of the item. If the collection already contains the specified number
            of items (<see cref="T:RecentItemCollection`1.Capacity"/>), the most recent item will
            be removed from the collection.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItemCollection`1.AddRange(System.Collections.Generic.IEnumerable{MKY.Collections.Specialized.RecentItem{`0}})">
            <summary>
            Adds the items to the collection. The items will be inserted at the location according
            to the time stamp of the item. If the collection already contains the specified number
            of items (<see cref="T:RecentItemCollection`1.Capacity"/>), the most recent item will
            be removed from the collection.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItemCollection`1.Contains(`0)">
            <summary>
            Determines whether collection contains the specified item.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItemCollection`1.RemoveMostRecent">
            <summary>
            Remove the most recent item if the collection already contains <see cref="T:RecentItemCollection`1.Capacity"/> items.
            </summary>
            <returns>
            <c>true</c> if an item is successfully removed; otherwise, <c>false</c>.
            <c>false</c> is also returned if no item was not found in the collection.
            </returns>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItemCollection`1.RemoveDuplicates">
            <summary>
            Removes all more recent duplicates from the collection, i.e. copies of items that have
            an older time stamp.
            </summary>
            <returns>
            The number of duplicates removed from the collection.
            </returns>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItemCollection`1.ValidateAll">
            <summary>
            Validates all recent items, invalid items are removed from the collection.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.RecentItemCollection`1.UpdateFrom(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Updates this collection from the given array.
            </summary>
            <returns>
            Returns whether collection has changed.
            </returns>
        </member>
        <member name="T:MKY.Collections.Specialized.TimedMovingAverage`1">
            <summary>
            Simple moving average based on <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
            <typeparam name="T">The type of the items of the collection.</typeparam>
        </member>
        <member name="P:MKY.Collections.Specialized.TimedMovingAverage`1.IntervalMs">
            <summary>
            The interval of the average in milliseconds.
            </summary>
        </member>
        <member name="P:MKY.Collections.Specialized.TimedMovingAverage`1.IntervalTicks">
            <summary>
            The interval of the average in ticks.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverage`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.TimedMovingAverage`1"/> class.
            </summary>
            <param name="intervalMs">The interval of the average in milliseconds.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="intervalMs"/> is equal or less than 0 ms.</exception>
        </member>
        <member name="P:MKY.Collections.Specialized.TimedMovingAverage`1.Value">
            <summary>
            The current value of the moving average.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverage`1.Enqueue(`0)">
            <summary>
            Enqueues a value.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverage`1.Enqueue(`0,System.DateTime)">
            <summary>
            Enqueues a value.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverage`1.Enqueue(`0,System.Int64)">
            <summary>
            Enqueues a value.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverage`1.EnqueueAndCalculate(`0)">
            <summary>
            Enqueues a value and immediately calculates the average.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverage`1.Calculate">
            <summary>
            Calculates the average.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverage`1.Avg(System.Tuple{`0,System.Int64}[])">
            <summary>
            Averages the given items; must be implemented by the deriving class.
            </summary>
            <remarks>
            Required to not have to use the dynamic keyword (which would require a reference to the
            "Microsoft.CSharp" assembly) nor <see cref="T:System.Linq.Expressions.Expression"/> (which
            has much less performance).
            See e.g. https://stackoverflow.com/questions/8122611/c-sharp-adding-two-generic-values
            for background and discussion.
            </remarks>
        </member>
        <member name="T:MKY.Collections.Specialized.TimedMovingAverageInt32">
            <summary>
            Simple moving average based on <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverageInt32.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.TimedMovingAverage`1"/> class.
            </summary>
            <param name="length">The length of the average.</param>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverageInt32.Avg(System.Tuple{System.Int32,System.Int64}[])">
            <summary>
            Adds two values.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.TimedMovingAverageInt64">
            <summary>
            Simple moving average based on <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverageInt64.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.TimedMovingAverage`1"/> class.
            </summary>
            <param name="length">The length of the average.</param>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverageInt64.Avg(System.Tuple{System.Int64,System.Int64}[])">
            <summary>
            Adds two values.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.TimedMovingAverageDouble">
            <summary>
            Simple moving average based on <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverageDouble.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.TimedMovingAverage`1"/> class.
            </summary>
            <param name="length">The length of the average.</param>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverageDouble.Avg(System.Tuple{System.Double,System.Int64}[])">
            <summary>
            Adds two values.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.TimedMovingAverageTimeSpan">
            <summary>
            Simple moving average based on <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverageTimeSpan.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.TimedMovingAverage`1"/> class.
            </summary>
            <param name="length">The length of the average.</param>
        </member>
        <member name="M:MKY.Collections.Specialized.TimedMovingAverageTimeSpan.Avg(System.Tuple{System.TimeSpan,System.Int64}[])">
            <summary>
            Adds two values.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.MovingAverage`1">
            <summary>
            Simple moving average based on <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
            <typeparam name="T">The type of the items of the collection.</typeparam>
        </member>
        <member name="P:MKY.Collections.Specialized.MovingAverage`1.Length">
            <summary>
            The length of the average.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverage`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.MovingAverage`1"/> class.
            </summary>
            <param name="length">The length of the average.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length"/> is equal or less than 0.</exception>
        </member>
        <member name="P:MKY.Collections.Specialized.MovingAverage`1.Value">
            <summary>
            The current value of the moving average.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverage`1.Enqueue(`0)">
            <summary>
            Enqueues a value.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverage`1.EnqueueAndCalculate(`0)">
            <summary>
            Enqueues a value and immediately calculates the average.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverage`1.Calculate">
            <summary>
            Calculates the average.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverage`1.Avg(`0[])">
            <summary>
            Averages the given items; must be implemented by the deriving class.
            </summary>
            <remarks>
            Required to not have to use the dynamic keyword (which would require a reference to the
            "Microsoft.CSharp" assembly) nor <see cref="T:System.Linq.Expressions.Expression"/> (which
            has much less performance).
            See e.g. https://stackoverflow.com/questions/8122611/c-sharp-adding-two-generic-values
            for background and discussion.
            </remarks>
        </member>
        <member name="T:MKY.Collections.Specialized.MovingAverageInt32">
            <summary>
            Simple moving average based on <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverageInt32.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.MovingAverage`1"/> class.
            </summary>
            <param name="length">The length of the average.</param>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverageInt32.Avg(System.Int32[])">
            <summary>
            Adds two values.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.MovingAverageInt64">
            <summary>
            Simple moving average based on <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverageInt64.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.MovingAverage`1"/> class.
            </summary>
            <param name="length">The length of the average.</param>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverageInt64.Avg(System.Int64[])">
            <summary>
            Adds two values.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.MovingAverageDouble">
            <summary>
            Simple moving average based on <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverageDouble.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.MovingAverage`1"/> class.
            </summary>
            <param name="length">The length of the average.</param>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverageDouble.Avg(System.Double[])">
            <summary>
            Adds two values.
            </summary>
        </member>
        <member name="T:MKY.Collections.Specialized.MovingAverageTimeSpan">
            <summary>
            Simple moving average based on <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverageTimeSpan.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.Specialized.MovingAverage`1"/> class.
            </summary>
            <param name="length">The length of the average.</param>
        </member>
        <member name="M:MKY.Collections.Specialized.MovingAverageTimeSpan.Avg(System.TimeSpan[])">
            <summary>
            Adds two values.
            </summary>
        </member>
        <member name="T:MKY.Collections.IListEx">
            <summary>
            <see cref="T:System.Collections.IList"/> utility methods.
            </summary>
        </member>
        <member name="F:MKY.Collections.IListEx.InvalidIndex">
            <summary>
            An invalid index is represented by -1.
            </summary>
        </member>
        <member name="T:MKY.Collections.IEnumeratorEx">
            <summary>
            <see cref="T:System.Collections.IEnumerator"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.Collections.IEnumeratorEx.ItemsEqual(System.Collections.IEnumerator,System.Collections.IEnumerator)">
            <summary>
            Determines whether the two enumerated objects have value equality, i.e. contains the
            same number of items, all items are equally sequenced and have value equality.
            </summary>
            <remarks>
            This method has intentionally been called "ItemsEqual()"...
            ...for similar naming as <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> and...
            ...to emphasize difference to "IEnumerator.Equals()" which is just "object.Equals()".
            </remarks>
            <returns>
            True if enumerated objects have value equality, otherwise false.
            </returns>
        </member>
        <member name="T:MKY.Collections.IEnumerableEx">
            <summary>
            <see cref="T:System.Collections.IEnumerable"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.Collections.IEnumerableEx.ItemsEqual(System.Collections.IEnumerable,System.Collections.IEnumerable)">
            <summary>
            Determines whether the two enumerable objects have value equality, i.e. contains the
            same number of items, all items are equally sequenced and have value equality.
            </summary>
            <remarks>
            This method has intentionally been called "ItemsEqual()"...
            ...for similar naming as <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> and...
            ...to emphasize difference to "IEnumerable.Equals()" which is just "object.Equals()".
            </remarks>
            <returns>
            True if enumerable objects have value equality, otherwise false.
            </returns>
        </member>
        <member name="M:MKY.Collections.IEnumerableEx.ItemsToString(System.Collections.IEnumerable,System.String)">
            <summary>
            Appends all items of an enumerable object to a comma separated string and returns it.
            Items that are <c>null</c> are returned as "(null)".
            An empty <paramref name="collection"/> is returned as "(empty)".
            </summary>
            <returns>
            String containing values of all items.
            </returns>
        </member>
        <member name="M:MKY.Collections.IEnumerableEx.ItemsToString(System.Collections.IEnumerable,System.Char)">
            <summary>
            Appends all items of an enumerable object to a comma separated string and returns it.
            Items that are <c>null</c> are returned as "(null)".
            </summary>
            <returns>
            String containing values of all items.
            </returns>
        </member>
        <member name="M:MKY.Collections.IEnumerableEx.ItemsToHashCode(System.Collections.IEnumerable)">
            <summary>
            Serves as a hash function that iterates over all items within the given collection.
            </summary>
        </member>
        <member name="T:MKY.Collections.NamedStringDictionary">
            <summary>
            A collection containing one or more sets of test settings.
            </summary>
        </member>
        <member name="P:MKY.Collections.NamedStringDictionary.Name">
            <summary>
            Gets or sets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="M:MKY.Collections.NamedStringDictionary.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.NamedStringDictionary"/> class.
            </summary>
        </member>
        <member name="M:MKY.Collections.NamedStringDictionary.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.NamedStringDictionary"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:MKY.Collections.NamedStringDictionary.Settings">
            <summary>
            Gets or sets the settings.
            </summary>
            <value>The settings.</value>
        </member>
        <member name="P:MKY.Collections.NamedStringDictionary.Keys">
            <summary>
            Gets the keys.
            </summary>
            <value>The keys.</value>
        </member>
        <member name="P:MKY.Collections.NamedStringDictionary.Item(System.String)">
            <summary>
            Gets the <see cref="T:System.String"/> with the specified key.
            </summary>
        </member>
        <member name="M:MKY.Collections.NamedStringDictionary.Clear">
            <summary>
            Clears all settings.
            </summary>
        </member>
        <member name="M:MKY.Collections.NamedStringDictionary.Add(System.String,System.String)">
            <summary>
            Adds the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:MKY.Collections.NamedStringDictionary.ContainsKey(System.String)">
            <summary>
            Determines whether the specified key contains key.
            </summary>
            <param name="key">The key.</param>
            <returns>
            <c>true</c> if the specified key contains key; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MKY.Collections.NamedStringDictionary.TryGetValue(System.String,System.String@)">
            <summary>
            Tries to get value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>
            <c>true</c> if the value at the specified key could be retrieved; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:MKY.Collections.StringKeyValuePair">
            <summary>
            Serializable string key/value-pair.
            </summary>
            <remarks>
            Required because <see cref="T:KeyValuePair`1"/> doesn't properly serialize
            its contents even though it is marked <see cref="T:System.SerializableAttribute"/>.
            </remarks>
        </member>
        <member name="P:MKY.Collections.StringKeyValuePair.Key">
            <summary>
            Gets or sets the key.
            </summary>
            <value>The key.</value>
        </member>
        <member name="P:MKY.Collections.StringKeyValuePair.Value">
            <summary>
            Gets or sets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:MKY.Collections.StringKeyValuePair.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Collections.StringKeyValuePair"/> struct.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:MKY.Collections.StringKeyValuePair.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.StringKeyValuePair.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.StringKeyValuePair.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Collections.StringKeyValuePair.Equals(MKY.Collections.StringKeyValuePair)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Collections.StringKeyValuePair.op_Equality(MKY.Collections.StringKeyValuePair,MKY.Collections.StringKeyValuePair)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Collections.StringKeyValuePair.op_Inequality(MKY.Collections.StringKeyValuePair,MKY.Collections.StringKeyValuePair)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.CommandLine.ArgsDefault">
            <summary>
            Helper class.
            </summary>
        </member>
        <member name="F:MKY.CommandLine.ArgsDefault.Empty">
            <summary>
            The default value of a C# <code>main(string[])</code> is an
            empty <see cref="T:System.String"/> <see cref="T:System.Array"/>, not <c>null</c>.
            </summary>
        </member>
        <member name="T:MKY.CommandLine.ArgsHandler">
             <summary>
             This command line infrastructure is based on the NUnit command line infrastructure:
             > NUnit version 2.5.10 (2011-03-14)
             > NUnit file "/src/ClientUtilities/util/CommandLineOptions.cs" (nunit.util.dll)
            
             See below for original file header content:
             -------------------------------------------------------------------------------------------
             This is a re-usable component to be used when you need to parse command-line options and
             parameters. It separates command line parameters from command line options. It uses
             reflection to populate member variables the derived class with the values of the options.
            
             An option can start with "-" or "--". On Windows systems, it can start with "/" as well.
            
             I define 3 types of "options":
               1. Boolean options (yes/no values), e.g. /r to recurse
               2. Value options, e.g. /loglevel=3
               3. Parameters, i.e. standalone strings like file names
            
             An example to explain:
               csc /nologo /t:exe myfile.cs
                   |       |      |
                   |       |      + parameter
                   |       |
                   |       + value option
                   |
                   + boolean option
            
             Please see a short description of the CommandLineOptions class
             at http://codeblast.com/~gert/dotnet/sells.html
            
             Gert Lombard (gert@codeblast.com)
             James Newkirk (jim@nunit.org)
             -------------------------------------------------------------------------------------------
            
             The implementation has been copied and improved to be more .NET-ish and edited to comply
             with the YAT/MKY naming and coding conventions such as passing FxCop and StyleCop analysis.
            
             In addition, this implementation has added so-called array-options. Array-options can be
             used to deal with a variable number of additional argument, i.e. ellipsis. This feature is
             optional.
            
             An alternative command line infrastructure can be found at http://commandline.codeplex.com/.
             </summary>
        </member>
        <member name="F:MKY.CommandLine.ArgsHandler.MinorIndent">
            <summary></summary>
        </member>
        <member name="F:MKY.CommandLine.ArgsHandler.MajorIndent">
            <summary></summary>
        </member>
        <member name="F:MKY.CommandLine.ArgsHandler.AllowForwardSlash">
            <summary>
            Gets a value indicating whether forward slashes are allowed as option indicator.
            This applies to Windows systems.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.#ctor(System.String[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.CommandLine.ArgsHandler"/> class.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.HasBeenProcessed">
            <summary>
            Gets a value indicating whether this instance has been processed.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.HasBeenValidated">
            <summary>
            Gets a value indicating whether this instance has been validated.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.IsValid">
            <summary>
            Gets a value indicating whether this instance is valid.
            </summary>
            <remarks>
            Until the args have been validated using <see cref="M:MKY.CommandLine.ArgsHandler.ProcessAndValidate"/>,
            this property returns <c>false</c>.
            </remarks>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.ValueArgs">
            <summary>
            Gets the value arguments.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.ValueArgsCount">
            <summary>
            Gets the value argument count.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.OptionArgs">
            <summary>
            Gets the option arguments.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.OptionArgsCount">
            <summary>
            Gets the option argument count.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.ArrayOptionArgs">
            <summary>
            Gets the array option arguments.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.ArrayOptionArgsCount">
            <summary>
            Gets the option argument count.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.ValidArgsCount">
            <summary>
            Gets the total valid argument count.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.InvalidArgs">
            <summary>
            Gets the invalid arguments.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.InvalidArgsCount">
            <summary>
            Gets the invalid argument count.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.ArgsCount">
            <summary>
            Gets the total argument count.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.HasNoArgs">
            <summary>
            Indicates that there are no args at all.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:System.String"/> at the specified index.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.InvalidationMessages">
            <summary>
            Gets the invalidation messages.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.InvalidationMessagesCount">
            <summary>
            Gets the invalidation message count.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.GetMemberFields">
            <summary></summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.GetValueArgAttributes(System.Reflection.FieldInfo)">
            <summary></summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.GetOptionArgAttributes(System.Reflection.FieldInfo)">
            <summary></summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.GetMemberField(System.String)">
            <summary>
            Gets the member field.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.MatchesName(System.Reflection.FieldInfo,System.String)">
            <summary>
            Matches the name.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.MatchesShortName(System.Reflection.FieldInfo,System.String)">
            <summary>
            Matches the short name.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.SupportValueArgs">
            <summary>
            Determines whether value args are supported.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.SupportOptionArgs">
            <summary>
            Determines whether option args are supported.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.ArgsHandler.SupportArrayOptionArgs">
            <summary>
            Determines whether array option args are supported.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.IsOptionNameChar(System.Char)">
            <summary>
            Determines whether the specified character is a valid option name character.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.IsOption(System.String,System.Int32@)">
            <summary>
            Determines whether the specified argument is an option and returns the position of
            the first character of the option name. An option starts with "/", "-" or "--".
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.IsOptionStart(System.String)">
            <summary>
            Determines whether the specified argument string starts with an option start sequence.
            An option starts with "/", "-" or "--".
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.IsOptionStart(System.String,System.Int32@)">
            <summary>
            Determines whether the specified argument starts with an option start sequence and
            returns the position of the first character of the option name. An option starts
            with "/", "-" or "--".
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.ParseOption(System.String,System.String,System.Boolean@,System.Object@,System.Reflection.FieldInfo@)">
            <summary>
            Initializes an option argument.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.InitializeOption(System.Reflection.FieldInfo,System.Object)">
            <summary>
            Initializes an option argument.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.InitializeArrayOption(System.Reflection.FieldInfo,System.Object[])">
            <summary>
            Initializes an option argument.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.SplitOptionAndValue(System.String,System.String@,System.String@)">
            <summary>
            Splits the option and value.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.IsValue(System.String)">
            <summary>
            Determines whether the specified argument is a value argument. A value argument must
            not start with "/", "-" or "--". Additional rules can be defined by overriding this
            method.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.InitializeValue(System.String,System.Int32)">
            <summary>
            Initializes a value argument.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.IsValidValueArg(System.String)">
            <summary>
            Determines whether the specified argument is a valid value argument.
            Override this method to implement application specific validation logic.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.Validate">
            <summary>
            Processes the command line options and validates them.
            Override this method to implement application specific validation logic.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.Invalidate(System.String)">
            <summary>
            Invalidates the command line argument object by a dedicated message.
            </summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.Override(System.String,System.Object)">
             <summary>
             Overrides an argument. This can be useful to default arguments at runtime, e.g. after
             the command line has been received but before it is processed, no matter what the
             command line is set to.
             </summary>
             <remarks>
             This mechanism allows to override an argument WITHOUT changing the original command line.
            
             Unfortunately, there is no practicable way to use a delegate to access a field, nor an
             easy way to get a <see cref="T:System.Reflection.FieldInfo"/> of a given class' field. So, the field name
             is used to reflect the field.
             </remarks>
             <param name="fieldName">The name of the argument to.</param>
             <param name="value">The value of the argument.</param>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.ProcessAndValidate">
            <summary>
            Processes and validates the specified args.
            </summary>
            <returns>
            Returns <c>true</c> if the specified args could successfully be processed and validated,
            <c>false</c> otherwise.
            </returns>
            <remarks>
            This method intentionally is public, and not called by the constructor, because it
            calls virtual methods. If a derived class has overridden such a method, the derived
            class version will be called before the derived class constructor is called. Finding
            of FxCop.
            This method may be called multiple times. Upon each call, the state of the object is
            reset and all arguments are processed and validated.
            </remarks>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.OptionIsGiven(System.String)">
            <summary></summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.IndentSpace(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.SplitIntoLines(System.Int32,System.Int32,System.String)">
            <summary></summary>
        </member>
        <member name="M:MKY.CommandLine.ArgsHandler.GetHelpText(System.Int32)">
            <summary>
            Gets the help text.
            </summary>
        </member>
        <member name="T:MKY.CommandLine.OptionArgAttribute">
            <summary>
            Attribute to mark an option argument.
            </summary>
            <remarks>
            This class is based on the NUnit command line infrastructure. See <see cref="T:MKY.CommandLine.ArgsHandler"/> for details.
            Sealed to improve performance during reflection on custom attributes according to FxCop:CA1813.
            </remarks>
        </member>
        <member name="P:MKY.CommandLine.OptionArgAttribute.Names">
            <summary>
            Gets or sets one or more names.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.OptionArgAttribute.Name">
            <summary>
            Gets or sets a single name.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.OptionArgAttribute.ShortNames">
            <summary>
            Gets or sets one or more short names.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.OptionArgAttribute.ShortName">
            <summary>
            Gets or sets a single short name.
            </summary>
        </member>
        <member name="P:MKY.CommandLine.OptionArgAttribute.Description">
            <summary>
            Gets or sets the description.
            </summary>
        </member>
        <member name="T:MKY.CommandLine.ValueArgAttribute">
            <summary>
            Attribute to mark a value argument.
            </summary>
            <remarks>
            This class is based on the NUnit command line infrastructure. See <see cref="T:MKY.CommandLine.ArgsHandler"/> for details.
            Sealed to improve performance during reflection on custom attributes according to FxCop:CA1813.
            </remarks>
        </member>
        <member name="P:MKY.CommandLine.ValueArgAttribute.Description">
            <summary>
            Gets or sets the description.
            </summary>
        </member>
        <member name="T:MKY.ComponentModel.StringCancelEventArgs">
             <summary>
             Cancel event args with a string value.
             </summary>
             <remarks>
             \remind (2017-07-23 / MKY)
             This class could be implemented with a generic type argument instead of being fixed to
             <see cref="T:System.String"/>. However, the VS2015 designer cannot cope with generic event args!
             Findings:
              > Designer cannot display the 'SendCommandRequest' of 'SendText' as well as 'Send'.
              > It crashes again and again! But is this indeed the root cause?
            
             \todo
             Check again with VS2017+.
             </remarks>
        </member>
        <member name="P:MKY.ComponentModel.StringCancelEventArgs.Value">
            <summary></summary>
        </member>
        <member name="M:MKY.ComponentModel.StringCancelEventArgs.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:MKY.ComponentModel.StringCancelEventArgs.#ctor(System.String,System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:MKY.Configuration.MergeableConfigurationSection">
            <summary></summary>
        </member>
        <member name="M:MKY.Configuration.MergeableConfigurationSection.MergeWith(MKY.Configuration.MergeableConfigurationSection)">
            <summary>
            Merges the configuration with alternative configurations.
            </summary>
            <param name="configurationsToBeMergedWith">The configurations to be merged with.</param>
        </member>
        <member name="T:MKY.Configuration.Provider">
             <summary>
             For software testing on computers it may be necessary to configure a test case to a given
             test environment. For example, a certain test may not be ran on a machine that misses a
             certain hardware. Or, a test may need to be configured to access a certain file that is
             located at a local path.
             This class in conjunction with <see cref="T:MKY.Configuration.MergeableConfigurationSection"/>, <see cref="T:MKY.Configuration.SelectionSection"/>
             as well as <see cref="T:MKY.Configuration.Selector"/> provides the infrastructure that is needed to implement
             test cases as described above. Basically, this infrastructure features a way to retrieve
             settings from a three-tier configuration environment:
             (1) Each setting must be hard-coded in a class that derives from <see cref="T:MKY.Configuration.MergeableConfigurationSection"/>.
                 This class must contain hard-coded default values for each setting.
             (2) The default configuration can be overridden by solution specific defaults in a file
                 'SolutionName'.config in the solution's root directory. These solution specific defaults
                 are to be checked in into the source code control system and are the same for all
                 developers.
             (3) The settings may be overridden again by machine specific configuration files
                 'TestProject'.config that can be located anywhere on the local file system. The location
                 of each file is resolved via a system variable 'TEST_PROJECT'_CONFIG_FILE.
            
             Example:
             "MKY.IO.Ports.Test.ConfigurationSection" implements settings to select the serial COM ports
             used in the test cases. Each setting is implemented as a <see cref="T:System.Configuration.ConfigurationProperty"/>
             and consists of the name, the data type and the default value (1).
             "YAT.config" contains a "MKY.IO.Ports.Test.Configuration" configuration group that defines the
             typical values used for YAT testing (2).
             "MKY.IO.Ports.Test.config" located at a certain machine defines which serial COM
             ports are available on that machine (3).
            
             Whenever the test suite, e.g. NUnit based, loads the test cases, the configurations are read
             and the test cases configured accordingly. The configuration providers may also implement logic
             that verifies whether the configuration really make sense on the current machine.
            
             In addition to the mechanism described above, the configuration may contain multiple values
             for each setting. Each set of values is collected in a <see cref="T:System.Configuration.ConfigurationSectionGroup"/>.
             The desired set can be selected using a <see cref="T:MKY.Configuration.SelectionSection"/>. It is also possible
             that one tier, e.g. (2), defines multiple sets and the next tier, e.g. (3), simply selects
             one of the sets defined by (2).
            
             Example:
             File 'YAT.Test.config' first announces the selector section:
                 sectionGroup name="MKY.IO.Ports.Test.Configuration" type="System.Configuration.ConfigurationSectionGroup"
                     section name="Selection" type="MKY.Configuration.SelectionSection, MKY"
             Then it lists the available sets of values in a section group:
                 sectionGroup name="MKY.IO.Ports.Test.Configuration.Configurations" type="System.Configuration.ConfigurationSectionGroup"
                     section name="NoDevices" type="MKY.IO.Ports.Test.ConfigurationSection, MKY.IO.Ports.Test"
                     section name="UsingPhysicalDevices" type="MKY.IO.Ports.Test.ConfigurationSection, MKY.IO.Ports.Test"
                     section name="UsingVirtualDevices" type="MKY.IO.Ports.Test.ConfigurationSection, MKY.IO.Ports.Test"
             Finally, the values for each section:
                 MKY.IO.Ports.Test.Configuration
                     Selection SelectedConfigurationName="NoDevices"
                 MKY.IO.Ports.Test.Configuration.Sections
                     NoDevices PortA="" PortB=""
                     UsingPhysicalDevices PortA="COM1" PortB="COM2"
                     UsingVirtualDevices PortA="COM101" PortB="COM102"
             These solution defaults may then be partly or completely overridden by the machine specific
             configuration file 'MKY.IO.Ports.Test.config':
                 MKY.IO.Ports.Test.Configuration
                     Selection SelectedConfigurationName="UsingPhysicalDevices"
            
             Saying hello to StyleCop ;-.
             </summary>
             <remarks>
             Debugging this configuration infrastructure may be a bit trickier than normal debugging.
             E.g. if the configuration is used to parameterize NUnit test cases, the follow steps worked
             with .NET 3.5:
             1. Build the solution
             2. Start NUnit
             3. 'Debug > Attach' Visual Studio to NUnit
             4. Set a breakpoint a the desired location below
             5. Reload the project in NUnit
                => Breakpoint is hit.
            
             However, with .NET 4.0 this no longer works, thus the workaround below.
             Check again when upgrading to NUnit 3.x (FR #293).
             </remarks>
        </member>
        <member name="M:MKY.Configuration.Provider.TryOpenAndMergeConfigurations``1(System.String,System.String,System.String,``0@)">
            <summary>
            Tries the open and merge configurations.
            </summary>
            <typeparam name="T">The type of the section to retrieve.</typeparam>
            <param name="selectionGroupName">Name of the selection configuration group.</param>
            <param name="sectionsGroupName">Name of the configuration sections group.</param>
            <param name="userConfigurationEnvironmentVariableName">Name of the user configuration environment variable.</param>
            <param name="resultingConfiguration">The resulting configuration (default, solution, user or merged).</param>
        </member>
        <member name="M:MKY.Configuration.Provider.TryOpenAndMergeConfigurations``1(System.String,System.String,System.String,System.String,``0@)">
            <summary>
            Tries the open and merge configurations.
            </summary>
            <typeparam name="T">The type of the section to retrieve.</typeparam>
            <param name="selectionGroupName">Name of the selection configuration group.</param>
            <param name="sectionsGroupName">Name of the configuration sections group.</param>
            <param name="solutionConfigurationFileNameSuffix">An optional suffix to select a dedicated file (e.g. ".Test" for a test configuration file).</param>
            <param name="userConfigurationEnvironmentVariableName">Name of the user configuration environment variable.</param>
            <param name="resultingConfiguration">The resulting configuration (default, solution, user or merged).</param>
        </member>
        <member name="T:MKY.Configuration.SelectionSection">
            <summary>
            Generic section to handle selection of multiple configurations with a configuration file.
            </summary>
        </member>
        <member name="F:MKY.Configuration.SelectionSection.SelectionSectionName">
            <summary></summary>
        </member>
        <member name="M:MKY.Configuration.SelectionSection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Configuration.SelectionSection"/> class.
            </summary>
        </member>
        <member name="P:MKY.Configuration.SelectionSection.Properties">
            <summary>
            Gets the collection of properties.
            </summary>
            <returns>
            The <see cref="T:System.Configuration.ConfigurationPropertyCollection"/> of properties for the element.
            </returns>
        </member>
        <member name="P:MKY.Configuration.SelectionSection.SelectedConfigurationName">
            <summary>
            Gets or sets the name of the selected configuration.
            </summary>
            <value>The name of the selected configuration.</value>
        </member>
        <member name="T:MKY.Configuration.TemplateGenerator">
            <summary>
            Utilities to deal with a configuration file.
            </summary>
        </member>
        <member name="F:MKY.Configuration.TemplateGenerator.DefaultInstructions_1through7">
            <summary>
            Returns an array of strings containing default instructions to generate template and configuration files.
            </summary>
        </member>
        <member name="M:MKY.Configuration.TemplateGenerator.CreateEmpty(System.String)">
            <summary>
            Creates an empty configuration for the given file.
            </summary>
            <param name="filePath">The file name or path of the configuration.</param>
            <returns>The created empty configuration.</returns>
        </member>
        <member name="M:MKY.Configuration.TemplateGenerator.CreateSectionsAndSave(System.String,System.String,System.String,System.String,MKY.Configuration.MergeableConfigurationSection)">
            <summary>
            Creates a configuration for the given sections and saves it to a file.
            </summary>
            <param name="filePath">The file name or path of the configuration to save.</param>
            <param name="selectionGroupName">The name of the selection group.</param>
            <param name="sectionsGroupName">The name of the sections group.</param>
            <param name="sectionName">The name of the section.</param>
            <param name="section">The section object.</param>
        </member>
        <member name="M:MKY.Configuration.TemplateGenerator.AddSectionGroups(System.Configuration.Configuration,System.String,System.String,System.String,MKY.Configuration.MergeableConfigurationSection)">
            <summary>
            Adds the given section groups to the given configuration.
            </summary>
            <param name="configuration">The file name or path of the configuration to save.</param>
            <param name="selectionGroupName">The name of the selection group.</param>
            <param name="sectionsGroupName">The name of the sections group.</param>
            <param name="sectionName">The name of the section.</param>
            <param name="section">The section object.</param>
        </member>
        <member name="T:MKY.Configuration.Selector">
            <summary>
            Utilities to select and return a particular configuration among a set of configurations.
            </summary>
            <remarks>
            Debugging this configuration infrastructure may be a bit trickier than normal debugging.
            E.g. if the configuration is used to parameterize NUnit test cases, the follow steps need
            to be taken:
            1. Build the solution
            2. Start NUnit
            3. 'Debug > Attach' Visual Studio to NUnit
            4. Set a breakpoint a the desired location below
            5. Reload the project in NUnit
               => Breakpoint is hit.
            </remarks>
        </member>
        <member name="M:MKY.Configuration.Selector.TryGetSelectedConfigurationName(System.Configuration.Configuration,System.String,System.String@)">
            <summary>
            Tries the name of the selected configuration.
            </summary>
            <param name="c">The configuration.</param>
            <param name="groupName">Name of the group.</param>
            <param name="selectedConfigurationName">Name of the selected configuration.</param>
        </member>
        <member name="M:MKY.Configuration.Selector.TryGetSelectedConfigurationSection``1(System.Configuration.Configuration,System.String,System.String,``0@)">
            <summary>
            Tries to get selected configuration section.
            </summary>
            <typeparam name="T">The type of the section to retrieve.</typeparam>
            <param name="c">The c.</param>
            <param name="groupName">Name of the group.</param>
            <param name="selectedConfigurationName">Name of the selected configuration.</param>
            <param name="selectedConfiguration">The selected configuration.</param>
        </member>
        <member name="M:MKY.Configuration.Selector.TryGetSelectedConfiguration``1(System.Configuration.Configuration,System.String,System.String,``0@)">
            <summary>
            Tries to get selected configuration.
            </summary>
            <typeparam name="T">The type of the section to retrieve.</typeparam>
            <param name="c">The c.</param>
            <param name="configurationGroupName">Name of the configuration group.</param>
            <param name="configurationsGroupName">Name of the configurations group.</param>
            <param name="selectedConfiguration">The selected configuration.</param>
        </member>
        <member name="T:MKY.Contracts.CallingContractAttribute">
            <summary>
            Attribute to indicate the nature of a function call.
            </summary>
            <remarks>
            Sealed to improve performance during reflection on custom attributes according to FxCop:CA1813.
            </remarks>
        </member>
        <member name="P:MKY.Contracts.CallingContractAttribute.IsAlwaysMainThread">
            <summary>
            Indicates that the function call is always performed on the main thread of the application.
            </summary>
        </member>
        <member name="P:MKY.Contracts.CallingContractAttribute.IsNeverMainThread">
            <summary>
            Indicates that the function call is never performed on the main thread of the application.
            </summary>
        </member>
        <member name="P:MKY.Contracts.CallingContractAttribute.IsAlwaysSequential">
            <summary>
            Indicates that the function call is always performed sequential, that is the caller
            ensures that no race condition may occur.
            </summary>
        </member>
        <member name="P:MKY.Contracts.CallingContractAttribute.IsAlwaysSequentialIncluding">
            <summary>
            Indicates that the function call is always performed sequential, that is the caller
            ensures that no race condition may occur, and the call is also sequentially synchronized
            with the given delegate.
            </summary>
        </member>
        <member name="P:MKY.Contracts.CallingContractAttribute.Rationale">
            <summary>
            The rationale for the calling contract.
            </summary>
        </member>
        <member name="T:MKY.Contracts.ImmutableContractAttribute">
            <summary>
            Attribute to indicate the nature of a class or struct.
            </summary>
            <remarks>
            Sealed to improve performance during reflection on custom attributes according to FxCop:CA1813.
            </remarks>
        </member>
        <member name="P:MKY.Contracts.ImmutableContractAttribute.IsImmutable">
            <summary>
            Indicates that the class or struct is immutable.
            </summary>
        </member>
        <member name="M:MKY.Contracts.ImmutableContractAttribute.#ctor(System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:MKY.Data.DataItem">
             <remarks>
             Attention, there currently are two similar implementations of this class:
              > <see cref="T:MKY.Data.DataItem"/>
              > <see cref="T:MKY.Settings.SettingsItem"/>
             The YAT feature request #158 "Consider replacing 'Settings' by 'DataItem'" deals with
             this issue, it will therefore not be forgotten. Until this feature request is implemented,
             changes to this class also have to be applied to <see cref="T:MKY.Settings.SettingsItem"/>.
            
             Note the additional YAT feature request #159 "Consider replacing SettingsItem/DataItem
             with attributes" and feature request #286 "Consider upgrade from XML serialization to
             .NET 3.0 DataContract serialization" to switch to that serialization, the preferred way
             to handle persistence since the .NET 3.0 framework version.
            
             Also note that this class intentionally doesn't implement <see cref="T:System.IDisposable"/>. That
             would unnecessarily complicate the handling of settings item, e.g. in a settings dialog,
             as code analysis requires that <see cref="T:System.IDisposable"/> are indeed disposed of.
            
             Finally note that the 'Serializable' attribute is required to allow reflection using e.g.
             <see cref="M:System.Runtime.Serialization.FormatterServices.GetSerializableMembers(System.Type)"/>.
             </remarks>
        </member>
        <member name="E:MKY.Data.DataItem.Changed">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.#ctor">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.AttachOrReplaceOrDetachNode(MKY.Data.DataItem,MKY.Data.DataItem)">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.AttachNode(MKY.Data.DataItem)">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.ReplaceNode(MKY.Data.DataItem,MKY.Data.DataItem)">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.DetachNode(MKY.Data.DataItem)">
            <summary></summary>
        </member>
        <member name="P:MKY.Data.DataItem.HaveChanged">
            <summary>
            This flag indicates that the item has changed. Either one of the values of the item
            itself, or any of the sub-items.
            </summary>
            <remarks>
            To clear this flag, <see cref="M:MKY.Data.DataItem.ClearChanged"/> must be called. The flag is never cleared
            automatically.
            </remarks>
        </member>
        <member name="M:MKY.Data.DataItem.SetChanged">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.SetMyChanged">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.ClearChanged">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.ClearMyChanged">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.SetDefaults">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.SetMyDefaults">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.SetNodeDefaults">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
        </member>
        <member name="M:MKY.Data.DataItem.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Data.DataItem.Equals(MKY.Data.DataItem)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Data.DataItem.op_Equality(MKY.Data.DataItem,MKY.Data.DataItem)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Data.DataItem.op_Inequality(MKY.Data.DataItem,MKY.Data.DataItem)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="M:MKY.Data.DataItem.OnChanged(MKY.Data.DataEventArgs)">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataItem.SetChangeEventSuspendedCount(System.Int32)">
            <summary>
            Sets the change event suspended count.
            </summary>
        </member>
        <member name="M:MKY.Data.DataItem.SuspendChangeEvent">
            <summary>
            Temporarily suspends the change event for the settings and all nodes of the settings tree.
            </summary>
        </member>
        <member name="M:MKY.Data.DataItem.ResumeChangeEvent(System.Boolean)">
            <summary>
            Resumes change events.
            </summary>
        </member>
        <member name="M:MKY.Data.DataItem.ForceChangeEvent">
            <summary>
            Forces a change event on the settings and all nodes of the settings tree.
            The event is raised even if the settings have not changed.
            </summary>
        </member>
        <member name="T:MKY.Data.EmptyDataItem">
            <summary></summary>
        </member>
        <member name="T:MKY.Data.DataEventArgs">
            <summary></summary>
        </member>
        <member name="P:MKY.Data.DataEventArgs.Source">
            <summary></summary>
        </member>
        <member name="P:MKY.Data.DataEventArgs.Inner">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataEventArgs.#ctor(MKY.Data.DataItem)">
            <summary></summary>
        </member>
        <member name="M:MKY.Data.DataEventArgs.#ctor(MKY.Data.DataItem,MKY.Data.DataEventArgs)">
            <summary></summary>
        </member>
        <member name="T:MKY.Diagnostics.AnyWriter">
            <summary>
            Provides static methods to write diagnostics output to any <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriter.WriteLocation(System.IO.TextWriter,System.String)">
            <summary>
            Writes location to the given <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriter.WriteTimeStamp(System.IO.TextWriter,System.String)">
            <summary>
            Writes time stamp and location to the given <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriter.WriteException(System.IO.TextWriter,System.Type,System.Exception,System.String)">
            <summary>
            Writes source, type, message and stack of the given exception and its inner exceptions
            to the given <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriter.WriteStack(System.IO.TextWriter,System.Type,System.String)">
            <summary>
            Writes a <see cref="T:System.Diagnostics.StackTrace"/> to the given <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriter.WriteStack(System.IO.TextWriter,System.Type,System.Diagnostics.StackTrace,System.String)">
            <summary>
            Writes a <see cref="T:System.Diagnostics.StackTrace"/> to the given <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriter.WriteWindowsFormsMessage(System.IO.TextWriter,System.Type,System.Windows.Forms.Message,System.String)">
            <summary>
            Writes the properties of a <see cref="T:System.Windows.Forms.Message"/> to the given <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriter.WriteFileStream(System.IO.TextWriter,System.Type,System.IO.FileStream,System.String)">
            <summary>
            Writes the properties of a <see cref="T:System.IO.FileStream"/> to the given <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="T:MKY.Diagnostics.AnyWriterWrapper">
            <summary>
            Wraps part of the interface of a <see cref="T:System.IO.TextWriter"/> to the common
            interface <see cref="T:MKY.Diagnostics.IDiagnosticsWriter"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriterWrapper.SetWriter(System.IO.TextWriter)">
            <summary>
            Sets a writer to write to. Set <param name="writer"></param> to <c>null</c> after writing.
            </summary>
        </member>
        <member name="F:MKY.Diagnostics.AnyWriterWrapper.IndentSizeDefault">
            <summary>
            The default number of spaces in an indent.
            </summary>
            <value>
            The number of spaces in an indent. The default is four (same as the default
            of <see cref="P:System.Diagnostics.Debug.IndentSize"/> and <see cref="P:System.Diagnostics.Trace.IndentSize"/>).
            </value>
        </member>
        <member name="P:MKY.Diagnostics.AnyWriterWrapper.IndentSize">
            <summary>
            Gets or sets the number of spaces in an indent.
            </summary>
            <value>
            The number of spaces in an indent. The default is four.
            </value>
        </member>
        <member name="P:MKY.Diagnostics.AnyWriterWrapper.IndentLevel">
            <summary>
            Gets or sets the indent level.
            </summary>
            <value>
            The indent level. The default is zero.
            </value>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriterWrapper.Indent">
            <summary>
            Increases the current <see cref="P:MKY.Diagnostics.AnyWriterWrapper.IndentLevel"/> by one.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriterWrapper.Unindent">
            <summary>
            Decreases the current <see cref="P:MKY.Diagnostics.AnyWriterWrapper.IndentLevel"/> by one.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriterWrapper.Write(System.String)">
            <summary>
            Writes a message to the diagnostics listeners.
            </summary>
            <param name="message">A message to write.</param>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriterWrapper.WriteLine(System.String)">
            <summary>
            Writes a message to the diagnostics listeners.
            </summary>
            <param name="message">A message to write.</param>
        </member>
        <member name="M:MKY.Diagnostics.AnyWriterWrapper.WriteIndent">
            <summary>
            Writes <see cref="P:MKY.Diagnostics.AnyWriterWrapper.IndentLevel"/> times <see cref="P:MKY.Diagnostics.AnyWriterWrapper.IndentSize"/> spaces to the
            diagnostics listeners.
            </summary>
        </member>
        <member name="T:MKY.Diagnostics.ConsoleWrapper">
            <summary>
            Wraps part of the interface of <see cref="T:System.Console"/> to the common
            interface <see cref="T:MKY.Diagnostics.IDiagnosticsWriter"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.ConsoleWrapper.#ctor(System.IO.TextWriter)">
            <summary>
            Initializes this wrapper and sets the console writer.
            Standard writers are <see cref="P:System.Console.Out"/> and <see cref="P:System.Console.Error"/>.
            </summary>
        </member>
        <member name="F:MKY.Diagnostics.ConsoleWrapper.IndentSizeDefault">
            <summary>
            The default number of spaces in an indent.
            </summary>
            <value>
            The number of spaces in an indent. The default is four (same as the default
            of <see cref="P:System.Diagnostics.Debug.IndentSize"/> and <see cref="P:System.Diagnostics.Trace.IndentSize"/>).
            </value>
        </member>
        <member name="P:MKY.Diagnostics.ConsoleWrapper.IndentSize">
            <summary>
            Gets or sets the number of spaces in an indent.
            </summary>
            <value>
            The number of spaces in an indent. The default is four.
            </value>
        </member>
        <member name="P:MKY.Diagnostics.ConsoleWrapper.IndentLevel">
            <summary>
            Gets or sets the indent level.
            </summary>
            <value>
            The indent level. The default is zero.
            </value>
        </member>
        <member name="M:MKY.Diagnostics.ConsoleWrapper.Indent">
            <summary>
            Increases the current <see cref="P:MKY.Diagnostics.ConsoleWrapper.IndentLevel"/> by one.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.ConsoleWrapper.Unindent">
            <summary>
            Decreases the current <see cref="P:MKY.Diagnostics.ConsoleWrapper.IndentLevel"/> by one.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.ConsoleWrapper.Write(System.String)">
            <summary>
            Writes a message to the diagnostics listeners.
            </summary>
            <param name="message">A message to write.</param>
        </member>
        <member name="M:MKY.Diagnostics.ConsoleWrapper.WriteLine(System.String)">
            <summary>
            Writes a message to the diagnostics listeners.
            </summary>
            <param name="message">A message to write.</param>
        </member>
        <member name="M:MKY.Diagnostics.ConsoleWrapper.WriteIndent">
            <summary>
            Writes <see cref="P:MKY.Diagnostics.ConsoleWrapper.IndentLevel"/> times <see cref="P:MKY.Diagnostics.ConsoleWrapper.IndentSize"/> spaces to the
            diagnostics listeners.
            </summary>
        </member>
        <member name="T:MKY.Diagnostics.DebugDisposal">
            <summary>
            Provides static methods to help with disposal.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugDisposal.DebugNotifyFinalizerInsteadOfDispose(System.Object)">
            <summary></summary>
        </member>
        <member name="T:MKY.Diagnostics.DebugEventManagement">
            <summary>
            Provides static methods to help debugging event handler management.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugEventManagement.DebugWriteAllEventRemains(System.Object)">
            <summary></summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugEventManagement.DebugWriteEventRemains(System.Object,System.String)">
            <summary></summary>
        </member>
        <member name="T:MKY.Diagnostics.DebugEx">
            <summary>
            Provides static methods to write diagnostics output to <see cref="T:System.Diagnostics.Debug"/>.
            </summary>
            <remarks>
            Implementation gets optimized on non-debug by not creating the debug wrapper.
            </remarks>
            <remarks>
            There also are <see cref="T:System.Diagnostics.Trace"/> variants of these methods available
            in <see cref="T:MKY.Diagnostics.TraceEx"/>.
            Unfortunately, the Debug and Trace objects do not provide access to their underlying
            output writers. Therefore, the two implementations use writer wrappers.
            </remarks>
        </member>
        <member name="M:MKY.Diagnostics.DebugEx.WriteLocation(System.String)">
            <summary>
            Writes location to <see cref="T:System.Diagnostics.Debug"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugEx.WriteTimeStamp(System.String)">
            <summary>
            Writes time stamp and location to <see cref="T:System.Diagnostics.Debug"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugEx.WriteException(System.Type,System.Exception,System.String)">
            <summary>
            Writes source, type, message and stack of the given exception and its inner exceptions
            to <see cref="T:System.Diagnostics.Debug"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugEx.WriteStack(System.Type,System.String)">
            <summary>
            Writes a <see cref="T:System.Diagnostics.StackTrace"/> to <see cref="T:System.Diagnostics.Debug"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugEx.WriteStack(System.Type,System.Diagnostics.StackTrace,System.String)">
            <summary>
            Writes a <see cref="T:System.Diagnostics.StackTrace"/> to <see cref="T:System.Diagnostics.Debug"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugEx.WriteWindowsFormsMessage(System.Type,System.Windows.Forms.Message,System.String)">
            <summary>
            Writes the properties of a <see cref="T:System.Windows.Forms.Message"/> to <see cref="T:System.Diagnostics.Debug"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugEx.WriteFileStream(System.Type,System.IO.FileStream,System.String)">
            <summary>
            Writes the properties of a <see cref="T:System.IO.FileStream"/> to <see cref="T:System.Diagnostics.Debug"/>.
            </summary>
        </member>
        <member name="T:MKY.Diagnostics.DebugFinalization">
            <summary>
            Provides static methods to help with finalization.
            </summary>
        </member>
        <member name="P:MKY.Diagnostics.DebugFinalization.FinalizationShouldHaveCompleted">
            <summary></summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugFinalization.DebugNotifyFinalizerAndCheckWhetherOverdue(System.Object)">
            <summary></summary>
        </member>
        <member name="T:MKY.Diagnostics.DebugWrapper">
            <summary>
            Wraps part of the interface of <see cref="T:System.Diagnostics.Debug"/> to the common
            interface <see cref="T:MKY.Diagnostics.IDiagnosticsWriter"/>.
            </summary>
        </member>
        <member name="P:MKY.Diagnostics.DebugWrapper.IndentSize">
            <summary>
            Gets or sets the number of spaces in an indent.
            </summary>
            <value>
            The number of spaces in an indent. The default is four.
            </value>
        </member>
        <member name="P:MKY.Diagnostics.DebugWrapper.IndentLevel">
            <summary>
            Gets or sets the indent level.
            </summary>
            <value>
            The indent level. The default is zero.
            </value>
        </member>
        <member name="M:MKY.Diagnostics.DebugWrapper.Indent">
            <summary>
            Increases the current <see cref="P:MKY.Diagnostics.DebugWrapper.IndentLevel"/> by one.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugWrapper.Unindent">
            <summary>
            Decreases the current <see cref="P:MKY.Diagnostics.DebugWrapper.IndentLevel"/> by one.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.DebugWrapper.Write(System.String)">
            <summary>
            Writes a message to the diagnostics listeners.
            </summary>
            <param name="message">A message to write.</param>
        </member>
        <member name="M:MKY.Diagnostics.DebugWrapper.WriteLine(System.String)">
            <summary>
            Writes a message to the diagnostics listeners.
            </summary>
            <param name="message">A message to write.</param>
        </member>
        <member name="T:MKY.Diagnostics.DiagnosticsWriterOutput">
            <summary>
            A collection of methods to write the state of certain objects to a given diagnostics writer.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.DiagnosticsWriterOutput.WriteLocation(MKY.Diagnostics.IDiagnosticsWriter,System.Diagnostics.StackTrace,System.Int32,System.String,System.Boolean)">
            <summary>
            Writes location to the given writer.
            </summary>
            <remarks>
            There are predefined variants for the static objects
            <see cref="T:System.Diagnostics.Debug"/> and
            <see cref="T:System.Diagnostics.Trace"/> and
            <see cref="T:System.Console"/> available in
            <see cref="T:MKY.Diagnostics.DebugEx"/> and
            <see cref="T:MKY.Diagnostics.TraceEx"/> and
            <see cref="T:MKY.ConsoleEx"/>.
            </remarks>
        </member>
        <member name="M:MKY.Diagnostics.DiagnosticsWriterOutput.WriteTimeStamp(MKY.Diagnostics.IDiagnosticsWriter,System.Diagnostics.StackTrace,System.Int32,System.String,System.Boolean)">
            <summary>
            Writes time stamp and location to the given writer.
            </summary>
            <remarks>
            There are predefined variants for the static objects
            <see cref="T:System.Diagnostics.Debug"/> and
            <see cref="T:System.Diagnostics.Trace"/> and
            <see cref="T:System.Console"/> available in
            <see cref="T:MKY.Diagnostics.DebugEx"/> and
            <see cref="T:MKY.Diagnostics.TraceEx"/> and
            <see cref="T:MKY.ConsoleEx"/>.
            </remarks>
        </member>
        <member name="M:MKY.Diagnostics.DiagnosticsWriterOutput.WriteExceptionLines(MKY.Diagnostics.IDiagnosticsWriter,System.Type,System.Exception,System.String)">
            <summary>
            Writes source, type, message and stack of the given exception and its inner exceptions
            to the given writer.
            </summary>
            <remarks>
            There are predefined variants for the static objects
            <see cref="T:System.Diagnostics.Debug"/> and
            <see cref="T:System.Diagnostics.Trace"/> and
            <see cref="T:System.Console"/> available in
            <see cref="T:MKY.Diagnostics.DebugEx"/> and
            <see cref="T:MKY.Diagnostics.TraceEx"/> and
            <see cref="T:MKY.ConsoleEx"/>.
            </remarks>
        </member>
        <member name="M:MKY.Diagnostics.DiagnosticsWriterOutput.WriteStackLines(MKY.Diagnostics.IDiagnosticsWriter,System.Type,System.Diagnostics.StackTrace,System.String)">
            <summary>
            Writes a <see cref="T:System.Diagnostics.StackTrace"/> to the given writer.
            </summary>
            <remarks>
            There are predefined variants for the static objects
            <see cref="T:System.Diagnostics.Debug"/> and
            <see cref="T:System.Diagnostics.Trace"/> and
            <see cref="T:System.Console"/> available in
            <see cref="T:MKY.Diagnostics.DebugEx"/> and
            <see cref="T:MKY.Diagnostics.TraceEx"/> and
            <see cref="T:MKY.ConsoleEx"/>.
            </remarks>
        </member>
        <member name="M:MKY.Diagnostics.DiagnosticsWriterOutput.WriteWindowsFormsMessageLines(MKY.Diagnostics.IDiagnosticsWriter,System.Type,System.Windows.Forms.Message,System.String)">
            <summary>
            Writes the properties of a <see cref="T:System.Windows.Forms.Message"/> to the given writer.
            </summary>
            <remarks>
            There are predefined variants for the static objects
            <see cref="T:System.Diagnostics.Debug"/> and
            <see cref="T:System.Diagnostics.Trace"/> and
            <see cref="T:System.Console"/> available in
            <see cref="T:MKY.Diagnostics.DebugEx"/> and
            <see cref="T:MKY.Diagnostics.TraceEx"/> and
            <see cref="T:MKY.ConsoleEx"/>.
            </remarks>
        </member>
        <member name="M:MKY.Diagnostics.DiagnosticsWriterOutput.WriteFileStreamLines(MKY.Diagnostics.IDiagnosticsWriter,System.Type,System.IO.FileStream,System.String)">
            <summary>
            Writes the properties of a <see cref="T:System.IO.FileStream"/> to the given writer.
            </summary>
            <remarks>
            There are predefined variants for the static objects
            <see cref="T:System.Diagnostics.Debug"/> and
            <see cref="T:System.Diagnostics.Trace"/> and
            <see cref="T:System.Console"/> available in
            <see cref="T:MKY.Diagnostics.DebugEx"/> and
            <see cref="T:MKY.Diagnostics.TraceEx"/> and
            <see cref="T:MKY.ConsoleEx"/>.
            </remarks>
        </member>
        <member name="T:MKY.Diagnostics.IDiagnosticsWriter">
            <summary>
            Provides a common interface to write to <see cref="T:System.Diagnostics.Debug"/>, <see cref="T:System.Diagnostics.Trace"/>,
            <see cref="T:System.Console"/> and other output writers via <see cref="T:MKY.Diagnostics.AnyWriter"/>.
            </summary>
        </member>
        <member name="P:MKY.Diagnostics.IDiagnosticsWriter.IndentLevel">
            <summary>
            Gets or sets the indent level.
            </summary>
            <value>
            The indent level. The default is zero.
            </value>
        </member>
        <member name="P:MKY.Diagnostics.IDiagnosticsWriter.IndentSize">
            <summary>
            Gets or sets the number of spaces in an indent.
            </summary>
            <value>
            The number of spaces in an indent. The default is four (same as the default
            of <see cref="P:System.Diagnostics.Debug.IndentSize"/> and <see cref="P:System.Diagnostics.Trace.IndentSize"/>).
            </value>
        </member>
        <member name="M:MKY.Diagnostics.IDiagnosticsWriter.Indent">
            <summary>
            Increases the current <see cref="P:MKY.Diagnostics.IDiagnosticsWriter.IndentLevel"/> by one.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.IDiagnosticsWriter.Unindent">
            <summary>
            Decreases the current <see cref="P:MKY.Diagnostics.IDiagnosticsWriter.IndentLevel"/> by one.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.IDiagnosticsWriter.Write(System.String)">
            <summary>
            Writes a message to the diagnostics listeners.
            </summary>
            <param name="message">A message to write.</param>
        </member>
        <member name="M:MKY.Diagnostics.IDiagnosticsWriter.WriteLine(System.String)">
            <summary>
            Writes a message to the diagnostics listeners.
            </summary>
            <param name="message">A message to write.</param>
        </member>
        <member name="T:MKY.Diagnostics.ProcessorLoad">
             <summary>
             A better way to measure the processor time than using a <see cref="T:System.Diagnostics.PerformanceCounter"/>,
             because that...
             ...is pretty resource hungry, and...
             ...is language dependent!
            
             Saying hello to StyleCop ;-.
             </summary>
             <remarks>
             Based on http://stackoverflow.com/questions/19756454/calculating-process-cpu-usage-from-process-totalprocessortime.
             </remarks>
        </member>
        <member name="P:MKY.Diagnostics.ProcessorLoad.CurrentPercentage">
            <summary>
            The current processor load percentage of the current process.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.ProcessorLoad.Initialize(System.Int32)">
            <summary>Initializes the processor load evaluation.</summary>
            <remarks>Call once as soon as the application is ready.</remarks>
        </member>
        <member name="M:MKY.Diagnostics.ProcessorLoad.Update">
            <summary>Updates the processor load evaluation.</summary>
            <remarks>Call in regular intervals, e.g. each second.</remarks>
            <remarks>Keep in mind that updating also takes time, below a millisecond, but still time.</remarks>
            <returns>The current processor load percentage of the current process.</returns>
        </member>
        <member name="M:MKY.Diagnostics.ProcessorLoad.DebugUpdate(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="T:MKY.Diagnostics.StopwatchEx">
            <summary>
            Stopwatch utility methods.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.StopwatchEx.TicksToTime(System.Int64)">
            <summary>
            Converts the given number of <see cref="T:System.Diagnostics.Stopwatch"/> ticks into the corresponding
            number of milliseconds, using <see cref="F:System.Diagnostics.Stopwatch.Frequency"/>.
            </summary>
            <remarks>
            A similar method exists as <see cref="M:MKY.TimeSpanEx.TicksToTime(System.Int64)"/>.
            </remarks>
        </member>
        <member name="M:MKY.Diagnostics.StopwatchEx.TimeToTicks(System.Int32)">
            <summary>
            Converts the given number of milliseconds into the corresponding number of
            <see cref="T:System.Diagnostics.Stopwatch"/> ticks, using <see cref="F:System.Diagnostics.Stopwatch.Frequency"/>.
            </summary>
            <remarks>
            A similar method exists as <see cref="M:MKY.TimeSpanEx.TimeToTicks(System.Int32)"/>.
            </remarks>
        </member>
        <member name="T:MKY.Diagnostics.TraceEx">
            <summary>
            Provides static methods to write diagnostics output to <see cref="T:System.Diagnostics.Trace"/>.
            </summary>
            <remarks>
            Implementation gets optimized on non-trace by not creating the trace wrapper.
            </remarks>
            <remarks>
            There also are <see cref="T:System.Diagnostics.Debug"/> variants of these methods available
            in <see cref="T:MKY.Diagnostics.DebugEx"/>.
            Unfortunately, the Debug and Trace objects do not provide access to their underlying
            output writers. Therefore, the two implementations use writer wrappers.
            </remarks>
        </member>
        <member name="M:MKY.Diagnostics.TraceEx.WriteLocation(System.String)">
            <summary>
            Writes location to <see cref="T:System.Diagnostics.Trace"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.TraceEx.WriteTimeStamp(System.String)">
            <summary>
            Writes time stamp and location to <see cref="T:System.Diagnostics.Trace"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.TraceEx.WriteException(System.Type,System.Exception,System.String)">
            <summary>
            Writes source, type, message and stack of the given exception and its inner exceptions
            to <see cref="T:System.Diagnostics.Trace"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.TraceEx.WriteStack(System.Type,System.String)">
            <summary>
            Writes a <see cref="T:System.Diagnostics.StackTrace"/> to <see cref="T:System.Diagnostics.Trace"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.TraceEx.WriteStack(System.Type,System.Diagnostics.StackTrace,System.String)">
            <summary>
            Writes a <see cref="T:System.Diagnostics.StackTrace"/> to <see cref="T:System.Diagnostics.Trace"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.TraceEx.WriteWindowsFormsMessage(System.Type,System.Windows.Forms.Message,System.String)">
            <summary>
            Writes the properties of a <see cref="T:System.Windows.Forms.Message"/> to <see cref="T:System.Diagnostics.Trace"/>.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.TraceEx.WriteFileStream(System.Type,System.IO.FileStream,System.String)">
            <summary>
            Writes the properties of a <see cref="T:System.IO.FileStream"/> to <see cref="T:System.Diagnostics.Trace"/>.
            </summary>
        </member>
        <member name="T:MKY.Diagnostics.TraceWrapper">
            <summary>
            Wraps part of the interface of <see cref="T:System.Diagnostics.Trace"/> to the common
            interface <see cref="T:MKY.Diagnostics.IDiagnosticsWriter"/>.
            </summary>
        </member>
        <member name="P:MKY.Diagnostics.TraceWrapper.IndentSize">
            <summary>
            Gets or sets the number of spaces in an indent.
            </summary>
            <value>
            The number of spaces in an indent. The default is four.
            </value>
        </member>
        <member name="P:MKY.Diagnostics.TraceWrapper.IndentLevel">
            <summary>
            Gets or sets the indent level.
            </summary>
            <value>
            The indent level. The default is zero.
            </value>
        </member>
        <member name="M:MKY.Diagnostics.TraceWrapper.Indent">
            <summary>
            Increases the current <see cref="P:MKY.Diagnostics.TraceWrapper.IndentLevel"/> by one.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.TraceWrapper.Unindent">
            <summary>
            Decreases the current <see cref="P:MKY.Diagnostics.TraceWrapper.IndentLevel"/> by one.
            </summary>
        </member>
        <member name="M:MKY.Diagnostics.TraceWrapper.Write(System.String)">
            <summary>
            Writes a message to the diagnostics listeners.
            </summary>
            <param name="message">A message to write.</param>
        </member>
        <member name="M:MKY.Diagnostics.TraceWrapper.WriteLine(System.String)">
            <summary>
            Writes a message to the diagnostics listeners.
            </summary>
            <param name="message">A message to write.</param>
        </member>
        <member name="T:MKY.ConsoleEx">
            <summary>
            Provides static methods to write diagnostics output to <see cref="P:System.Console.Out"/> and
            <see cref="P:System.Console.Error"/>.
            </summary>
        </member>
        <member name="T:MKY.ConsoleEx.TextWriterEx">
            <summary>
            A console writer extension to <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:MKY.ConsoleEx.TextWriterEx.#ctor(MKY.Diagnostics.IDiagnosticsWriter)">
            <summary>
            Initializes writer and sets the diagnostics writer that wraps the console writer.
            </summary>
        </member>
        <member name="M:MKY.ConsoleEx.TextWriterEx.WriteLocation(System.String)">
            <summary>
             Writes location to the output writer of this object.
            </summary>
        </member>
        <member name="M:MKY.ConsoleEx.TextWriterEx.WriteTimeStamp(System.String)">
            <summary>
            Writes time stamp and location to the output writer of this object.
            </summary>
        </member>
        <member name="M:MKY.ConsoleEx.TextWriterEx.WriteException(System.Type,System.Exception,System.String)">
            <summary>
            Writes source, type, message and stack of the given exception and its inner
            exceptions to the output writer of this object.
            </summary>
        </member>
        <member name="M:MKY.ConsoleEx.TextWriterEx.WriteStack(System.Type,System.String)">
            <summary>
            Writes a <see cref="T:System.Diagnostics.StackTrace"/> to the output writer of this object.
            </summary>
        </member>
        <member name="M:MKY.ConsoleEx.TextWriterEx.WriteStack(System.Type,System.Diagnostics.StackTrace,System.String)">
            <summary>
            Writes a <see cref="T:System.Diagnostics.StackTrace"/> to the output writer of this object.
            </summary>
        </member>
        <member name="M:MKY.ConsoleEx.TextWriterEx.WriteWindowsFormsMessage(System.Type,System.Windows.Forms.Message,System.String)">
            <summary>
            Writes the properties of a <see cref="T:System.Windows.Forms.Message"/> to the output writer of this object.
            </summary>
        </member>
        <member name="M:MKY.ConsoleEx.TextWriterEx.WriteFileStream(System.Type,System.IO.FileStream,System.String)">
            <summary>
            Writes the properties of a <see cref="T:System.IO.FileStream"/> to the output writer of this object.
            </summary>
        </member>
        <member name="P:MKY.ConsoleEx.Out">
            <summary>
            Gets the standard output stream wrapped to output diagnostics.
            </summary>
            <returns>
            A <see cref="T:MKY.ConsoleEx.TextWriterEx"/> that represents the standard output stream.
            </returns>
        </member>
        <member name="P:MKY.ConsoleEx.Error">
            <summary>
            Gets the standard error stream wrapped to output diagnostics.
            </summary>
            <returns>
            A <see cref="T:MKY.ConsoleEx.TextWriterEx"/> that represents the standard error stream.
            </returns>
        </member>
        <member name="T:MKY.Drawing.ColorTranslatorEx">
            <summary>
            An extension to the <see cref="T:System.Drawing.ColorTranslator"/> class.
            </summary>
        </member>
        <member name="M:MKY.Drawing.ColorTranslatorEx.FromHtmlOrWin32(System.String)">
            <summary>
            Translates an HTML or Win32 color representation to a GDI+ <see cref="T:System.Drawing.Color"/> structure.
            </summary>
            <exception cref="T:System.ArgumentException"> if <paramref name="colorString"/> cannot be converted into a color structure.</exception>
        </member>
        <member name="T:MKY.Drawing.FontEx">
            <summary>
            Drawing utility methods.
            </summary>
        </member>
        <member name="P:MKY.Drawing.FontEx.DefaultFontItalic">
             <summary>
             Gets the <see cref="P:System.Drawing.SystemFonts.DefaultFont"/> with <see cref="F:System.Drawing.FontStyle.Italic"/>.
             </summary>
             <remarks>
             Same as retrieving <see cref="P:System.Drawing.SystemFonts.DefaultFont"/>, retrieving this property can
             be a rather time-consuming operation, this property shall not be retrieved more needed.
            
             Measurements 2019-09-02..05 in PredefinedCommandButtonSet around lines #490..505 at
             ~2062500 ticks per second, i.e. each tick ~0.5 us:
             <code>
             System.Diagnostics.Trace.WriteLine("FR = " + System.Diagnostics.Stopwatch.Frequency);
             </code>
            
             Retrieving <see cref="P:System.Drawing.SystemFonts.DefaultFont"/> for evaluation has been measured as
             220 us to 1.1 ms to even 22 ms !?!
             <code>
             System.Diagnostics.Trace.WriteLine("DF = " + System.Diagnostics.Stopwatch.GetTimestamp());
            
             if (someControl.Font != SystemFonts.DefaultFont) // Improve performance by only assigning if different.
                 someControl.Font = SystemFonts.DefaultFont;  // Improves because "Font" is managed by a "PropertyStore".
            
             System.Diagnostics.Trace.WriteLine("DF = " + System.Diagnostics.Stopwatch.GetTimestamp());
             </code>
            
             The same applies to <see cref="P:MKY.Drawing.FontEx.DefaultFontItalic"/>. Attempts to fix this by caching did not succeed:
             <code>
             System.Diagnostics.Trace.WriteLine("IT = " + System.Diagnostics.Stopwatch.GetTimestamp());
            
             var defaultFontItalic = DrawingEx.UpdateCacheIfNameOrSizeHasChanged(ref staticDefaultFontItalicCache, SystemFonts.DefaultFont, FontStyle.Italic);
            
             System.Diagnostics.Trace.WriteLine("IT = " + System.Diagnostics.Stopwatch.GetTimestamp());
            
             if (someControl.Font != defaultFontItalic) // Improve performance by only assigning if different.
                 someControl.Font = defaultFontItalic;  // Improves because "Font" is managed by a "PropertyStore".
            
             System.Diagnostics.Trace.WriteLine("IT = " + System.Diagnostics.Stopwatch.GetTimestamp());
             </code>
            
             Solving issue by reducing the number of accesses to <see cref="P:System.Drawing.SystemFonts.DefaultFont"/>
             and <see cref="P:MKY.Drawing.FontEx.DefaultFontItalic"/>, which is the better approach anyway.
             </remarks>
        </member>
        <member name="M:MKY.Drawing.FontEx.TryGet(System.String,System.Single,System.Drawing.FontStyle)">
            <summary>
            Tries to initialize a new <see cref="T:System.Drawing.Font"/> using a specified name, size and style.
            </summary>
            <param name="familiyName">A <c>string</c> representation of the <see cref="T:System.Drawing.FontFamily"/> for the new <see cref="T:System.Drawing.Font"/>.</param>
            <param name="emSize">The em-size, in points, of the new font.</param>
            <param name="style">The <see cref="T:System.Drawing.FontStyle"/> of the new font.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Drawing.FontEx.TryGet(System.String,System.Single,System.Drawing.Font@)">
            <summary>
            Tries to initialize a new <see cref="T:System.Drawing.Font"/> using a specified name, size and style.
            </summary>
            <param name="familiyName">A <c>string</c> representation of the <see cref="T:System.Drawing.FontFamily"/> for the new <see cref="T:System.Drawing.Font"/>.</param>
            <param name="emSize">The em-size, in points, of the new font.</param>
            <param name="font">The new <see cref="T:System.Drawing.Font"/> if available; otherwise, <c>null</c>.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Drawing.FontEx.TryGet(System.String,System.Single,System.Drawing.FontStyle,System.Drawing.Font@)">
            <summary>
            Tries to initialize a new <see cref="T:System.Drawing.Font"/> using a specified name, size and style.
            </summary>
            <param name="familiyName">A <c>string</c> representation of the <see cref="T:System.Drawing.FontFamily"/> for the new <see cref="T:System.Drawing.Font"/>.</param>
            <param name="emSize">The em-size, in points, of the new font.</param>
            <param name="style">The <see cref="T:System.Drawing.FontStyle"/> of the new font.</param>
            <param name="font">The new <see cref="T:System.Drawing.Font"/> if available; otherwise, <c>null</c>.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Drawing.FontEx.TryGet(System.String,System.Single,System.Exception@)">
            <summary>
            Tries to initialize a new <see cref="T:System.Drawing.Font"/> using a specified name, size and style.
            </summary>
            <param name="familiyName">A <c>string</c> representation of the <see cref="T:System.Drawing.FontFamily"/> for the new <see cref="T:System.Drawing.Font"/>.</param>
            <param name="emSize">The em-size, in points, of the new font.</param>
            <param name="exceptionOnFailure">Exception object, in case of failure.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Drawing.FontEx.TryGet(System.String,System.Single,System.Drawing.FontStyle,System.Exception@)">
            <summary>
            Tries to initialize a new <see cref="T:System.Drawing.Font"/> using a specified name, size and style.
            </summary>
            <param name="familiyName">A <c>string</c> representation of the <see cref="T:System.Drawing.FontFamily"/> for the new <see cref="T:System.Drawing.Font"/>.</param>
            <param name="emSize">The em-size, in points, of the new font.</param>
            <param name="style">The <see cref="T:System.Drawing.FontStyle"/> of the new font.</param>
            <param name="exceptionOnFailure">Exception object, in case of failure.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Drawing.FontEx.TryGet(System.String,System.Single,System.Drawing.Font@,System.Exception@)">
            <summary>
            Tries to initialize a new <see cref="T:System.Drawing.Font"/> using a specified name, size and style.
            </summary>
            <param name="familiyName">A <c>string</c> representation of the <see cref="T:System.Drawing.FontFamily"/> for the new <see cref="T:System.Drawing.Font"/>.</param>
            <param name="emSize">The em-size, in points, of the new font.</param>
            <param name="font">The new <see cref="T:System.Drawing.Font"/> if available; otherwise, <c>null</c>.</param>
            <param name="exceptionOnFailure">Exception object, in case of failure.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Drawing.FontEx.TryGet(System.String,System.Single,System.Drawing.FontStyle,System.Drawing.Font@,System.Exception@)">
            <summary>
            Tries to initialize a new <see cref="T:System.Drawing.Font"/> using a specified name, size and style.
            </summary>
            <param name="familiyName">A <c>string</c> representation of the <see cref="T:System.Drawing.FontFamily"/> for the new <see cref="T:System.Drawing.Font"/>.</param>
            <param name="emSize">The em-size, in points, of the new font.</param>
            <param name="style">The <see cref="T:System.Drawing.FontStyle"/> of the new font.</param>
            <param name="font">The new <see cref="T:System.Drawing.Font"/> if available; otherwise, <c>null</c>.</param>
            <param name="exceptionOnFailure">Exception object, in case of failure.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="emSize"/> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="familiyName"/> is <c>null</c> or <see cref="F:System.String.Empty"/>.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="familiyName"/> is not available in the environment.</exception>
        </member>
        <member name="M:MKY.Drawing.FontEx.IsMonospaced(System.String)">
            <summary>
            Determines whether the <see cref="T:System.Drawing.Font"/> of the given <paramref name="familiyName"/> is monospaced.
            </summary>
            <remarks><para>
            Using "monospaced" instead of "fixed width" same as in <see cref="P:System.Drawing.FontFamily.GenericMonospace"/>.
            Using "monospaced" instead of "monospace" same as in:
            <list type="bullet">
            <item><description>"\DejaVu\README.md" "Mono = monospaced".</description></item>
            <item><description>https://en.wikipedia.org/wiki/Monospaced_font "A monospaced font, also called a fixed-pitch, fixed-width, or non-proportional font".</description></item>
            </list>
            </para><para>
            Based on https://social.msdn.microsoft.com/forums/windows/en-US/5b582b96-ade5-4354-99cf-3fe64cc6b53b/determining-if-font-is-monospaced.
            </para></remarks>
            <param name="familiyName">A <c>string</c> representation of the <see cref="T:System.Drawing.FontFamily"/> for the <see cref="T:System.Drawing.Font"/> to evaluate.</param>
            <returns><c>true</c> if monospaced; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Drawing.FontEx.IsMonospaced(System.Drawing.Font)">
            <summary>
            Determines whether the given <paramref name="font"/> is monospaced.
            </summary>
            <remarks><para>
            Using "monospaced" instead of "fixed width" same as in <see cref="P:System.Drawing.FontFamily.GenericMonospace"/>.
            Using "monospaced" instead of "monospace" same as in:
            <list type="bullet">
            <item><description>"\DejaVu\README.md" "Mono = monospaced".</description></item>
            <item><description>https://en.wikipedia.org/wiki/Monospaced_font "A monospaced font, also called a fixed-pitch, fixed-width, or non-proportional font".</description></item>
            </list>
            </para><para>
            Based on https://social.msdn.microsoft.com/forums/windows/en-US/5b582b96-ade5-4354-99cf-3fe64cc6b53b/determining-if-font-is-monospaced.
            </para></remarks>
            <param name="font">The <see cref="T:System.Drawing.Font"/> to evaluate.</param>
            <returns><c>true</c> if monospaced; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Drawing.FontEx.UpdateCacheIfAnyHasChanged(System.Drawing.Font@,System.String,System.Single,System.Drawing.FontStyle)">
            <summary>
            If the cached font doesn't exist, it is created.
            If the font properties have changed, the cached font is updated.
            </summary>
            <param name="cachedFont">The cached font.</param>
            <param name="fontName">Name of the font.</param>
            <param name="fontSize">Size of the font.</param>
            <param name="fontStyle">The font style.</param>
            <returns>The reference to the cached font.</returns>
        </member>
        <member name="M:MKY.Drawing.FontEx.UpdateCacheIfNameOrSizeHasChanged(System.Drawing.Font@,System.Drawing.Font,System.Drawing.FontStyle)">
            <summary>
            If the cached font doesn't exist, it is created.
            If the font properties have changed, the cached font is updated.
            </summary>
            <param name="cachedFont">The cached font.</param>
            <param name="fontNameAndSizeToEvaluate">The font to retrieve name and size from for evaluation of change.</param>
            <param name="fontStyleToApply">The font style to apply to the cached font.</param>
            <returns>The reference to the cached font.</returns>
        </member>
        <member name="M:MKY.Drawing.FontEx.UpdateCacheIfNameOrSizeHasChanged(System.Drawing.Font@,System.String,System.Single,System.Drawing.FontStyle)">
            <summary>
            If the cached font doesn't exist, it is created.
            If the font properties have changed, the cached font is updated.
            </summary>
            <param name="cachedFont">The cached font.</param>
            <param name="fontNameToEvaluate">Name of the font for evaluation of change.</param>
            <param name="fontSizeToEvaluate">Size of the font for evaluation of change.</param>
            <param name="fontStyleToApply">The font style to apply to the cached font.</param>
            <returns>The reference to the cached font.</returns>
        </member>
        <member name="T:MKY.Drawing.ContentAlignmentEx">
            <summary>
            This class provides conversion methods for <see cref="T:System.Drawing.ContentAlignment"/>.
            </summary>
        </member>
        <member name="M:MKY.Drawing.ContentAlignmentEx.ConvertTo(System.Drawing.ContentAlignment)">
            <summary>
            Converts a <see cref="T:System.Drawing.ContentAlignment"/> enum to a <see cref="T:System.Windows.Forms.TextFormatFlags"/> enum.
            Can be used for user drawn controls.
            </summary>
            <param name="contentAlignment"><see cref="T:System.Drawing.ContentAlignment"/> to be converted.</param>
            <returns>Converted <see cref="T:System.Windows.Forms.TextFormatFlags"/>.</returns>
        </member>
        <member name="M:MKY.Drawing.ContentAlignmentEx.ApplyTo(System.Drawing.ContentAlignment,System.Windows.Forms.TextFormatFlags)">
            <summary>
            Applies a <see cref="T:System.Drawing.ContentAlignment"/> enum to a <see cref="T:System.Windows.Forms.TextFormatFlags"/> enum.
            Can be used for user drawn controls.
            </summary>
            <param name="contentAlignment"><see cref="T:System.Drawing.ContentAlignment"/> to be converted.</param>
            <param name="textFormatFlags"><see cref="T:System.Windows.Forms.TextFormatFlags"/> to be changed.</param>
            <returns>Changed <see cref="T:System.Windows.Forms.TextFormatFlags"/>.</returns>
        </member>
        <member name="T:MKY.Drawing.RotateType">
            <summary>
            This enum reduces <see cref="T:System.Drawing.RotateFlipType"/> to rotation.
            </summary>
        </member>
        <member name="T:MKY.Drawing.RotateTypeEx">
            <summary>
            This class provides explicit conversion methods for <see cref="T:MKY.Drawing.RotateType"/>.
            </summary>
            <remarks>
            The conversions are intentionally implemented using this helper class because this
            implementation is faster than using a <see cref="T:System.ComponentModel.TypeConverter"/>.
            </remarks>
        </member>
        <member name="F:MKY.Drawing.RotateTypeEx.Default">
            <summary>Default is <see cref="F:MKY.Drawing.RotateType.RotateNone"/>.</summary>
        </member>
        <member name="M:MKY.Drawing.RotateTypeEx.AngleFromDifference(MKY.Drawing.RotateType,MKY.Drawing.RotateType)">
            <summary></summary>
        </member>
        <member name="M:MKY.Drawing.RotateTypeEx.RotationFromAngle(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.Drawing.RotateTypeEx.RotationFromDifference(MKY.Drawing.RotateType,MKY.Drawing.RotateType)">
            <summary></summary>
        </member>
        <member name="M:MKY.Drawing.RotateTypeEx.ConvertToRotateFlipType(MKY.Drawing.RotateType)">
            <summary></summary>
        </member>
        <member name="M:MKY.Drawing.RotateTypeEx.ConvertToRotateType(System.Drawing.RotateFlipType)">
            <summary></summary>
        </member>
        <member name="T:MKY.Drawing.FlipType">
            <summary>
            This enum reduces <see cref="T:System.Drawing.RotateFlipType"/> to flipping.
            </summary>
        </member>
        <member name="T:MKY.Drawing.FlipTypeEx">
            <summary>
            This class provides explicit conversion methods for <see cref="T:MKY.Drawing.FlipType"/>.
            </summary>
            <remarks>
            The conversions are intentionally implemented using this helper class because this
            implementation is faster than using a <see cref="T:System.ComponentModel.TypeConverter"/>.
            </remarks>
        </member>
        <member name="F:MKY.Drawing.FlipTypeEx.Default">
            <summary>Default is <see cref="F:MKY.Drawing.FlipType.FlipNone"/>.</summary>
        </member>
        <member name="M:MKY.Drawing.FlipTypeEx.ConvertToRotateFlipType(MKY.Drawing.FlipType)">
            <summary></summary>
        </member>
        <member name="M:MKY.Drawing.FlipTypeEx.ConvertToFlipType(System.Drawing.RotateFlipType)">
            <summary></summary>
        </member>
        <member name="T:MKY.Globalization.CultureInfoEx">
            <summary>
            Some CultureInfo utilities.
            </summary>
        </member>
        <member name="M:MKY.Globalization.CultureInfoEx.GetMostAppropriateCulture(System.Collections.Generic.IEnumerable{System.Globalization.CultureInfo})">
            <summary>
            Returns the most appropriate culture info from a collection of culture information.
            </summary>
        </member>
        <member name="M:MKY.Globalization.CultureInfoEx.GetMostAppropriateUICulture(System.Collections.Generic.IEnumerable{System.Globalization.CultureInfo})">
            <summary>
            Returns the most appropriate UI culture info from a collection of culture information.
            </summary>
        </member>
        <member name="T:MKY.GuidEx">
            <summary>
            Some GUID utilities.
            </summary>
        </member>
        <member name="F:MKY.GuidEx.CommonRegexPattern">
            <summary>
            A compiled <see cref="F:MKY.GuidEx.CommonRegexPattern"/> that can be used for parsing a GUID from a string.
            </summary>
            <remarks>
            This regular expression works for the common "N", "D", "B" and "P" formats of
            <see cref="M:System.Guid.ToString(System.String)"/> or <see cref="M:System.Guid.ToString(System.String,System.IFormatProvider)"/>,
            but not for the uncommon "X" format (hexadecimal values enclosed in braces, fourth value enclosed in additional braces).
            </remarks>
        </member>
        <member name="M:MKY.GuidEx.TryParseCommonTolerantly(System.String,System.Guid@)">
            <summary>
            Tries to create and return a <see cref="T:System.Guid"/> object from the string specified,
            using <see cref="F:MKY.GuidEx.CommonRegexPattern"/> to parse <paramref name="s"/> tolerantly.
            </summary>
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="T:MKY.GuidList`1">
            <summary>
            List with additional methods to handle items providing a <see cref="T:System.Guid"/>.
            </summary>
            <typeparam name="T">Type that implements <see cref="T:MKY.IGuidProvider"/>.</typeparam>
        </member>
        <member name="M:MKY.GuidList`1.#ctor">
            <summary></summary>
        </member>
        <member name="M:MKY.GuidList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary></summary>
        </member>
        <member name="M:MKY.GuidList`1.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.GuidList`1.AddOrReplace(`0)">
            <summary>
            Add or replaces the item that has the same <see cref="T:System.Guid"/> as item.
            </summary>
        </member>
        <member name="M:MKY.GuidList`1.Replace(`0)">
            <summary>
            Replaces the item that has the same <see cref="T:System.Guid"/> as item.
            </summary>
        </member>
        <member name="M:MKY.GuidList`1.Find(System.Guid)">
            <summary>
            Returns the first item within the list that has the specified <see cref="T:System.Guid"/>,
            <c>null</c>  if no item with the specified <see cref="T:System.Guid"/> exists.
            </summary>
        </member>
        <member name="M:MKY.GuidList`1.Remove(System.Guid)">
            <summary>
            Removes the first item within the list that has the specified <see cref="T:System.Guid"/>,
            and returns it, <c>null</c> if no item with the specified <see cref="T:System.Guid"/> exists.
            </summary>
        </member>
        <member name="T:MKY.IGuidProvider">
            <summary>
            Interface that can be implemented by types providing a <see cref="P:MKY.IGuidProvider.Guid"/>.
            </summary>
        </member>
        <member name="P:MKY.IGuidProvider.Guid">
            <summary>
            Returns the <see cref="P:MKY.IGuidProvider.Guid"/> of the providing object.
            </summary>
        </member>
        <member name="T:MKY.DisposableBase">
             <summary>
             Provides a thread-safe base implementation of the standard <see cref="T:System.IDisposable"/>
             as well as the extended <see cref="T:MKY.IDisposableEx"/> interfaces.
             </summary>
             <remarks>
             Based on Brian Lambert's "A simple and totally thread-safe implementation of IDisposable".
             https://docs.microsoft.com/en-us/archive/blogs/blambert/a-simple-and-totally-thread-safe-implementation-of-idisposable
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="F:MKY.DisposableBase.disposableState">
            <summary>
            A value which indicates the disposable state.
            <list type="bullet">
            <item><description>0 indicates undisposed.</description></item>
            <item><description>1 indicates disposal is ongoing or has completed.</description></item>
            </list>
            </summary>
            <remarks>
            <c>int</c> rather than <c>bool</c> is required for thread-safe operations.
            </remarks>
        </member>
        <member name="P:MKY.DisposableBase.IsUndisposed">
            <summary>
            Gets a value indicating whether disposal of object is neither ongoing nor has completed.
            </summary>
            <remarks>
            Being aware that "undisposed" is an uncommon term, it indeed seems the best matching
            because a) it contains "dispose" and thus links to <see cref="T:System.IDisposable"/> and
            <see cref="M:System.IDisposable.Dispose"/> and b) does not mislead to be limited to "completed"
            as "IsDisposed" would. Also note <see cref="P:System.Windows.Forms.Control.Disposing"/>
            and <see cref="P:System.Windows.Forms.Control.IsDisposed"/> which explicitly indicate the
            state of the disposal sequence, i.e. only either or can be <c>true</c>.
            </remarks>
        </member>
        <member name="P:MKY.DisposableBase.IsInDisposal">
            <summary>
            Gets a value indicating whether disposal of object is either ongoing or has completed.
            </summary>
            <remarks>
            This is a convenience property to prevent hardly comprehensive and thus potentially
            error-prone code like <code>if (!IsUndisposed)</code>.
            </remarks>
        </member>
        <member name="M:MKY.DisposableBase.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing or releasing resources.
            </summary>
        </member>
        <member name="M:MKY.DisposableBase.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:MKY.DisposableBase.Dispose"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="M:MKY.DisposableBase.AssertUndisposed">
            <summary>
            Asserts that disposal of object is neither ongoing nor has already completed.
            </summary>
            <remarks>
            Not named "AssertIsUndisposed" as that sounds more like "check whether assert is undisposed".
            </remarks>
        </member>
        <member name="M:MKY.DisposableBase.DebugMessage(System.String,System.Object[])">
            <remarks><para>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with the formatted message, and rather than e.g. "Common" for comprehensibility.
            </para><para>
            <c>private</c> because a derived class cannot override a method that is decorated with
            the <see cref="T:System.Diagnostics.ConditionalAttribute"/>, as that is limited to file scope.
            </para></remarks>
        </member>
        <member name="M:MKY.DisposableBase.DebugMessage(System.String)">
            <remarks><para>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with <paramref name="message"/>, and rather than e.g. "Common" for comprehensibility.
            </para><para>
            <c>private</c> because a derived class cannot override a method that is decorated with
            the <see cref="T:System.Diagnostics.ConditionalAttribute"/>, as that is limited to file scope.
            </para></remarks>
        </member>
        <member name="T:MKY.IO.DirectoryEx">
            <summary>
            Utility methods for <see cref="T:System.IO.Directory"/>.
            </summary>
        </member>
        <member name="M:MKY.IO.DirectoryEx.IsWritable(System.String)">
            <summary>
            Determines whether the given path can be written to.
            </summary>
        </member>
        <member name="M:MKY.IO.DirectoryEx.TryBrowse(System.String)">
            <summary>
            Tries to open the given path with the system's file browser/explorer.
            </summary>
            <remarks>
            Named 'Browse' instead of 'Open' to emphasize that system browser/explorer will be used.
            </remarks>
            <param name="path">Directory to browse.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.IO.DirectoryEx.TryBrowse(System.String,System.Exception@)">
            <summary>
            Tries to open the given path with the system's file browser/explorer.
            </summary>
            <remarks>
            Named 'Browse' instead of 'Open' to emphasize that system browser/explorer will be used.
            </remarks>
            <param name="path">Directory to browse.</param>
            <param name="exceptionOnFailure">Exception object, in case of failure.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.IO.DirectoryEx.MakeAllFilesWritable(System.String,System.Boolean)">
            <summary>
            Makes all files within a directory writable, including or excluding sub-directories.
            </summary>
        </member>
        <member name="T:MKY.IO.FileEx">
            <summary>
            Utility methods for <see cref="T:System.IO.File"/>.
            </summary>
        </member>
        <member name="F:MKY.IO.FileEx.BackupFileExtension">
            <summary>
            Default extension for backup files.
            </summary>
        </member>
        <member name="M:MKY.IO.FileEx.Size(System.String)">
            <summary>
            Returns the size of the given file.
            </summary>
            <param name="filePath">The file path.</param>
            <returns>
            The size of the given file.
            </returns>
        </member>
        <member name="M:MKY.IO.FileEx.IsReadable(System.String)">
            <summary>
            Determines whether the given file is readable, i.e. exists and can be accessed.
            </summary>
            <param name="filePath">The file path.</param>
            <returns>
            Returns <c>true</c> if file is readable.
            </returns>
        </member>
        <member name="M:MKY.IO.FileEx.IsReadOnly(System.String)">
            <summary>
            Determines whether the given file is read-only, i.e. exists and is read-only.
            </summary>
            <param name="filePath">The file path.</param>
            <returns>
            Returns <c>true</c> if file is read-only.
            </returns>
        </member>
        <member name="M:MKY.IO.FileEx.IsWritable(System.String)">
            <summary>
            Determines whether the given file path is writeable, i.e. is not read-only or the file doesn't exist yet.
            </summary>
            <param name="filePath">The file path.</param>
            <returns>
            Returns <c>true</c> if file is writeable.
            </returns>
        </member>
        <member name="M:MKY.IO.FileEx.IsFindable(System.String)">
            <summary>
            Determines whether the given file is findable, e.g. via the system's PATH variable.
            </summary>
            <param name="fileName">The file name, typically an executable.</param>
            <returns>
            Returns <c>true</c> if file is findable.
            </returns>
        </member>
        <member name="M:MKY.IO.FileEx.IsFindable(System.String,System.String@)">
            <summary>
            Determines whether the given file is findable, e.g. via the system's PATH variable.
            </summary>
            <param name="fileName">The file name, typically an executable.</param>
            <param name="filePath">The path to the file.</param>
            <returns>
            Returns <c>true</c> if file is findable.
            </returns>
        </member>
        <member name="M:MKY.IO.FileEx.TryDelete(System.String)">
            <summary>
            Tries to delete file <paramref name="filePath"/>.
            </summary>
            <returns>
            Returns <c>true</c> if file successfully saved.
            </returns>
        </member>
        <member name="M:MKY.IO.FileEx.TrySwap(System.String,System.String)">
            <summary>
            Tries to swap two existing files.
            </summary>
        </member>
        <member name="M:MKY.IO.FileEx.Swap(System.String,System.String)">
            <summary>
            Swaps two existing files.
            </summary>
        </member>
        <member name="M:MKY.IO.FileEx.GetUniqueFilePath(System.String,System.String)">
            <summary>
            Returns a unique file path for the initial file path specified, unique part is separated by optional separator string.
            </summary>
            <remarks>
            <see cref="M:MKY.IO.PathEx.GetUniqueTempPath"/> offers a similar method using a globally unique file name.
            </remarks>
        </member>
        <member name="T:MKY.IO.LogFile">
            <summary>
            Thread-safe log file.
            </summary>
        </member>
        <member name="M:MKY.IO.LogFile.#ctor(System.String,System.Boolean)">
            <summary>
            Starts log file.
            </summary>
            <remarks>
            Using UTF-8 encoding with (Windows) or without (Unix, Linux,...) BOM.
            </remarks>
            <param name="filePath">Path of log file.</param>
            <param name="append">true to append to file, false to replace file.</param>
        </member>
        <member name="M:MKY.IO.LogFile.#ctor(System.String,System.Boolean,System.Text.Encoding)">
            <summary>
            Starts log file.
            </summary>
            <param name="filePath">Path of log file.</param>
            <param name="append">true to append to file, false to replace file.</param>
            <param name="encoding">Encoding of log file.</param>
        </member>
        <member name="M:MKY.IO.LogFile.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:MKY.IO.LogFile.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="P:MKY.IO.LogFile.FilePath">
            <summary>
            Returns complete path of log file.
            </summary>
        </member>
        <member name="P:MKY.IO.LogFile.UnderlyingStream">
            <summary>
            Returns underlying stream.
            </summary>
        </member>
        <member name="M:MKY.IO.LogFile.WriteLine(System.String,System.String)">
            <summary>
            Writes a line into log file and adds a time stamp.
            </summary>
        </member>
        <member name="M:MKY.IO.LogFile.Close">
            <summary>
            Closes log file.
            </summary>
        </member>
        <member name="T:MKY.IO.PathEx">
            <summary>
            Utility methods for <see cref="T:System.IO.Path"/>.
            </summary>
        </member>
        <member name="P:MKY.IO.PathEx.Comparer">
            <summary>
            The comparer dependent on the operating systems policies.
            </summary>
        </member>
        <member name="P:MKY.IO.PathEx.ComparisonType">
            <summary>
            The comparison type dependent on the operating systems policies.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.ConvertToPlatform(System.String)">
            <summary>
            Convert non-platform separators according to platform.
            </summary>
        </member>
        <member name="P:MKY.IO.PathEx.InvalidPathRoot">
            <summary>
            Returns an invalid path root.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.Equals(System.String,System.String)">
            <summary>
            Compares two specified path string, dependent on the operating systems policies.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.EqualsAny(System.String,System.String[])">
            <summary>
            Compares whether <paramref name="pathA"/> matches any <paramref name="pathB"/>,
            dependent on the operating systems policies.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.EqualsAny(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Compares whether <paramref name="pathA"/> matches any <paramref name="pathB"/>,
            dependent on the operating systems policies.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.ContainsAny(System.String,System.String[])">
            <summary>
            Determines whether <paramref name="path"/> matches one of the specified <paramref name="values"/>,
            dependent on the operating systems policies.
            </summary>
            <param name="path">The string.</param>
            <param name="values">The strings to compare with.</param>
            <returns>true if <paramref name="path"/> matches the beginning of a comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">value is null.</exception>
        </member>
        <member name="M:MKY.IO.PathEx.ContainsAny(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether <paramref name="path"/> matches one of the specified <paramref name="values"/>.
            </summary>
            <param name="path">The string.</param>
            <param name="values">The strings to compare with.</param>
            <returns>true if <paramref name="path"/> matches the beginning of a comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">value is null.</exception>
        </member>
        <member name="M:MKY.IO.PathEx.IsContainedInvariant(System.String,System.String)">
            <summary>
            Returns whether <paramref name="str"/> contains the given <paramref name="path"/>. The
            comparison is done in a platform independent way, i.e. any path designation is accepted.
            </summary>
            <remarks>
            Named 'IsContained' instead of 'Contains' as <paramref name="str"/> can be any string,
            not just a path string.
            </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.IsValid(System.String)">
            <summary>
            Returns whether the directory or file path is valid.
            </summary>
            <remarks>
            This method only checks whether the path is valid but not whether it actually exists.
            Use <see cref="M:System.IO.Directory.Exists(System.String)"/> or <see cref="M:System.IO.File.Exists(System.String)"/> to check existence.
            </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.NormalizeExtension(System.String)">
            <summary>
            Normalizes an extension, i.e. prepends a '.' if missing.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.DenormalizeExtension(System.String)">
            <summary>
            Denormalizes an extension, i.e. removes a '.' if apparent.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.Limit(System.String,System.Int32)">
            <summary>
            Limits a directory or file path to the specified max length. If the path exceed the
            max length, <see cref="F:MKY.StringEx.Ellipsis"/> are added before the last part of the path
            (same behavior as <see cref="F:System.Windows.Forms.TextFormatFlags.PathEllipsis"/>).
            </summary>
            <remarks>
            This function does not expand environment variables.
            </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.AppendPostfixToFileName(System.String,System.String)">
            <summary>
            Appends a directory or file path to the specified max length.
            </summary>
            <remarks>
            This function does not expand environment variables.
            </remarks>
            <example>
            <code>
            string filePath = "C:\\Temp\\MyFile.txt";
            filePath = PathEx.AppendPostfixToFileName(filePath, "_ABC");
            </code>
            <paramref name="filePath"/> will now be "C:\\Temp\\MyFile_ABC.txt".
            </example>
            <param name="filePath">Path to the file.</param>
            <param name="fileNamePostfix">Postfix that shall be appended to the file name.</param>
            <returns>The resulting file path.</returns>
        </member>
        <member name="M:MKY.IO.PathEx.CompareDirectoryPaths(System.String,System.String)">
             <summary>
             Compares <paramref name="directoryPathB"/> relative to <paramref name="directoryPathA"/>
             and returns relative path of <paramref name="directoryPathB"/>.
             </summary>
             <remarks>
             Returns <paramref name="directoryPathB"/> if it already is relative.
             Why is this functionality not already provided by <see cref="T:System.IO.Path"/>?
             Seems that the Microsoft guys were a bit lazy ;-)
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.CompareDirectoryAndFilePaths(System.String,System.String)">
             <summary>
             Compares <paramref name="filePath"/> relative to <paramref name="directoryPath"/> and
             returns relative path of file.
             </summary>
             <remarks>
             Returns <paramref name="filePath"/> if it already is relative.
             Why is this functionality not already provided by <see cref="T:System.IO.Path"/>?
             Seems that the Microsoft guys were a bit lazy ;-)
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.CompareFileAndDirectoryPaths(System.String,System.String)">
             <summary>
             Compares <paramref name="directoryPath"/> relative to <paramref name="filePath"/> and
             returns relative path of <paramref name="directoryPath"/>.
             </summary>
             <remarks>
             Returns <paramref name="directoryPath"/> if it already is relative.
             Why is this functionality not already provided by <see cref="T:System.IO.Path"/>?
             Seems that the Microsoft guys were a bit lazy ;-)
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.CompareFilePaths(System.String,System.String)">
             <summary>
             Compares <paramref name="filePathB"/> relative to <paramref name="filePathA"/> and
             returns relative path of fileB.
             </summary>
             <remarks>
             Returns <paramref name="filePathB"/> if it already is relative.
             Why is this functionality not already provided by <see cref="T:System.IO.Path"/>?
             Seems that the Microsoft guys were a bit lazy ;-)
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.CombineDirectoryPaths(System.String,System.String)">
             <summary>
             Resolves <paramref name="directoryPathB"/> relative to <paramref name="directoryPathA"/>
             and returns normalized absolute path of <paramref name="directoryPathB"/>.
             </summary>
             <remarks>
             Returns <paramref name="directoryPathB"/> if it is absolute.
             Why is this functionality not already provided by <see cref="T:System.IO.Path"/>?
             Seems that the Microsoft guys were a bit lazy ;-)
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.CombineDirectoryAndFilePaths(System.String,System.String)">
             <summary>
             Resolves <paramref name="filePath"/> relative to <paramref name="directoryPath"/> and
             returns normalized absolute path of file.
             </summary>
             <remarks>
             Returns <paramref name="filePath"/> if it is absolute.
             Why is this functionality not already provided by <see cref="T:System.IO.Path"/>?
             Seems that the Microsoft guys were a bit lazy ;-)
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.CombineFileAndDirectoryPaths(System.String,System.String)">
             <summary>
             Resolves <paramref name="directoryPath"/> relative to <paramref name="filePath"/> and
             returns normalized absolute path of <paramref name="directoryPath"/>.
             </summary>
             <remarks>
             Returns <paramref name="directoryPath"/> if it is absolute.
             Why is this functionality not already provided by <see cref="T:System.IO.Path"/>?
             Seems that the Microsoft guys were a bit lazy ;-)
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.CombineFilePaths(System.String,System.String)">
             <summary>
             Resolves <paramref name="filePathB"/> relative to <paramref name="filePathA"/> and
             returns normalized absolute path of fileB.
             </summary>
             <remarks>
             Returns <paramref name="filePathB"/> if it is absolute.
             Why is this functionality not already provided by <see cref="T:System.IO.Path"/>?
             Seems that the Microsoft guys were a bit lazy ;-)
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.DoCompareDirectoryPaths(System.String,System.String)">
            <summary>
            Returns relation between the two absolute directory paths.
            </summary>
            <remarks>
            This function does not expand environment variables.
            </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.DoCombineDirectoryPaths(System.String,System.String)">
            <summary>
            Takes the first directory path and combines it with the second directory
            path also taking "." and ".." into account.
            </summary>
            <remarks>
            This function does not expand environment variables.
            </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.DoPrepareDirectoryPath(System.String,System.IO.DirectoryInfo@,System.String@,System.IO.DirectoryInfo@)">
            <remarks>
            This function does not expand environment variables.
            </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.DoPrepareFilePath(System.String,System.IO.DirectoryInfo@,System.String@,System.IO.DirectoryInfo@,System.String@)">
            <remarks>
            This function does not expand environment variables.
            </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.Distinct(System.Collections.Generic.IEnumerable{System.String}[])">
            <summary>
            Retrieves the distinct (no duplicate) paths among all given paths.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.Distinct(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Retrieves the distinct (no duplicate) paths among the given paths.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.DistinctDirectories(System.Collections.Specialized.StringCollection)">
            <summary>
            Retrieves the distinct (no duplicate) directories among the given paths.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.DistinctDirectories(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Retrieves the distinct (no duplicate) directories among the given paths.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.GetDirectoryPath(System.String)">
            <summary>
            Returns the directory information for the specified path string.
            </summary>
            <remarks>
            Same as <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/>, but with the proper method name.
            </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.GetDirectoryNameOnly(System.String)">
            <summary>
            Returns the name of the given path.
            </summary>
            <remarks>
            Opposed to <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/>, this method returns the directory
            name only, not the full directory path.
            </remarks>
        </member>
        <member name="M:MKY.IO.PathEx.GetNormalizedRootedExpandingEnvironmentVariables(System.String)">
            <summary>
            Resolves the absolute location to the given file path and normalizes it, expanding environment variables.
             - If <see cref="M:System.IO.Path.IsPathRooted(System.String)"/>, simply expand environment variables.
             - Otherwise, expand environment variables and combine it with the <see cref="P:System.Environment.CurrentDirectory"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="filePath"/> is null.
            </exception>
        </member>
        <member name="M:MKY.IO.PathEx.GetNormalizedRootedExpandingEnvironmentVariables(System.String,System.String)">
            <summary>
            Resolves the absolute location to the given file path and normalizes it, expanding environment variables.
             - If <see cref="M:System.IO.Path.IsPathRooted(System.String)"/>, simply expand environment variables.
             - Otherwise, expand environment variables and combine it with the given <paramref name="rootDirectory"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="filePath"/> is null.
            </exception>
        </member>
        <member name="M:MKY.IO.PathEx.TryGetCommon(System.String,System.String,System.String@)">
            <summary>
            Evaluates whether the given paths share a common parent and returns the common part.
            </summary>
        </member>
        <member name="M:MKY.IO.PathEx.GetUniqueTempPath">
            <summary>
            Returns a unique temporary file path, using a new guid (= globally unique).
            </summary>
            <remarks>
            <see cref="M:MKY.IO.FileEx.GetUniqueFilePath(System.String,System.String)"/> offers a similar method keeping the file name.
            </remarks>
        </member>
        <member name="T:MKY.IO.PathCompareResult">
            <summary>
            Structure to hold the complete result of a directory comparison.
            </summary>
        </member>
        <member name="P:MKY.IO.PathCompareResult.HaveCommon">
            <summary>True if directories share a common path, i.e. also a common root.</summary>
        </member>
        <member name="P:MKY.IO.PathCompareResult.CommonPath">
            <summary>Common path, e.g. "C:\MyDir".</summary>
        </member>
        <member name="P:MKY.IO.PathCompareResult.CommonDirectoryCount">
            <summary>Number of common directories, e.g. "C:\MyDir" results in 1.</summary>
        </member>
        <member name="P:MKY.IO.PathCompareResult.AreRelative">
            <summary>True if directories are relative, e.g. "C:\MyDir\MySubDir1" and "C:\MyDir\MySubDir2".</summary>
        </member>
        <member name="P:MKY.IO.PathCompareResult.RelativeDirectoryCount">
            <summary>Number of relative directories, e.g. "C:\MyDir\MySubDir1" and "C:\MyDir\MySubDir2" results in 2.</summary>
        </member>
        <member name="P:MKY.IO.PathCompareResult.AreNearRelative">
            <summary>True if directories are near relative, e.g. "C:\MyDir" and "C:\MyDir\MySubDir".</summary>
        </member>
        <member name="P:MKY.IO.PathCompareResult.NearRelativeDirectoryCount">
            <summary>Number of near relative directories, e.g. "C:\MyDir" and "C:\MyDir\MySubDir" results in 1.</summary>
        </member>
        <member name="P:MKY.IO.PathCompareResult.RelativePath">
            <summary>Relative path between the two.</summary>
        </member>
        <member name="M:MKY.IO.PathCompareResult.#ctor(System.Boolean)">
            <summary>Creates a directory info compare result structure.</summary>
        </member>
        <member name="M:MKY.IO.PathCompareResult.#ctor(System.Boolean,System.String)">
            <summary>Creates a directory info compare result structure.</summary>
        </member>
        <member name="M:MKY.IO.PathCompareResult.#ctor(System.String,System.Int32,System.Int32,System.String)">
            <summary>Creates a directory info compare result structure.</summary>
        </member>
        <member name="M:MKY.IO.PathCompareResult.#ctor(System.String,System.Int32,System.Int32,System.Boolean,System.Int32,System.String)">
            <summary>Creates a directory info compare result structure.</summary>
        </member>
        <member name="M:MKY.IO.PathCompareResult.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.IO.PathCompareResult.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.IO.PathCompareResult.Equals(MKY.IO.PathCompareResult)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.IO.PathCompareResult.op_Equality(MKY.IO.PathCompareResult,MKY.IO.PathCompareResult)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.IO.PathCompareResult.op_Inequality(MKY.IO.PathCompareResult,MKY.IO.PathCompareResult)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.IO.StreamEx">
            <summary>
            Utility methods for <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="F:MKY.IO.StreamEx.EndOfStream">
            <summary>
            Result when reading the stream's end.
            </summary>
            <remarks>
            Value corresponds to the value returned by <see cref="M:System.IO.Stream.ReadByte"/>
            and the other read functions if no more characters can be read from the stream.
            Value also corresponds to <see cref="F:MKY.CharEx.InvalidChar"/>.
            </remarks>
        </member>
        <member name="F:MKY.IO.StreamEx.UnknownLength">
            <summary>
            Result when stream length cannot be retrieved from a stream,
            e.g. if the stream is not seekable.
            </summary>
        </member>
        <member name="M:MKY.IO.StreamEx.RemainingLength(System.IO.Stream)">
            <summary>
            Returns the true length of available data in a stream.
            </summary>
        </member>
        <member name="M:MKY.IO.StreamEx.HasRemainingData(System.IO.Stream)">
            <summary>
            Returns whether the given stream contains more data.
            </summary>
        </member>
        <member name="M:MKY.IO.StreamEx.AtLeastRemaining(System.IO.Stream,System.Int32)">
            <summary>
            Returns whether the given stream contains at least the given amount of data.
            </summary>
        </member>
        <member name="T:MKY.IO.Temp">
            <summary>
            Utility methods to deal with temporary files, e.g. during testing.
            </summary>
        </member>
        <member name="M:MKY.IO.Temp.MakeTempPath(System.Type,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:MKY.IO.Temp.CleanTempPath(System.Type,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:MKY.IO.Temp.MakeTempFileName(System.Type,System.String)">
            <param name="type">The type of an object, is used to retrieve namespace and type name.</param>
            <param name="extension">The desired file extension, must include the dot as it is the case in similar I/O methods of .NET.</param>
        </member>
        <member name="M:MKY.IO.Temp.MakeTempFileName(System.Type,System.String,System.String)">
            <param name="type">The type of an object, is used to retrieve namespace and type name.</param>
            <param name="name">An additional name that is appended to the file name.</param>
            <param name="extension">The desired file extension, must include the dot as it is the case in similar I/O methods of .NET.</param>
        </member>
        <member name="M:MKY.IO.Temp.MakeTempFileName(System.Type,System.String,System.String,System.String)">
            <param name="type">The type of an object, is used to retrieve namespace and type name.</param>
            <param name="name">An additional name that is appended to the file name.</param>
            <param name="postfix">Yet another postfix to the file name.</param>
            <param name="extension">The desired file extension, must include the dot as it is the case in similar I/O methods of .NET.</param>
        </member>
        <member name="M:MKY.IO.Temp.MakeTempFilePath(System.Type,System.String,System.Boolean)">
            <param name="type">The type of an object, is used to retrieve namespace and type name.</param>
            <param name="extension">The desired file extension, must include the dot as it is the case in similar I/O methods of .NET.</param>
            <param name="acceptExistingFile">Set to <c>true</c> to accept an existing file, e.g. when appending to the file. If <c>false</c>, the file name will be postfixed with a unique number.</param>
        </member>
        <member name="M:MKY.IO.Temp.MakeTempFilePath(System.Type,System.String,System.String,System.Boolean,System.Boolean)">
            <param name="type">The type of an object, is used to retrieve namespace and type name.</param>
            <param name="name">An additional name that is appended to the file name.</param>
            <param name="extension">The desired file extension, must include the dot as it is the case in similar I/O methods of .NET.</param>
            <param name="acceptExistingFile">Set to <c>true</c> to accept an existing file, e.g. when appending to the file. If <c>false</c>, the file name will be postfixed with a unique number.</param>
            <param name="outputFilePathToDebug">Optionally output the resulting file path to <see cref="T:System.Diagnostics.Debug"/>.</param>
        </member>
        <member name="T:MKY.IO.TextEx">
            <summary></summary>
        </member>
        <member name="M:MKY.IO.TextEx.ToLines(System.String[],System.IFormatProvider)">
            <summary>
            Converts a string array to a multi-line string, using <see cref="P:System.Environment.NewLine"/>
            as the end-of-line separator.
            </summary>
        </member>
        <member name="M:MKY.IO.TextEx.ToLines(System.String[],System.IFormatProvider,System.String)">
            <summary>
            Converts a string array to a multi-line string, using the given end-of-line separator.
            </summary>
        </member>
        <member name="M:MKY.IO.TextEx.FromLines(System.String)">
            <summary>
            Converts a multi-line string to a string array.
            </summary>
        </member>
        <member name="T:MKY.MarshalByRefWrapper`1">
            <summary>
            Wrapper class that wraps a 'MarshalByValObject' type to <see cref="T:System.MarshalByRefObject"/>.
            </summary>
            <remarks>
            Based on https://stackoverflow.com/questions/22766549/cross-appdomain-cancelable-event.
            </remarks>
            <typeparam name="T">The type of the object to wrap.</typeparam>
        </member>
        <member name="P:MKY.MarshalByRefWrapper`1.Obj">
            <summary>
            Gets the object that has been wrapped.
            </summary>
        </member>
        <member name="M:MKY.MarshalByRefWrapper`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.MarshalByRefWrapper`1"/> class.
            </summary>
        </member>
        <member name="M:MKY.MarshalByRefWrapper`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.MarshalByRefWrapper`1"/> class.
            </summary>
            <param name="obj">The object to be wrapped.</param>
        </member>
        <member name="M:MKY.MarshalByRefWrapper`1.op_Implicit(`0)~MKY.MarshalByRefWrapper{`0}">
            <summary>
            Performs an implicit conversion from <typeparamref name="T"/> to <see cref="T:MKY.MarshalByRefWrapper`1"/>.
            </summary>
            <param name="obj">The object to be converted.</param>
        </member>
        <member name="T:MKY.Media.SystemSounds">
            <summary></summary>
        </member>
        <member name="F:MKY.Media.SystemSounds.None">
            <remarks>No corresponding item in <see cref="T:System.Media.SystemSounds"/>.</remarks>
        </member>
        <member name="F:MKY.Media.SystemSounds.Asterisk">
            <remarks>Corresponds to <see cref="P:System.Media.SystemSounds.Asterisk"/>.</remarks>
        </member>
        <member name="F:MKY.Media.SystemSounds.Beep">
            <remarks>Corresponds to <see cref="P:System.Media.SystemSounds.Beep"/>.</remarks>
        </member>
        <member name="F:MKY.Media.SystemSounds.Exclamation">
            <remarks>Corresponds to <see cref="P:System.Media.SystemSounds.Exclamation"/>.</remarks>
        </member>
        <member name="F:MKY.Media.SystemSounds.Hand">
            <remarks>Corresponds to <see cref="P:System.Media.SystemSounds.Hand"/>.</remarks>
        </member>
        <member name="F:MKY.Media.SystemSounds.Question">
            <remarks>Corresponds to <see cref="P:System.Media.SystemSounds.Question"/>.</remarks>
        </member>
        <member name="T:MKY.Media.SystemSoundsEx">
            <summary>
            Extended enum SystemSoundsEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:MKY.Media.SystemSoundsEx.Default">
            <summary>Default is <see cref="F:MKY.Media.SystemSounds.None"/>.</summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.#ctor">
            <summary>Default is <see cref="F:MKY.Media.SystemSoundsEx.Default"/>.</summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.#ctor(MKY.Media.SystemSounds)">
            <summary></summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.Play">
            <summary></summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.TryParse(System.String,MKY.Media.SystemSoundsEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.TryParse(System.String,MKY.Media.SystemSounds@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.op_Implicit(MKY.Media.SystemSoundsEx)~MKY.Media.SystemSounds">
            <summary></summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.op_Implicit(MKY.Media.SystemSounds)~MKY.Media.SystemSoundsEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.op_Implicit(MKY.Media.SystemSoundsEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.op_Implicit(System.Int32)~MKY.Media.SystemSoundsEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.op_Implicit(MKY.Media.SystemSoundsEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.op_Implicit(System.String)~MKY.Media.SystemSoundsEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.op_Implicit(MKY.Media.SystemSoundsEx)~System.Media.SystemSound">
            <summary></summary>
        </member>
        <member name="M:MKY.Media.SystemSoundsEx.op_Implicit(System.Media.SystemSound)~MKY.Media.SystemSoundsEx">
            <summary></summary>
        </member>
        <member name="T:MKY.Net.Browser">
            <summary>
            Browser utility methods.
            </summary>
        </member>
        <member name="M:MKY.Net.Browser.TryBrowseUri(System.String)">
            <summary>
            Tries to browse the given URI with the system's default browser.
            </summary>
            <param name="uri">URI to browse.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Net.Browser.TryBrowseUri(System.String,System.Exception@)">
            <summary>
            Tries to browse the given URI with the system's default browser.
            </summary>
            <param name="uri">URI to browse.</param>
            <param name="exceptionOnFailure">Exception object, in case of failure.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Net.Browser.TryBrowseUri(System.Uri)">
            <summary>
            Tries to browse the given URI with the system's default browser.
            </summary>
            <param name="uri">URI to browse.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Net.Browser.TryBrowseUri(System.Uri,System.Exception@)">
            <summary>
            Tries to browse the given URI with the system's default browser.
            </summary>
            <param name="uri">URI to browse.</param>
            <param name="exceptionOnFailure">Exception object, in case of failure.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:MKY.Net.IPAddressEx">
            <summary>
            <see cref="T:System.Net.IPAddress"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.Net.IPAddressEx.GetAnyOfFamily(System.Net.IPAddress)">
            <summary>
            Returns <see cref="F:System.Net.IPAddress.Any"/> if <paramref name="address"/> is <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork"/>.
            Returns <see cref="F:System.Net.IPAddress.IPv6Any"/> if <paramref name="address"/> is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6"/>.
            </summary>
        </member>
        <member name="M:MKY.Net.IPAddressEx.GetNoneOfFamily(System.Net.IPAddress)">
            <summary>
            Returns <see cref="F:System.Net.IPAddress.None"/> if <paramref name="address"/> is <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork"/>.
            Returns <see cref="F:System.Net.IPAddress.IPv6None"/> if <paramref name="address"/> is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6"/>.
            </summary>
        </member>
        <member name="M:MKY.Net.IPAddressEx.GetLoopbackOfFamily(System.Net.IPAddress)">
            <summary>
            Returns <see cref="F:System.Net.IPAddress.Loopback"/> if <paramref name="address"/> is <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork"/>.
            Returns <see cref="F:System.Net.IPAddress.IPv6Loopback"/> if <paramref name="address"/> is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6"/>.
            </summary>
        </member>
        <member name="M:MKY.Net.IPAddressEx.IsMulticast(System.Net.IPAddress)">
            <summary>
            Determines whether the specified address is a multicast address.
            </summary>
        </member>
        <member name="M:MKY.Net.IPAddressEx.IsIPv4Multicast(System.Net.IPAddress)">
            <summary>
            Determines whether the specified address is an IPv4 multicast address.
            </summary>
        </member>
        <member name="M:MKY.Net.IPAddressEx.Equals(System.Net.IPAddress,System.Net.IPAddress)">
             <summary>
             Determines whether the specified <see cref="T:System.Net.IPAddress"/> instances are considered equal.
             </summary>
             <remarks>
             Convenience method because <see cref="T:System.Net.IPAddress"/> does not override the ==/!= operators, thanks Microsoft guys...
            
             This method is simply a wrapper to <see cref="M:System.Object.Equals(System.Object,System.Object)"/>.
             It can e.g. be used to implement an overloaded Equals() method.
            
             Note the logic behind <see cref="M:System.Object.Equals(System.Object,System.Object)"/>:
              - If both objects represent the same object reference, it returns true.
              - If either or object is <c>null</c>, it returns false.
              - Otherwise, it calls objA.Equals(objB) and returns the result.
             </remarks>
             <param name="addressA">The first <see cref="T:System.Net.IPAddress"/> to compare.</param>
             <param name="addressB">The second <see cref="T:System.Net.IPAddress"/> to compare.</param>
             <returns><c>true</c> if the instances are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Net.IPAddressEx.EqualsNone(System.Net.IPAddress)">
            <summary>
            Determines whether the specified <paramref name="address"/> has the value of <see cref="F:System.Net.IPAddress.None"/> or <see cref="F:System.Net.IPAddress.IPv6None"/>.
            </summary>
            <remarks>
            Convenience method because <see cref="T:System.Net.IPAddress"/> does not override the ==/!= operators, thanks Microsoft guys...
            </remarks>
            <param name="address">Address to evaluate.</param>
            <returns><c>true</c> if value is valid; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Net.IPAddressEx.NotEqualsNone(System.Net.IPAddress)">
            <summary>
            Determines whether the specified <paramref name="address"/> has a value other than <see cref="F:System.Net.IPAddress.None"/> or <see cref="F:System.Net.IPAddress.IPv6None"/>.
            </summary>
            <remarks>
            Convenience method because <see cref="T:System.Net.IPAddress"/> does not override the ==/!= operators, thanks Microsoft guys...
            </remarks>
            <param name="address">Address to evaluate.</param>
            <returns><c>true</c> if value is valid; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:MKY.Net.IPEndPointEx">
            <summary>
            <see cref="T:System.Net.IPEndPoint"/> utility methods.
            </summary>
        </member>
        <member name="P:MKY.Net.IPEndPointEx.Empty">
            <summary>
            An empty IP end point, i.e. address 0.0.0.0 and port 0.
            </summary>
            <remarks>
            Must be implemented as property (instead of a readonly) since <see cref="T:System.Net.IPEndPoint"/>
            is a mutable reference type. Defining a readonly would correctly result in FxCop
            message CA2104 "DoNotDeclareReadOnlyMutableReferenceTypes" (Microsoft.Security).
            </remarks>
        </member>
        <member name="M:MKY.Net.IPEndPointEx.IsValidPort(System.Int32)">
            <summary>
            Determines whether the specified <paramref name="port"/> has a valid value.
            </summary>
            <param name="port">Port to evaluate.</param>
            <returns><c>true</c> if value is valid; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:MKY.Net.IPFilter">
            <summary></summary>
        </member>
        <member name="T:MKY.Net.IPFilterEx">
            <summary>
            Extended enum IPFilterEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:MKY.Net.IPFilterEx.Any_string">
            <remarks>Explicitly using "[any]" instead of "[Any]" same as "[localhost]" and "[loopback]".</remarks>
        </member>
        <member name="F:MKY.Net.IPFilterEx.Localhost_string">
            <remarks>Explicitly using the more common spelling "[localhost]" instead of "[Localhost]".</remarks>
        </member>
        <member name="F:MKY.Net.IPFilterEx.staticItems">
            <remarks>
            The list of fixed items of this extended enum.
            </remarks>
        </member>
        <member name="F:MKY.Net.IPFilterEx.Default">
            <summary>Default is <see cref="F:MKY.Net.IPFilter.Any"/>.</summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.#ctor">
            <summary>Default is <see cref="F:MKY.Net.IPFilterEx.Default"/>.</summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.#ctor(MKY.Net.IPFilter)">
            <remarks>
            Do not use with <see cref="F:MKY.Net.IPFilter.Explicit"/> because that selection requires
            an IP address or host name. Use <see cref="M:MKY.Net.IPFilterEx.#ctor(System.Net.IPAddress)"/> or
            <see cref="M:MKY.Net.IPFilterEx.#ctor(System.String,System.Net.IPAddress)"/> instead.
            </remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="address"/> is <see cref="F:MKY.Net.IPFilter.Explicit"/>. Use <see cref="M:MKY.Net.IPFilterEx.#ctor(System.Net.IPAddress)"/> instead.
            </exception>
        </member>
        <member name="M:MKY.Net.IPFilterEx.#ctor(System.Net.IPAddress)">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.#ctor(System.String,System.Net.IPAddress)">
            <summary>
            Creates an explicit <see cref="T:MKY.Net.IPFilterEx"/> object, using the provided host name and optional address.
            </summary>
        </member>
        <member name="P:MKY.Net.IPFilterEx.Name">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPFilterEx.Address">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPFilterEx.IsAny">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPFilterEx.IsLocalhost">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPFilterEx.IsExplicit">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPFilterEx.IPv4MaskBytes">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.ConvertToIPv4MaskBytes">
            <summary>
            Converts the given address to filter mask bytes.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.ConvertToIPv4MaskBytes(System.Net.IPAddress)">
            <summary>
            Converts the given address to filter mask bytes.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.IsAccepted(System.Net.IPAddress)">
            <summary>
            Determines whether the given address is accepted by the filter.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.IsAccepted(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            Determines whether the given address is accepted by the given filter.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.IsIPv4Accepted(System.UInt32,System.Net.IPAddress)">
            <summary>
            Determines whether the given address is accepted by the given filter.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.IsRefused(System.Net.IPAddress)">
            <summary>
            Determines whether the given address is refused by the filter.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.IsRefused(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            Determines whether the given address is refused by the given filter.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.IsIPv4Refused(System.UInt32,System.Net.IPAddress)">
            <summary>
            Determines whether the given address is refused by the given filter.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.ToCompactString">
            <summary>
            Returns a compact string representation:
            - For predefined filters, the predefined string is returned.
            - For explicit filters, the host name or address is returned.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.ToEndpointAddressString">
             <summary>
             Returns a <see cref="T:System.String" /> that e.g. adds [] for IPv6 addresses.
             </summary>
             <remarks>
             It is recommended to use this function instead of <see cref="M:MKY.Net.IPFilterEx.ToString"/> in cases where
             the IPv6 address is immediately followed the port number, separated by a colon.
             Compare readability:
             "1:2:3:4:5:6:7:8:8080"
             "[1:2:3:4:5:6:7:8]:8080"
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.Net.IPFilterEx.ToEndpointAddressString(System.Net.IPAddress)">
             <summary>
             Returns a <see cref="T:System.String" /> that e.g. adds [] for IPv6 addresses.
             </summary>
             <remarks>
             It is recommended to use this function instead of <see cref="M:MKY.Net.IPFilterEx.ToString"/> in cases where
             the IPv6 address is immediately followed the port number, separated by a colon.
             Compare readability:
             "1:2:3:4:5:6:7:8:8080"
             "[1:2:3:4:5:6:7:8]:8080"
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.Net.IPFilterEx.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.Equals(MKY.Net.IPFilterEx)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.op_Equality(MKY.Net.IPFilterEx,MKY.Net.IPFilterEx)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.op_Inequality(MKY.Net.IPFilterEx,MKY.Net.IPFilterEx)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.GetItems">
            <remarks>
            The list of fixed items of this extended enum.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPFilterEx.Contains(MKY.Net.IPFilterEx)">
            <summary>
            Determines whether the enumeration contains the specified item.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPFilterEx.TryParse(System.String,MKY.Net.IPFilterEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPFilterEx.TryParse(System.String,MKY.Net.IPFilter@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPFilterEx.TryParseAndResolve(System.String,MKY.Net.IPFilterEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPFilterEx.TryResolve(System.String,System.Net.IPAddress@)">
            <summary>
            Tries to resolve an IP address from DNS.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.TryResolve">
            <summary>
            Tries to resolve an IP address from DNS.
            </summary>
        </member>
        <member name="P:MKY.Net.IPFilterEx.HasBeenResolved">
            <summary>
            Returns whether IP has been resolved from DNS.
            </summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.op_Implicit(MKY.Net.IPFilterEx)~MKY.Net.IPFilter">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.op_Explicit(MKY.Net.IPFilter)~MKY.Net.IPFilterEx">
            <remarks>
            Explicit because cast doesn't work for <see cref="F:MKY.Net.IPFilter.Explicit"/>.
            </remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="address"/> is <see cref="F:MKY.Net.IPFilter.Explicit"/>.
            </exception>
        </member>
        <member name="M:MKY.Net.IPFilterEx.op_Implicit(MKY.Net.IPFilterEx)~System.Net.IPAddress">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.op_Implicit(System.Net.IPAddress)~MKY.Net.IPFilterEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.op_Implicit(MKY.Net.IPFilterEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPFilterEx.op_Implicit(System.String)~MKY.Net.IPFilterEx">
            <summary></summary>
        </member>
        <member name="T:MKY.Net.IPHost">
            <summary></summary>
        </member>
        <member name="T:MKY.Net.IPHostEx">
            <summary>
            Extended enum IPHostEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:MKY.Net.IPHostEx.Localhost_string">
            <remarks>Explicitly using the more common spelling "[localhost]" instead of "[Localhost]".</remarks>
        </member>
        <member name="F:MKY.Net.IPHostEx.Default">
            <summary>Default is <see cref="F:MKY.Net.IPHost.Localhost"/>.</summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.#ctor">
            <summary>Default is <see cref="F:MKY.Net.IPHostEx.Default"/>.</summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.#ctor(MKY.Net.IPHost)">
            <remarks>
            Do not use with <see cref="F:MKY.Net.IPHost.Explicit"/> because that selection requires
            an IP address or host name. Use <see cref="M:MKY.Net.IPHostEx.#ctor(System.Net.IPAddress)"/> or
            or <see cref="M:MKY.Net.IPHostEx.#ctor(System.String,System.Net.IPAddress)"/> instead.
            </remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="host"/> is <see cref="F:MKY.Net.IPHost.Explicit"/>. Use <see cref="M:MKY.Net.IPHostEx.#ctor(System.Net.IPAddress)"/> instead.
            </exception>
        </member>
        <member name="M:MKY.Net.IPHostEx.#ctor(System.Net.IPAddress)">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.#ctor(System.String,System.Net.IPAddress)">
            <summary>
            Creates an explicit <see cref="T:MKY.Net.IPHostEx"/> object, using the provided host name and optional address.
            </summary>
        </member>
        <member name="P:MKY.Net.IPHostEx.Name">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPHostEx.Address">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPHostEx.IsLocalhost">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPHostEx.IsBroadcast">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPHostEx.IsExplicit">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.ToCompactString">
            <summary>
            Returns a compact string representation:
            - For predefined hosts, the predefined string is returned.
            - For explicit hosts, the host name or address is returned.
            </summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.ToEndpointAddressString">
             <summary>
             Returns a <see cref="T:System.String" /> that e.g. adds [] for IPv6 addresses.
             </summary>
             <remarks>
             It is recommended to use this function instead of <see cref="M:MKY.Net.IPHostEx.ToString"/> in cases where
             the IPv6 address is immediately followed the port number, separated by a colon.
             Compare readability:
             "1:2:3:4:5:6:7:8:8080"
             "[1:2:3:4:5:6:7:8]:8080"
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.Net.IPHostEx.ToEndpointAddressString(System.Net.IPAddress)">
             <summary>
             Returns a <see cref="T:System.String" /> that e.g. adds [] for IPv6 addresses.
             </summary>
             <remarks>
             It is recommended to use this function instead of <see cref="M:MKY.Net.IPHostEx.ToString"/> in cases where
             the IPv6 address is immediately followed the port number, separated by a colon.
             Compare readability:
             "1:2:3:4:5:6:7:8:8080"
             "[1:2:3:4:5:6:7:8]:8080"
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.Net.IPHostEx.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.Equals(MKY.Net.IPHostEx)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.op_Equality(MKY.Net.IPHostEx,MKY.Net.IPHostEx)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.op_Inequality(MKY.Net.IPHostEx,MKY.Net.IPHostEx)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.GetItems(System.Boolean)">
            <remarks>
            The list of items of this extended enum, depending on whether broadcast shall be included or not.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPHostEx.HasItem(MKY.Net.IPHostEx)">
            <summary>
            Determines whether the enumeration covers the specified item.
            </summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPHostEx.TryParse(System.String,MKY.Net.IPHostEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPHostEx.TryParse(System.String,MKY.Net.IPHost@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPHostEx.TryParseAndResolve(System.String,MKY.Net.IPHostEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPHostEx.TryResolve(System.String,System.Net.IPAddress@)">
            <summary>
            Tries to resolve an IP address from DNS.
            </summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.TryResolve">
            <summary>
            Tries to resolve an IP address from DNS.
            </summary>
        </member>
        <member name="P:MKY.Net.IPHostEx.HasBeenResolved">
            <summary>
            Returns whether IP has been resolved from DNS.
            </summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.op_Implicit(MKY.Net.IPHostEx)~MKY.Net.IPHost">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.op_Explicit(MKY.Net.IPHost)~MKY.Net.IPHostEx">
            <remarks>
            Explicit because cast doesn't work for <see cref="F:MKY.Net.IPHost.Explicit"/>.
            </remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="host"/> is <see cref="F:MKY.Net.IPHost.Explicit"/>.
            </exception>
        </member>
        <member name="M:MKY.Net.IPHostEx.op_Implicit(MKY.Net.IPHostEx)~System.Net.IPAddress">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.op_Implicit(System.Net.IPAddress)~MKY.Net.IPHostEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.op_Implicit(MKY.Net.IPHostEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPHostEx.op_Implicit(System.String)~MKY.Net.IPHostEx">
            <summary></summary>
        </member>
        <member name="T:MKY.Net.IPNetworkInterface">
            <summary></summary>
        </member>
        <member name="T:MKY.Net.IPNetworkInterfaceEx">
            <summary>
            Extended enum IPNetworkInterfaceEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:MKY.Net.IPNetworkInterfaceEx.Any_string">
            <remarks>Explicitly using "[any]" instead of "[Any]" same as "[localhost]" and "[loopback]".</remarks>
        </member>
        <member name="F:MKY.Net.IPNetworkInterfaceEx.Loopback_string">
            <remarks>Explicitly using the more common spelling "[loopback]" instead of "[Loopback]".</remarks>
        </member>
        <member name="F:MKY.Net.IPNetworkInterfaceEx.Default">
            <summary>Default is <see cref="F:MKY.Net.IPNetworkInterface.Any"/>.</summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.#ctor">
            <summary>Default is <see cref="F:MKY.Net.IPNetworkInterfaceEx.Default"/>.</summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.#ctor(MKY.Net.IPNetworkInterface)">
            <remarks>
            Do not use with <see cref="F:MKY.Net.IPNetworkInterface.Explicit"/> because that selection
            requires an IP address or interface description.
            Use <see cref="M:MKY.Net.IPNetworkInterfaceEx.#ctor(System.Net.IPAddress,System.String)"/> instead.
            </remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="networkInterface"/> is <see cref="F:MKY.Net.IPNetworkInterface.Explicit"/>. Use <see cref="M:MKY.Net.IPNetworkInterfaceEx.#ctor(System.Net.IPAddress,System.String)"/> instead.
            </exception>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.#ctor(System.Net.IPAddress,System.String)">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPNetworkInterfaceEx.Address">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPNetworkInterfaceEx.Description">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPNetworkInterfaceEx.IsAny">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPNetworkInterfaceEx.IsLocalhost">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPNetworkInterfaceEx.IsExplicit">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.ToDescriptorPair">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.RetrieveIPv4Mask">
            <remarks>
            Named 'Retrieve' rather than 'Get' to emphasize an time consuming operation
            (i.e. <see cref="M:System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces"/> is invoked underneath.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.RetrieveIPv4Mask(MKY.Net.IPNetworkInterfaceEx)">
            <remarks>
            Named 'Retrieve' rather than 'Get' to emphasize an time consuming operation
            (i.e. <see cref="M:System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces"/> is invoked underneath.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.RetrieveIPv4Mask(System.Net.IPAddress)">
            <remarks>
            Named 'Retrieve' rather than 'Get' to emphasize an time consuming operation
            (i.e. <see cref="M:System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces"/> is invoked underneath.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.RetrieveDirectedBroadcastAddress">
            <remarks>
            Named 'Retrieve' rather than 'Get' to emphasize an time consuming operation
            (i.e. <see cref="M:System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces"/> is invoked underneath.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.RetrieveDirectedBroadcastAddress(MKY.Net.IPNetworkInterfaceEx)">
            <remarks>
            Named 'Retrieve' rather than 'Get' to emphasize an time consuming operation
            (i.e. <see cref="M:System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces"/> is invoked underneath.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.RetrieveDirectedBroadcastAddress(System.Net.IPAddress)">
            <remarks>
            Named 'Retrieve' rather than 'Get' to emphasize an time consuming operation
            (i.e. <see cref="M:System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces"/> is invoked underneath.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.RetrieveDirectedAnyAddress">
            <remarks>
            Named 'Retrieve' rather than 'Get' to emphasize an time consuming operation
            (i.e. <see cref="M:System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces"/> is invoked underneath.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.RetrieveDirectedAnyAddress(MKY.Net.IPNetworkInterfaceEx)">
            <remarks>
            Named 'Retrieve' rather than 'Get' to emphasize an time consuming operation
            (i.e. <see cref="M:System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces"/> is invoked underneath.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.RetrieveDirectedAnyAddress(System.Net.IPAddress)">
            <remarks>
            Named 'Retrieve' rather than 'Get' to emphasize an time consuming operation
            (i.e. <see cref="M:System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces"/> is invoked underneath.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.Equals(MKY.Net.IPNetworkInterfaceEx)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.EqualsDescription(MKY.Net.IPNetworkInterfaceEx)">
            <summary>
            Determines whether this instance and the specified object have value equality,
            ignoring <see cref="P:MKY.Net.IPNetworkInterfaceEx.Address"/>.
            </summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.op_Equality(MKY.Net.IPNetworkInterfaceEx,MKY.Net.IPNetworkInterfaceEx)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.op_Inequality(MKY.Net.IPNetworkInterfaceEx,MKY.Net.IPNetworkInterfaceEx)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.TryParse(System.String,MKY.Net.IPNetworkInterfaceEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.TryParse(System.String,MKY.Net.IPNetworkInterface@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.op_Implicit(MKY.Net.IPNetworkInterfaceEx)~MKY.Net.IPNetworkInterface">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.op_Explicit(MKY.Net.IPNetworkInterface)~MKY.Net.IPNetworkInterfaceEx">
            <remarks>
            Explicit because cast doesn't work for <see cref="F:MKY.Net.IPNetworkInterface.Explicit"/>.
            </remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="networkInterface"/> is <see cref="F:MKY.Net.IPNetworkInterface.Explicit"/>.
            </exception>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.op_Implicit(MKY.Net.IPNetworkInterfaceEx)~MKY.Net.IPNetworkInterfaceDescriptorPair">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.op_Implicit(MKY.Net.IPNetworkInterfaceDescriptorPair)~MKY.Net.IPNetworkInterfaceEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.op_Implicit(MKY.Net.IPNetworkInterfaceEx)~System.Net.IPAddress">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.op_Implicit(System.Net.IPAddress)~MKY.Net.IPNetworkInterfaceEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.op_Implicit(MKY.Net.IPNetworkInterfaceEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceEx.op_Implicit(System.String)~MKY.Net.IPNetworkInterfaceEx">
            <summary></summary>
        </member>
        <member name="T:MKY.Net.IPNetworkInterfaceCollection">
            <summary>
            List containing IP network interfaces.
            </summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceCollection.#ctor">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceCollection.#ctor(System.Collections.Generic.IEnumerable{MKY.Net.IPNetworkInterfaceEx})">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceCollection.FillWithAvailableLocalInterfaces(System.Boolean)">
            <summary>
            Fills list with all interfaces.
            </summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceCollection.ContainsDescription(MKY.Net.IPNetworkInterfaceEx)">
            <summary>
            Determines whether an element is in the collection.
            </summary>
            <param name="item">
            The object to locate in the collection. The value can be null for reference types.
            </param>
            <returns>
            <c>true</c> if item is found in the collection; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceCollection.FindDescription(MKY.Net.IPNetworkInterfaceEx)">
            <summary>
            Searches for an element that matches the <paramref name="item"/>, and returns the
            first occurrence within the entire collection.
            </summary>
            <param name="item">
            The object to locate in the collection. The value can be null for reference types.
            </param>
            <returns>
            The first element that matches the <paramref name="item"/>, if found; otherwise, 1.
            </returns>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceCollection.FindIndexDescription(MKY.Net.IPNetworkInterfaceEx)">
            <summary>
            Searches for an element that matches the <paramref name="item"/>, and returns the
            zero-based index of the first occurrence within the collection.
            </summary>
            <param name="item">
            The object to locate in the collection. The value can be null for reference types.
            </param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            <paramref name="item"/>, if found; otherwise, 1.
            </returns>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceCollection.DebugVerboseIndent(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceCollection.DebugVerboseUnindent(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="T:MKY.Net.IPNetworkInterfaceDescriptorPair">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPNetworkInterfaceDescriptorPair.Description">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.IPNetworkInterfaceDescriptorPair.Address">
            <summary>Interval of reconnect in milliseconds.</summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceDescriptorPair.#ctor(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceDescriptorPair.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceDescriptorPair.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceDescriptorPair.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceDescriptorPair.Equals(MKY.Net.IPNetworkInterfaceDescriptorPair)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceDescriptorPair.op_Equality(MKY.Net.IPNetworkInterfaceDescriptorPair,MKY.Net.IPNetworkInterfaceDescriptorPair)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Net.IPNetworkInterfaceDescriptorPair.op_Inequality(MKY.Net.IPNetworkInterfaceDescriptorPair,MKY.Net.IPNetworkInterfaceDescriptorPair)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.Net.EqualsDescription">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.EqualsDescription.NetworkInterface">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.EqualsDescription.#ctor(MKY.Net.IPNetworkInterfaceEx)">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.EqualsDescription.Match">
            <summary></summary>
        </member>
        <member name="T:MKY.Net.Local">
            <summary>
            Local utility methods.
            </summary>
        </member>
        <member name="F:MKY.Net.Local.FindAvailableTcpPortAttempts">
            <summary></summary>
        </member>
        <member name="P:MKY.Net.Local.FindAvailableTcpPortAttemptsErrorMessage">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.Local.FindAvailableTcpPort">
            <summary>
            Finds an available TCP port chosen by the system or the system's TCP stack.
            </summary>
        </member>
        <member name="M:MKY.Net.Local.TryFindAvailableTcpPort(System.Int32@)">
            <summary>
            Finds an available TCP port chosen by the system or the system's TCP stack.
            </summary>
        </member>
        <member name="T:MKY.Net.RecentIPFilterCollection">
            <summary>
            Collection for recent items like recent files, provides methods to handle the recent items.
            </summary>
        </member>
        <member name="M:MKY.Net.RecentIPFilterCollection.#ctor">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.RecentIPFilterCollection.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.RecentIPFilterCollection.#ctor(System.Collections.Generic.IEnumerable{MKY.Collections.Specialized.RecentItem{System.String}})">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.RecentIPFilterCollection.RemoveMostRecent">
            <summary>
            Remove the most recent item if the collection already contains <see cref="T:RecentItemCollection`1.Capacity" /> items.
            </summary>
            <returns>
            <c>true</c> if an item is successfully removed; otherwise, <c>false</c>.
            <c>false</c> is also returned if no item was not found in the collection.
            </returns>
        </member>
        <member name="T:MKY.Net.RecentIPHostCollection">
            <summary>
            Collection for recent items like recent files, provides methods to handle the recent items.
            </summary>
        </member>
        <member name="M:MKY.Net.RecentIPHostCollection.#ctor">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.RecentIPHostCollection.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.RecentIPHostCollection.#ctor(System.Collections.Generic.IEnumerable{MKY.Collections.Specialized.RecentItem{System.String}})">
            <summary></summary>
        </member>
        <member name="M:MKY.Net.RecentIPHostCollection.RemoveMostRecent">
            <summary>
            Remove the most recent item if the collection already contains <see cref="T:RecentItemCollection`1.Capacity" /> items.
            </summary>
            <returns>
            <c>true</c> if an item is successfully removed; otherwise, <c>false</c>.
            <c>false</c> is also returned if no item was not found in the collection.
            </returns>
        </member>
        <member name="T:MKY.Net.Sockets.SocketEx">
            <summary>Hard coded default values.</summary>
        </member>
        <member name="F:MKY.Net.Sockets.SocketEx.SendBufferSizeDefault">
            <remarks>
            The hard-coded default value of <see cref="P:System.Net.Sockets.Socket.SendBufferSize"/>.
            </remarks>
            <remarks>
            Value cannot be retrieved from <see cref="T:System.Net.Sockets.Socket"/>.
            Value is hard-coded, there is no need to create an object and retrieve the value.
            </remarks>
        </member>
        <member name="F:MKY.Net.Sockets.SocketEx.ReceiveBufferSizeDefault">
            <remarks>
            The hard-coded default value of <see cref="P:System.Net.Sockets.Socket.ReceiveBufferSize"/>.
            </remarks>
        </member>
        <member name="T:MKY.RandomEx">
            <summary>
            Random utility methods.
            </summary>
        </member>
        <member name="P:MKY.RandomEx.GlobalObject">
            <summary>
            Gets the global <see cref="T:System.Random"/> object that can be used without having to create a
            local <see cref="T:System.Random"/> object.
            </summary>
            <remarks>
            This approach also solves the issue described in <see cref="M:MKY.RandomEx.NextRandomSeed"/>.
            </remarks>
        </member>
        <member name="M:MKY.RandomEx.NextRandomSeed">
            <summary>
            This method solves an issue described in the MSDN description of <see cref="T:System.Random"/>:
            The default seed value is derived from the system clock and has finite resolution. As a
            result, different <see cref="T:System.Random"/> objects that are created in close succession by a
            call to the default constructor will have identical default seed values and, therefore,
            will produce identical sets of random numbers. This problem can be avoided by using a
            single <see cref="T:System.Random"/> object to generate the seed for all random generators.
            </summary>
        </member>
        <member name="T:MKY.Reflection.InvocationHelper">
            <summary>
            Invocation utility methods.
            </summary>
        </member>
        <member name="T:MKY.Reflection.InvocationHelper.StaticPropertyAttribute">
            <summary>
            Attribute to select a static property of a generic type, i.e. kind of a static interface.
            </summary>
        </member>
        <member name="P:MKY.Reflection.InvocationHelper.StaticPropertyAttribute.PropertyName">
            <summary></summary>
        </member>
        <member name="P:MKY.Reflection.InvocationHelper.StaticPropertyAttribute.PropertyType">
            <summary></summary>
        </member>
        <member name="M:MKY.Reflection.InvocationHelper.StaticPropertyAttribute.#ctor(System.String,System.Type)">
            <summary></summary>
        </member>
        <member name="M:MKY.Reflection.InvocationHelper.InvokeStaticPropertyFromAttribute``1(System.Type)">
            <summary>
            Invokes the given static property.
            </summary>
            <typeparam name="TReturn">The return type of the method to invoke.</typeparam>
        </member>
        <member name="T:MKY.Runtime.CompilerServices.CallerEx">
            <summary>
            Helper to use <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>, <see cref="T:System.Runtime.CompilerServices.CallerFilePathAttribute"/>
            and <see cref="T:System.Runtime.CompilerServices.CallerLineNumberAttribute"/> from within a method.
            </summary>
        </member>
        <member name="M:MKY.Runtime.CompilerServices.CallerEx.GetCallerMemberName(System.String)">
            <summary>
            Convenience method that allows retrieving caller information by a caller itself.
            </summary>
            <remarks>
            Based on <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>.
            <para>
            Considering performance as described at
            https://stackoverflow.com/questions/1348643/how-performant-is-stackframe
            and
            https://stackoverflow.com/questions/16101152/is-performance-hit-by-using-caller-information-attributes
            calling this method is preferred over using reflection.
            <para></para>
            Considering maintenance and error-proneness, calling this method is preferred over using
            the <code>nameof()</code> operator, as that operator requires to provide the very method
            name, whereas with this method the method does not need any identifier.
            </para></remarks>
        </member>
        <member name="M:MKY.Runtime.CompilerServices.CallerEx.GetCallerFilePath(System.String)">
            <summary>
            Convenience method that allows retrieving caller information by a caller itself.
            </summary>
            <remarks>
            Based on <see cref="T:System.Runtime.CompilerServices.CallerFilePathAttribute"/>.
            </remarks>
        </member>
        <member name="M:MKY.Runtime.CompilerServices.CallerEx.GetCallerLineNumber(System.Int32)">
            <summary>
            Convenience method that allows retrieving caller information by a caller itself.
            </summary>
            <remarks>
            Based on <see cref="T:System.Runtime.CompilerServices.CallerLineNumberAttribute"/>.
            </remarks>
        </member>
        <member name="T:MKY.Runtime.InteropServices.IntPtrEx">
            <summary>
            Extends <see cref="T:System.IntPtr"/>.
            </summary>
        </member>
        <member name="F:MKY.Runtime.InteropServices.IntPtrEx.Invalid">
            <summary></summary>
        </member>
        <member name="T:MKY.Settings.ApplicationSettingsFileAccess">
            <summary>
            Options to control access to the applications settings file(s).
            </summary>
        </member>
        <member name="F:MKY.Settings.ApplicationSettingsFileAccess.None">
            <summary>Do no access the file at all, only use temporary settings.</summary>
            <remarks>Can be used to prevent concurrent instances to write the settings file(s).</remarks>
        </member>
        <member name="F:MKY.Settings.ApplicationSettingsFileAccess.ReadShared">
            <summary>Only read the settings.</summary>
            <remarks>Can be used to prevent concurrent instances to write the settings file(s).</remarks>
        </member>
        <member name="F:MKY.Settings.ApplicationSettingsFileAccess.ReadSharedWriteIfOwned">
            <summary>Default, read and write the settings.</summary>
        </member>
        <member name="T:MKY.Settings.ApplicationSettingsHandler`3">
            <summary>
            Generic class to handle standard application settings. It covers common, local user
            as well as roaming user settings.
            </summary>
            <typeparam name="TCommonSettings">The type of the common settings.</typeparam>
            <typeparam name="TLocalUserSettings">The type of the local user settings.</typeparam>
            <typeparam name="TRoamingUserSettings">The type of the roaming user settings.</typeparam>
            <remarks>
            Pass <see cref="T:MKY.Settings.EmptySettingsItem"/> for those settings that shall not be used.
            </remarks>
        </member>
        <member name="F:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.disposableState">
            <summary>
            A value which indicates the disposable state.
            <list type="bullet">
            <item><description>0 indicates undisposed.</description></item>
            <item><description>1 indicates disposal is ongoing or has completed.</description></item>
            </list>
            </summary>
            <remarks>
            <c>int</c> rather than <c>bool</c> is required for thread-safe operations.
            </remarks>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.#ctor(System.String,System.String,MKY.Settings.ApplicationSettingsFileAccess)">
            <param name="name">The name of the settings.</param>
            <param name="filePath">The file path to the settings file.</param>
            <param name="desiredFileAccess">The file access of the settings file.</param>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.IsUndisposed">
            <summary>
            Gets a value indicating whether disposal of object is neither ongoing nor has completed.
            </summary>
            <remarks>
            See remarks at <see cref="P:MKY.DisposableBase.IsUndisposed"/>.
            </remarks>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing or releasing resources.
            </summary>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.Dispose"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.AssertUndisposed">
            <summary>
            Asserts that disposal of object is neither ongoing nor has already completed.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.Settings">
            <summary>
            Handler to settings.
            </summary>
            <remarks>
            Public getter, protected setter.
            </remarks>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.AreCurrentlyOwnedByThisInstance">
            <summary>
            Returns whether settings are currently owned by the current instance,
            <c>false</c> if not.
            </summary>
            <remarks>
            This class uses a named mutex to prevent that concurrent instances of the application
            (i.e. if the application has been started multiple times in parallel) mess with the
            common settings.
            </remarks>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.Load">
            <summary>
            Tries to load settings from corresponding file path.
            </summary>
            <returns>
            Returns <c>true</c> if settings could be loaded from the given file path,
            returns <c>false</c> if they could not be loaded and were set to defaults instead.
            </returns>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.Save">
             <summary>
             Tries to save settings to corresponding file path.
             </summary>
             <remarks>
             Use of exception instead of boolean return value to ease handling of errors:
              - Exception will contain the reason for the failure
              - 'good-weather' case be easier implemented, kind of scripted
            
             Saying hello to StyleCop ;-.
             </remarks>
             <exception cref="T:System.Exception">
             Thrown if settings could not be saved.
             </exception>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.Close">
            <summary>
            Close the settings and release all resources.
            </summary>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.DebugMessage(System.String,System.Object[])">
            <remarks>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with the formatted message, and rather than e.g. "Common" for comprehensibility.
            </remarks>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Handler`1.DebugMessage(System.String)">
            <remarks>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with <paramref name="message"/>, and rather than e.g. "Common" for comprehensibility.
            </remarks>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.#ctor(MKY.Settings.ApplicationSettingsFileAccess,MKY.Settings.ApplicationSettingsFileAccess,MKY.Settings.ApplicationSettingsFileAccess)">
            <summary>
            Handles common and user settings. Common settings are stored in
            <see cref="P:System.Windows.Forms.Application.CommonAppDataPath"/>, local user settings in
            <see cref="P:System.Windows.Forms.Application.LocalUserAppDataPath"/>, user settings in
            <see cref="P:System.Windows.Forms.Application.UserAppDataPath"/>.
            </summary>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:MKY.Settings.ApplicationSettingsHandler`3.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.HasCommonSettings">
            <summary>
            Returns whether this handler has common settings.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.HasLocalUserSettings">
            <summary>
            Returns whether this handler has local user settings.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.HasRoamingUserSettings">
            <summary>
            Returns whether this handler has user settings.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.CommonSettingsDefault">
            <summary>
            Handler to common settings, if has common settings,
            <c>null</c> otherwise.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.LocalUserSettingsDefault">
            <summary>
            Handler to local user settings defaults, if has local user settings,
            <c>null</c> otherwise.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.RoamingUserSettingsDefault">
            <summary>
            Handler to user settings defaults, if has user settings,
            <c>null</c> otherwise.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.CommonSettingsFilePath">
            <summary>
            Absolute path to common settings file, if has common settings,
            <see cref="F:System.String.Empty"/> otherwise.
            </summary>
            <exception cref="T:System.NullReferenceException">
            Thrown if attempted to set file if this handler has no common settings.
            </exception>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.LocalUserSettingsFilePath">
            <summary>
            Absolute path to local user settings file, if has local user settings,
            <see cref="F:System.String.Empty"/> otherwise.
            </summary>
            <exception cref="T:System.NullReferenceException">
            Thrown if attempted to set file if this handler has no local user settings.
            </exception>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.RoamingUserSettingsFilePath">
            <summary>
            Absolute path to roaming user settings file, if has roaming user settings,
            <see cref="F:System.String.Empty"/> otherwise.
            </summary>
            <exception cref="T:System.NullReferenceException">
            Thrown if attempted to set file if this handler has no roaming user settings.
            </exception>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.CommonSettings">
            <summary>
            Handler to common settings, if has common settings, <c>null</c> otherwise.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.LocalUserSettings">
            <summary>
            Handler to local user settings, if has local user settings, <c>null</c> otherwise.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.RoamingUserSettings">
            <summary>
            Handler to roaming user settings, if has roaming user settings, <c>null</c> otherwise.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.CommonSettingsSuccessfullyLoadedFromFile">
            <summary>
            Returns whether common settings have successfully been loaded, <c>false</c> if
            there was no valid settings file and they were set to their defaults.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.LocalUserSettingsSuccessfullyLoadedFromFile">
            <summary>
            Returns whether local user settings have successfully been loaded, <c>false</c> if
            there was no valid settings file and they were set to their defaults.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.RoamingUserSettingsSuccessfullyLoadedFromFile">
            <summary>
            Returns whether roaming user settings have successfully been loaded, <c>false</c> if
            there was no valid settings file and they were set to their defaults.
            </summary>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.CommonSettingsAreCurrentlyOwnedByThisInstance">
            <summary>
            Returns whether common settings are currently owned by the current instance,
            <c>false</c> if not.
            </summary>
            <remarks>
            This class uses a named mutex to prevent that concurrent instances of the application
            (i.e. if the application has been started multiple times in parallel) mess with the
            common settings.
            </remarks>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.LocalUserSettingsAreCurrentlyOwnedByThisInstance">
            <summary>
            Returns whether local user settings are currently owned by the current instance,
            <c>false</c> if not.
            </summary>
            <remarks>
            This class uses a named mutex to prevent that concurrent instances of the application
            (i.e. if the application has been started multiple times in parallel) mess with the
            local user settings.
            </remarks>
        </member>
        <member name="P:MKY.Settings.ApplicationSettingsHandler`3.RoamingUserSettingsAreCurrentlyOwnedByThisInstance">
            <summary>
            Returns whether roaming user settings are currently owned by the current instance,
            <c>false</c> if not.
            </summary>
            <remarks>
            This class uses a named mutex to prevent that concurrent instances of the application
            (i.e. if the application has been started multiple times in parallel) mess with the
            roaming user settings.
            </remarks>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Load">
            <summary>
            Loads settings from <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.CommonSettingsFilePath"/>,
            <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.LocalUserSettingsFilePath"/> and <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.RoamingUserSettingsFilePath"/>
            or creates default settings if file not found or not readable.
            </summary>
            <returns>
            Returns false if either settings could not be loaded from its file path and have been
            set to defaults.
            </returns>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.LoadCommonSettings">
            <summary>
            Tries to load settings from <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.CommonSettingsFilePath"/>.
            </summary>
            <returns>
            Returns false if either settings could not be loaded from
            its file path and have been set to defaults.
            </returns>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.LoadLocalUserSettings">
            <summary>
            Tries to load settings from <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.LocalUserSettingsFilePath"/>.
            </summary>
            <returns>
            Returns false if either settings could not be loaded from
            its file path and have been set to defaults.
            </returns>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.LoadRoamingUserSettings">
            <summary>
            Tries to load settings from <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.RoamingUserSettingsFilePath"/>.
            </summary>
            <returns>
            Returns false if either settings could not be loaded from
            its file path and have been set to defaults.
            </returns>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Save">
             <summary>
             Tries to save settings to <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.CommonSettingsFilePath"/>,
             <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.LocalUserSettingsFilePath"/> and <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.RoamingUserSettingsFilePath"/>.
             </summary>
             <remarks>
             Use of exception instead of boolean return value to ease handling of errors:
              - Exception will contain the reason for the failure
              - 'good-weather' case be easier implemented, kind of scripted
            
             Saying hello to StyleCop ;-.
             </remarks>
             <exception cref="T:System.Exception">
             Thrown if settings could not be saved.
             </exception>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.SaveCommonSettings">
             <summary>
             Tries to save settings to <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.CommonSettingsFilePath"/>.
             </summary>
             <remarks>
             Use of exception instead of boolean return value to ease handling of errors:
              - Exception will contain the reason for the failure
              - 'good-weather' case be easier implemented, kind of scripted
            
             Saying hello to StyleCop ;-.
             </remarks>
             <exception cref="T:System.Exception">
             Thrown if settings could not be saved.
             </exception>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.SaveLocalUserSettings">
             <summary>
             Tries to save settings to <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.LocalUserSettingsFilePath"/>.
             </summary>
             <remarks>
             Use of exception instead of boolean return value to ease handling of errors:
              - Exception will contain the reason for the failure
              - 'good-weather' case be easier implemented, kind of scripted
            
             Saying hello to StyleCop ;-.
             </remarks>
             <exception cref="T:System.Exception">
             Thrown if settings could not be saved.
             </exception>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.SaveRoamingUserSettings">
             <summary>
             Tries to save settings to <see cref="P:MKY.Settings.ApplicationSettingsHandler`3.RoamingUserSettingsFilePath"/>.
             </summary>
             <remarks>
             Use of exception instead of boolean return value to ease handling of errors:
              - Exception will contain the reason for the failure
              - 'good-weather' case be easier implemented, kind of scripted
            
             Saying hello to StyleCop ;-.
             </remarks>
             <exception cref="T:System.Exception">
             Thrown if settings could not be saved.
             </exception>
        </member>
        <member name="M:MKY.Settings.ApplicationSettingsHandler`3.Close">
            <summary>
            Close the application settings.
            </summary>
        </member>
        <member name="T:MKY.Settings.DocumentSettingsHandler`1">
            <summary>
            Generic class to handle any kind of document settings, e.g. MDI application settings.
            </summary>
            <typeparam name="TSettings">The type of the settings.</typeparam>
        </member>
        <member name="M:MKY.Settings.DocumentSettingsHandler`1.#ctor">
            <summary>
            Handles document settings. Settings are stored in <see cref="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFilePath"/>.
            </summary>
        </member>
        <member name="M:MKY.Settings.DocumentSettingsHandler`1.#ctor(`0)">
            <summary>
            Handles document settings. Settings are stored in <see cref="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFilePath"/>.
            </summary>
        </member>
        <member name="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFilePath">
            <summary>
            Absolute path to the settings file.
            </summary>
        </member>
        <member name="M:MKY.Settings.DocumentSettingsHandler`1.ResetSettingsFilePath">
            <summary></summary>
        </member>
        <member name="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFilePathIsDefined">
            <summary>
            Returns whether the settings file path is defined.
            </summary>
        </member>
        <member name="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFilePathIsValid">
            <summary>
            Returns whether the settings file path is valid.
            </summary>
        </member>
        <member name="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFileExists">
            <summary>
            Returns whether the settings file exists.
            </summary>
        </member>
        <member name="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFileExistsNoMore">
            <summary>
            Returns whether the settings were loaded from a file but that doesn't exist anymore.
            </summary>
        </member>
        <member name="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFileIsUpToDate">
            <summary>
            Returns whether the settings file is up to date.
            </summary>
        </member>
        <member name="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFileIsReadable">
            <summary>
            Returns whether the settings file is readable.
            </summary>
        </member>
        <member name="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFileIsReadOnly">
            <summary>
            Returns whether the settings file is read-only.
            </summary>
        </member>
        <member name="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFileIsWritable">
            <summary>
            Returns whether the settings file is writable.
            </summary>
        </member>
        <member name="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFileSuccessfullyLoaded">
            <summary>
            Returns whether the settings file has successfully been loaded, <c>false</c> if there was
            no valid settings file available.
            </summary>
        </member>
        <member name="P:MKY.Settings.DocumentSettingsHandler`1.Settings">
            <summary>
            Handler to settings.
            </summary>
            <remarks>
            Public getter, protected setter.
            </remarks>
        </member>
        <member name="M:MKY.Settings.DocumentSettingsHandler`1.Load">
            <summary>
            Loads settings from <see cref="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFilePath"/>
            or creates default settings if file path not found or not readable.
            </summary>
            <returns>
            Returns <c>true</c> if settings could be loaded from <see cref="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFilePath"/>,
            returns <c>false</c> if they could not be loaded and were set to defaults instead.
            </returns>
            <exception cref="T:System.Exception">
            Thrown if settings could not be created.
            </exception>
        </member>
        <member name="M:MKY.Settings.DocumentSettingsHandler`1.Save">
             <summary>
             Tries to save settings to <see cref="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFilePath"/>.
             </summary>
             <remarks>
             Use of exception instead of boolean return value to ease handling of errors:
              - Exception will contain the reason for the failure
              - 'good-weather' case be easier implemented, kind of scripted
            
             Saying hello to StyleCop ;-.
             </remarks>
             <exception cref="T:System.Exception">
             Thrown if settings could not be saved.
             </exception>
        </member>
        <member name="M:MKY.Settings.DocumentSettingsHandler`1.TryDelete">
            <summary>
            Tries to delete file <see cref="P:MKY.Settings.DocumentSettingsHandler`1.SettingsFilePath"/>.
            </summary>
            <returns>
            Returns <c>true</c> if settings file successfully deleted.
            </returns>
        </member>
        <member name="T:MKY.Settings.SettingsEventArgs">
            <summary></summary>
        </member>
        <member name="P:MKY.Settings.SettingsEventArgs.Source">
            <summary></summary>
        </member>
        <member name="P:MKY.Settings.SettingsEventArgs.Inner">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsEventArgs.#ctor(MKY.Settings.SettingsItem)">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsEventArgs.#ctor(MKY.Settings.SettingsItem,MKY.Settings.SettingsEventArgs)">
            <summary></summary>
        </member>
        <member name="T:MKY.Settings.SettingsFileHandler">
            <summary>
            Utility class to provide basic settings file handling methods.
            </summary>
        </member>
        <member name="M:MKY.Settings.SettingsFileHandler.#ctor">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsFileHandler.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="P:MKY.Settings.SettingsFileHandler.FilePath">
            <summary>
            Absolute path to settings file.
            </summary>
        </member>
        <member name="P:MKY.Settings.SettingsFileHandler.FilePathIsDefined">
            <summary>
            Determines whether the settings file path is defined.
            </summary>
        </member>
        <member name="P:MKY.Settings.SettingsFileHandler.FilePathIsValid">
            <summary>
            Determines whether the settings file path is valid.
            </summary>
        </member>
        <member name="P:MKY.Settings.SettingsFileHandler.FileExists">
            <summary>
            Determines whether the settings file exists.
            </summary>
        </member>
        <member name="P:MKY.Settings.SettingsFileHandler.FileExistsNoMore">
            <summary>
            Determines whether the settings were loaded from a file but that doesn't exist anymore.
            </summary>
        </member>
        <member name="P:MKY.Settings.SettingsFileHandler.FileIsUpToDate">
            <summary>
            Determines whether the settings file is up to date.
            </summary>
        </member>
        <member name="P:MKY.Settings.SettingsFileHandler.FileIsReadable">
            <summary>
            Determines whether the settings file is readable, i.e. exists and can be accessed.
            </summary>
        </member>
        <member name="P:MKY.Settings.SettingsFileHandler.FileIsReadOnly">
            <summary>
            Determines whether the settings file is read-only, i.e. exists and is read-only.
            </summary>
        </member>
        <member name="P:MKY.Settings.SettingsFileHandler.FileIsWritable">
            <summary>
            Determines whether the settings file path is writeable, i.e. is not read-only or the file doesn't exist yet.
            </summary>
        </member>
        <member name="P:MKY.Settings.SettingsFileHandler.FileSuccessfullyLoaded">
            <summary>
            Determines whether the settings file has successfully been loaded, <c>false</c> if there was
            no valid settings file available.
            </summary>
        </member>
        <member name="P:MKY.Settings.SettingsFileHandler.SaveIsFeasible">
            <summary>
            Determines whether settings are feasible to be saved to the settings file.
            </summary>
        </member>
        <member name="M:MKY.Settings.SettingsFileHandler.LoadFromFile``1">
            <typeparam name="T">The settings type.</typeparam>
            <exception cref="T:System.Exception">
            Thrown if settings could not be created.
            </exception>
        </member>
        <member name="M:MKY.Settings.SettingsFileHandler.LoadFromFile``1(System.Collections.Generic.IEnumerable{MKY.Xml.AlternateXmlElement})">
            <typeparam name="T">The settings type.</typeparam>
            <exception cref="T:System.Exception">
            Thrown if settings could not be created.
            </exception>
        </member>
        <member name="M:MKY.Settings.SettingsFileHandler.LoadFromFile``1(System.Collections.Generic.IEnumerable{MKY.Xml.AlternateXmlElement},System.String)">
            <summary>
            This method loads settings from a file. If the schema of the settings doesn't match,
            this method tries to load the settings using tolerant XML interpretation by making use
            of <see cref="T:MKY.Xml.Serialization.TolerantXmlSerializer"/> or <see cref="T:MKY.Xml.Serialization.AlternateTolerantXmlSerializer"/>.
            </summary>
            <typeparam name="T">The settings type.</typeparam>
            <exception cref="T:System.Exception">
            Thrown if settings could not be created.
            </exception>
        </member>
        <member name="M:MKY.Settings.SettingsFileHandler.SaveToFile``1(``0)">
            <typeparam name="T">The settings type.</typeparam>
            <exception cref="T:System.Exception">
            Thrown if settings could not be saved.
            </exception>
        </member>
        <member name="M:MKY.Settings.SettingsFileHandler.SaveToFile``1(``0,System.String)">
            <typeparam name="T">The settings type.</typeparam>
            <exception cref="T:System.Exception">
            Thrown if settings could not be saved.
            </exception>
        </member>
        <member name="M:MKY.Settings.SettingsFileHandler.TryDelete">
            <summary>
            Tries to delete file <see cref="P:MKY.Settings.SettingsFileHandler.FilePath"/>.
            </summary>
            <returns>
            Returns <c>true</c> if file successfully saved.
            </returns>
        </member>
        <member name="T:MKY.Settings.SettingsType">
            <summary></summary>
        </member>
        <member name="F:MKY.Settings.SettingsType.Explicit">
            <summary>
            Explicit (normal) user settings, user gets notified as soon as setting changes.
            </summary>
        </member>
        <member name="F:MKY.Settings.SettingsType.Implicit">
            <summary>
            Implicit (hidden) user settings, user doesn't get notified when setting changes.
            </summary>
        </member>
        <member name="T:MKY.Settings.SettingsItem">
             <remarks>
             Attention, there currently are two similar implementations of this class:
              > <see cref="T:MKY.Settings.SettingsItem"/>
              > <see cref="T:MKY.Data.DataItem"/>
             The YAT feature request #158 "Consider replacing 'Settings' by 'DataItem'" deals with
             this issue, it will therefore not be forgotten. Until this feature request is implemented,
             changes to this class also have to be applied to <see cref="T:MKY.Data.DataItem"/>.
            
             Note the additional YAT feature request #159 "Consider replacing SettingsItem/DataItem
             with attributes" and feature request #286 "Consider upgrade from XML serialization to
             .NET 3.0 DataContract serialization" to switch to that serialization, the preferred way
             to handle persistence since the .NET 3.0 framework version.
            
             Also note that this class intentionally doesn't implement <see cref="T:System.IDisposable"/>. That
             would unnecessarily complicate the handling of settings item, e.g. in a settings dialog,
             as code analysis requires that <see cref="T:System.IDisposable"/> are indeed disposed of.
            
             Finally note that the 'Serializable' attribute is required to allow reflection using e.g.
             <see cref="M:System.Runtime.Serialization.FormatterServices.GetSerializableMembers(System.Type)"/>.
             </remarks>
        </member>
        <member name="E:MKY.Settings.SettingsItem.Changed">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.#ctor">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.#ctor(MKY.Settings.SettingsItem)">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="P:MKY.Settings.SettingsItem.SettingsType">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.AttachOrReplaceOrDetachNode(MKY.Settings.SettingsItem,MKY.Settings.SettingsItem)">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.AttachNode(MKY.Settings.SettingsItem)">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.ReplaceNode(MKY.Settings.SettingsItem,MKY.Settings.SettingsItem)">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.DetachNode(MKY.Settings.SettingsItem)">
            <summary></summary>
        </member>
        <member name="P:MKY.Settings.SettingsItem.HaveChanged">
            <summary>
            This flag indicates that the item has changed. Either one of the values of the item
            itself, or any of the sub-items. Either explicit or implicit settings.
            </summary>
            <remarks>
            To clear this flag, <see cref="M:MKY.Settings.SettingsItem.ClearChanged"/> must be called. The flag is never cleared
            automatically.
            </remarks>
        </member>
        <member name="P:MKY.Settings.SettingsItem.ExplicitHaveChanged">
            <summary>
            This flag indicates that the item has changed. Either one of the values of the item
            itself, or any of the sub-items. This flag can be used to e.g. display an asterisk *
            indicating a change of data, settings,...
            </summary>
            <remarks>
            To clear this flag, <see cref="M:MKY.Settings.SettingsItem.ClearChanged"/> must be called. The flag is never cleared
            automatically.
            </remarks>
        </member>
        <member name="M:MKY.Settings.SettingsItem.SetChanged">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.SetMyChanged">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.ClearChanged">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.ClearMyChanged">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.SetDefaults">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.SetMyDefaults">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.SetNodeDefaults">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.Equals(MKY.Settings.SettingsItem)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.op_Equality(MKY.Settings.SettingsItem,MKY.Settings.SettingsItem)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.op_Inequality(MKY.Settings.SettingsItem,MKY.Settings.SettingsItem)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.OnChanged(MKY.Settings.SettingsEventArgs)">
            <summary></summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.SetChangeEventSuspendedCount(System.Int32)">
            <summary>
            Sets the change event suspended count.
            </summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.SuspendChangeEvent">
            <summary>
            Temporarily suspends the change event for the settings and all nodes of the settings tree.
            </summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.ResumeChangeEvent(System.Boolean)">
            <summary>
            Resumes change events.
            </summary>
        </member>
        <member name="M:MKY.Settings.SettingsItem.ForceChangeEvent">
            <summary>
            Forces a change event on the settings and all nodes of the settings tree.
            The event is raised even if the settings have not changed.
            </summary>
        </member>
        <member name="T:MKY.Settings.EmptySettingsItem">
            <summary></summary>
        </member>
        <member name="T:MKY.Text.RegularExpressions.CommonPatternsWithSubCaptures">
            <summary>
            Some common regex patters.
            </summary>
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatternsWithSubCaptures.DateWithSpacesAscending">
            <summary>
            Captures dates separated by spaces, e.g 01 01 2000, always including leading zeros.
            </summary>
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatternsWithSubCaptures.DateWithSpacesDescending">
            <summary>
            Captures dates separated by spaces, e.g 2000 01 01, always including leading zeros.
            </summary>                                     // Grouping only, no capturing.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatternsWithSubCaptures.DateWithHyphensDescending">
            <summary>
            Captures dates separated by spaces, e.g 2000-01-01, always including leading zeros.
            </summary>                                      // Grouping only, no capturing.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatternsWithSubCaptures.TimeWithSpaces">
            <summary>
            Captures times separated by spaces, e.g 12 00 00, always including leading zeros.
            </summary>
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatternsWithSubCaptures.TimeWithColons">
            <summary>
            Captures times separated by colons, e.g 12:00:00, always including leading zeros.
            </summary>
        </member>
        <member name="T:MKY.Text.RegularExpressions.MatchCollectionEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.MatchCollectionEx.UnfoldCapturesToStringArray(System.Text.RegularExpressions.MatchCollection)">
            <summary>
            Unfolds the captures of the given matches to a string array.
            </summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.MatchCollectionEx.UnfoldCapturesToTupleArray(System.Text.RegularExpressions.MatchCollection)">
            <summary>
            Unfolds the captures of the given matches to a tuple array.
            </summary>
        </member>
        <member name="T:MKY.Text.RegularExpressions.RegexEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.RegexEx.LikelyContainsAnyPattern(System.String)">
            <summary>
            Determines whether <paramref name="s"/> likely contains any regular expression typical pattern.
            </summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.RegexEx.LikelyContainsCharacterGroupPattern(System.String)">
            <summary>
            Determines whether <paramref name="s"/> likely contains a regular expression character group pattern.
            </summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.RegexEx.LikelyContainsBasicCharacterClassPattern(System.String)">
            <summary>
            Determines whether <paramref name="s"/> likely contains a basic regular expression character class.
            </summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.RegexEx.LikelyContainsUnicodeCharacterClassPattern(System.String)">
            <summary>
            Determines whether <paramref name="s"/> likely contains a regular expression Unicode character class pattern.
            </summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.RegexEx.LikelyContainsAnchorPattern(System.String)">
            <summary>
            Determines whether <paramref name="s"/> likely contains a regular expression anchor pattern.
            </summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.RegexEx.LikelyContainsOtherPattern(System.String)">
            <summary>
            Determines whether <paramref name="s"/> likely contains any other regular expression typical pattern.
            </summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.RegexEx.TryValidatePattern(System.String)">
            <summary>
            Validates the given regular expression pattern.
            </summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.RegexEx.TryValidatePattern(System.String,System.String@)">
            <summary>
            Validates the given regular expression pattern.
            </summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.RegexEx.TryValidatePattern(System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Validates the given regular expression pattern.
            </summary>
        </member>
        <member name="M:MKY.Text.RegularExpressions.RegexEx.TryValidatePattern(System.String,System.Text.RegularExpressions.RegexOptions,System.String@)">
            <summary>
            Validates the given regular expression pattern.
            </summary>
        </member>
        <member name="T:MKY.Text.RegularExpressions.CommonPatterns">
            <summary>
            Some common regex patters.
            </summary>
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.IntegralNumber">
            <summary>
            Captures integral numbers.
            </summary>
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.FloatingPointNormal">
            <summary>
            Captures numbers in normal floating point format.
            </summary>
            <remarks>
            Includes integral values as well as trailing dot representation, i.e. "123", "123." and ".123".
            </remarks>                                    // Grouping only, no capturing.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.FloatingPointScientific">
            <summary>
            Captures numbers in normal floating point format.
            </summary>
            <remarks>
            Includes integral values as well as trailing dot representation, i.e. "123e9", "123.e9" and ".123e9".
            </remarks>                                        // Grouping only, no capturing.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.FloatingPointAny">
            <summary>
            Captures numbers in normal floating point format.
            </summary>
            <remarks>
            Includes integral values as well as trailing dot representation, i.e. "123", "123." and ".123" as well as "123e9", "123.e9" and ".123e9".
            </remarks>                                 // Grouping only, no capturing.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.DateWithSpacesAscending">
            <summary>
            Captures dates separated by spaces, e.g 01 01 2000, always including leading zeros.
            </summary>                                   // Grouping only, no capturing.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.DateWithSpacesDescending">
            <summary>
            Captures dates separated by spaces, e.g 2000 01 01, always including leading zeros.
            </summary>                                    // Grouping only, no capturing.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.DateWithHyphensDescending">
            <summary>
            Captures dates separated by spaces, e.g 2000-01-01, always including leading zeros.
            </summary>                                     // Grouping only, no capturing.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.TimeWithSpaces">
            <summary>
            Captures times separated by spaces, e.g 12 00 00, always including leading zeros.
            </summary>                          // Grouping only, no capturing.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.TimeWithColons">
            <summary>
            Captures times separated by colons, e.g 12:00:00, always including leading zeros.
            </summary>                          // Grouping only, no capturing.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.QuotedString">
            <summary>
            Captures '"' quoted strings, allowing escaped '\"'.
            </summary>                                  // Grouping only, no capturing.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.PositiveLookaheadOutsideQuotes">
            <summary>
            Positive lookahead that only captures items outside quotes '"', allowing escaped '\"'.
            </summary>
            <remarks>
            Source: https://stackoverflow.com/questions/11502598/how-to-match-something-with-regex-that-is-not-between-two-special-characters.
            </remarks>
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.MACAddress">
            <summary>
            MAC address in colon format, e.g. "01:23:45:67:89:AB".
            </summary>                      // Grouping only, no capturing. No capture groups necessary anyway, string converted 'ToUpper()' can be parsed by 'System.Net.NetworkInformation.PhysicalAddress.[Try]Parse()'.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.IPv4Address">
            <summary>
            IPv4 address in dot format, e.g. "127.0.0.0".
            </summary>                       // Grouping only, no capturing. No capture groups necessary anyway, string can be parsed by 'System.Net.IPAddress.[Try]Parse()'.
        </member>
        <member name="F:MKY.Text.RegularExpressions.CommonPatterns.IPv4Netmask">
            <summary>
            IPv4 netmask in dot format, e.g. "255.255.255.0".
            </summary>                       // Grouping only, no capturing. No capture groups necessary anyway, string can be parsed by 'System.Net.IPAddress.[Try]Parse()'.
        </member>
        <member name="T:MKY.Text.Ascii">
            <summary>
            ASCII code conversions. Source: http://www.asciitable.com.
            </summary>
        </member>
        <member name="F:MKY.Text.Ascii.MnemonicMinLength">
            <summary>
            The length of the shortest mnemonic is 2, e.g. "BS".
            </summary>
        </member>
        <member name="F:MKY.Text.Ascii.MnemonicMaxLength">
            <summary>
            The length of the longest mnemonic is 4, i.e. "XOFF".
            </summary>
        </member>
        <member name="M:MKY.Text.Ascii.IsControl(System.Byte)">
            <summary>
            Returns whether the given byte is a control byte.
            </summary>
        </member>
        <member name="M:MKY.Text.Ascii.ConvertToMnemonic(System.Byte)">
            <summary>
            Converts an ASCII code into according mnemonic.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if code out of range 0x00 to 0x1F, 0x7F.</exception>
        </member>
        <member name="M:MKY.Text.Ascii.ConvertToDescription(System.Byte)">
            <summary>
            Converts an ASCII code into according description.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if code out of range 0x00 to 0x1F, 0x7F.</exception>
        </member>
        <member name="M:MKY.Text.Ascii.Parse(System.String)">
            <summary>
            Converts an ASCII mnemonic into according code. Case-insensitive.
            </summary>
            <exception cref="T:System.FormatException">Thrown if mnemonic unknown.</exception>
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="mnemonic"/>.
            </remarks>
        </member>
        <member name="M:MKY.Text.Ascii.TryParse(System.String,System.Byte@)">
            <summary>
            Converts an ASCII mnemonic into according code. Case-insensitive.
            </summary>
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="mnemonic"/>.
            </remarks>
        </member>
        <member name="T:MKY.Text.SupportedEncoding">
            <summary>
            Encodings that are supported by .NET, currently 140 encodings.
            </summary>
            <remarks>
            Enum value corresponds to code page.
            </remarks>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ASCII">
            <summary>US-ASCII.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.UTF8">
            <summary>Unicode (UTF-8).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.UTF16">
            <summary>Unicode.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.UTF16BE">
            <summary>Unicode (Big-Endian).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.UTF32">
            <summary>Unicode (UTF-32).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.UTF32BE">
            <summary>Unicode (UTF-32 Big-Endian).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_1">
            <summary>Western European (ISO).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_2">
            <summary>Central European (ISO).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_3">
            <summary>Latin 3 (ISO).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_4">
            <summary>Baltic (ISO).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_5">
            <summary>Cyrillic (ISO).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_6">
            <summary>Arabic (ISO).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_7">
            <summary>Greek (ISO).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_8">
            <summary>Hebrew (ISO-Visual).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_8I">
            <summary>Hebrew (ISO-Logical).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_9">
            <summary>Turkish (ISO).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_13">
            <summary>Estonian (ISO).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO8859_15">
            <summary>Latin 9 (ISO).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO2022JP">
            <summary>Japanese (JIS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.CSISO2022JP">
            <summary>Japanese (JIS-Allow 1 byte Kana).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO2022JP_A">
            <summary>Japanese (JIS-Allow 1 byte Kana - SO/SI).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ISO2022KR">
            <summary>Korean (ISO).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Windows1252">
            <summary>Western European (Windows).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Windows1250">
            <summary>Central European (Windows).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Windows1251">
            <summary>Cyrillic (Windows).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Windows1253">
            <summary>Greek (Windows).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Windows1254">
            <summary>Turkish (Windows).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Windows1255">
            <summary>Hebrew (Windows).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Windows1256">
            <summary>Arabic (Windows).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Windows1257">
            <summary>Baltic (Windows).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Windows1258">
            <summary>Vietnamese (Windows).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Windows874">
            <summary>Thai (Windows).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Macintosh">
            <summary>Western European (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacCE">
            <summary>Central European (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacJapanese">
            <summary>Japanese (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacChineseTrad">
            <summary>Chinese Traditional (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacChineseSimp">
            <summary>Chinese Simplified (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacKorean">
            <summary>Korean (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacArabic">
            <summary>Arabic (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacHebrew">
            <summary>Hebrew (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacGreek">
            <summary>Greek (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacCyrillic">
            <summary>Cyrillic (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacRomanian">
            <summary>Romanian (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacUkrainian">
            <summary>Ukrainian (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacThai">
            <summary>Thai (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacIcelandic">
            <summary>Icelandic (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacTurkish">
            <summary>Turkish (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.XMacCroatian">
            <summary>Croatian (Mac).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.EUC_JP">
            <summary>Japanese (JIS 0208-1990 and 0212-1990).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.EUC_JP_A">
            <summary>Japanese (EUC).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.EUC_CN">
            <summary>Chinese Simplified (EUC).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.EUC_KR">
            <summary>Korean (EUC).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1047">
            <summary>IBM Latin-1.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM924">
            <summary>IBM Latin-1.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM500">
            <summary>IBM EBCDIC (International).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM037">
            <summary>IBM EBCDIC (US-Canada).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM870">
            <summary>IBM EBCDIC (Multilingual Latin-2).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM423">
            <summary>IBM EBCDIC (Greek).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.CP875">
            <summary>IBM EBCDIC (Greek Modern).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM880">
            <summary>IBM EBCDIC (Cyrillic Russian).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.CP1025">
            <summary>IBM EBCDIC (Cyrillic Serbian-Bulgarian).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM905">
            <summary>IBM EBCDIC (Turkish).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1026">
            <summary>IBM EBCDIC (Turkish Latin-5).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1140">
            <summary>IBM EBCDIC (US-Canada-Euro).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1141">
            <summary>IBM EBCDIC (Germany-Euro).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1142">
            <summary>IBM EBCDIC (Denmark-Norway-Euro).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1143">
            <summary>IBM EBCDIC (Finland-Sweden-Euro).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1144">
            <summary>IBM EBCDIC (Italy-Euro).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1145">
            <summary>IBM EBCDIC (Spain-Euro).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1146">
            <summary>IBM EBCDIC (UK-Euro).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1147">
            <summary>IBM EBCDIC (France-Euro).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1148">
            <summary>IBM EBCDIC (International-Euro).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM1149">
            <summary>IBM EBCDIC (Icelandic-Euro).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM273">
            <summary>IBM EBCDIC (Germany).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM277">
            <summary>IBM EBCDIC (Denmark-Norway).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM278">
            <summary>IBM EBCDIC (Finland-Sweden).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM871">
            <summary>IBM EBCDIC (Icelandic).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM280">
            <summary>IBM EBCDIC (Italy).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM284">
            <summary>IBM EBCDIC (Spain).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM285">
            <summary>IBM EBCDIC (UK).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM297">
            <summary>IBM EBCDIC (France).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM420">
            <summary>IBM EBCDIC (Arabic).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM424">
            <summary>IBM EBCDIC (Hebrew).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM290">
            <summary>IBM EBCDIC (Japanese katakana).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBMThai">
            <summary>IBM EBCDIC (Thai).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_EBCDIC_KoreanExtended">
            <summary>IBM EBCDIC (Korean Extended).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM437">
            <summary>OEM United States.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM855">
            <summary>OEM Cyrillic.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM858">
            <summary>OEM Multilingual Latin I.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM850">
            <summary>Western European (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM852">
            <summary>Central European (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM737">
            <summary>Greek (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM869">
            <summary>Greek, Modern (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM775">
            <summary>Baltic (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.CP866">
            <summary>Cyrillic (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM860">
            <summary>Portuguese (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM861">
            <summary>Icelandic (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM863">
            <summary>French Canadian (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM865">
            <summary>Nordic (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM857">
            <summary>Turkish (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.DOS720">
            <summary>Arabic (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.IBM864">
            <summary>Arabic (864).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.DOS862">
            <summary>Hebrew (DOS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.KOI8_R">
            <summary>Cyrillic (KOI8-R).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.KOI8_U">
            <summary>Cyrillic (KOI8-U).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.ASMO_708">
            <summary>Arabic (ASMO 708).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Shift_JIS">
            <summary>Japanese (Shift-JIS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.GB2312">
            <summary>Chinese Simplified (GB2312).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.GB18030">
            <summary>Chinese Simplified (GB18030).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.HZ_GB_2312">
            <summary>Chinese Simplified (HZ).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Big5">
            <summary>Chinese Traditional (Big5).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_CP20936">
            <summary>Chinese Simplified (GB2312-80).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_CP20949">
            <summary>Korean (Wansung).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.KS_C_5601_1987">
            <summary>Korean.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.Johab">
            <summary>Korean (Johab).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_Europa">
            <summary>Europa.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ChineseCNS">
            <summary>Chinese Traditional (CNS).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ChineseEten">
            <summary>Chinese Traditional (Eten).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_IA5">
            <summary>Western European (IA5).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_IA5_German">
            <summary>German (IA5).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_IA5_Swedish">
            <summary>Swedish (IA5).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_IA5_Norwegian">
            <summary>Norwegian (IA5).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_CP20001">
            <summary>TCA Taiwan.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_CP20003">
            <summary>IBM5550 Taiwan.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_CP20004">
            <summary>TeleText Taiwan.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_CP20005">
            <summary>Wang Taiwan.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_CP50227">
            <summary>Chinese Simplified (ISO-2022).</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_CP20261">
            <summary>T.61.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_CP20269">
            <summary>ISO-6937.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ISCII_DE">
            <summary>ISCII Devanagari.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ISCII_BE">
            <summary>ISCII Bengali.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ISCII_TA">
            <summary>ISCII Tamil.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ISCII_TE">
            <summary>ISCII Telugu.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ISCII_AS">
            <summary>ISCII Assamese.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ISCII_OR">
            <summary>ISCII Oriya.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ISCII_KA">
            <summary>ISCII Kannada.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ISCII_MA">
            <summary>ISCII Malayalam.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ISCII_GU">
            <summary>ISCII Gujarati.</summary>
        </member>
        <member name="F:MKY.Text.SupportedEncoding.X_ISCII_PA">
            <summary>ISCII Punjabi.</summary>
        </member>
        <member name="T:MKY.Text.EncodingEx">
            <summary>
            Extended enum EncodingEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:MKY.Text.EncodingEx.Default">
             <summary>
             Default is <see cref="F:MKY.Text.SupportedEncoding.UTF8"/> which corresponds to <see cref="P:System.Text.Encoding.UTF8"/>.
             </summary>
             <remarks>
             <see cref="P:System.Text.Encoding.Default"/>:
             "Because all <see cref="P:System.Text.Encoding.Default"/> encodings based on ANSI code pages lose data,
             consider using the <see cref="P:System.Text.Encoding.UTF8"/> encoding instead."
             and
             "On .NET Core, the 'Default' property always returns the 'UTF8Encoding'."
            
             Saying hello to StyleCop ;-.
             </remarks>
             <remarks>
             Must be implemented as const (instead of a readonly <see cref="P:MKY.Text.EncodingEx.Encoding"/>) as that
             is a mutable reference type. Defining a readonly would correctly result in FxCop
             message CA2104 "DoNotDeclareReadOnlyMutableReferenceTypes" (Microsoft.Security).
             </remarks>
        </member>
        <member name="M:MKY.Text.EncodingEx.#ctor">
            <summary>
            Default is <see cref="F:MKY.Text.EncodingEx.Default"/>.
            </summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.#ctor(MKY.Text.SupportedEncoding)">
            <summary></summary>
        </member>
        <member name="P:MKY.Text.EncodingEx.CodePage">
            <summary>
            Encoding code page.
            </summary>
        </member>
        <member name="P:MKY.Text.EncodingEx.Name">
            <summary>
            Unified encoding name.
            </summary>
        </member>
        <member name="P:MKY.Text.EncodingEx.DisplayName">
            <summary>
            Human readable encoding name.
            </summary>
        </member>
        <member name="P:MKY.Text.EncodingEx.Encoding">
            <summary>
            Returns encoding object.
            </summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.GetEncoding(MKY.Text.SupportedEncoding)">
            <summary>
            Returns the encoding object for the given encoding.
            </summary>
        </member>
        <member name="P:MKY.Text.EncodingEx.IsDefault">
            <summary>
            Returns whether this instance represents the default encoding.
            </summary>
        </member>
        <member name="P:MKY.Text.EncodingEx.IsSingleByte">
            <summary>
            Gets a value indicating whether the current encoding uses single-byte code points.
            </summary>
        </member>
        <member name="P:MKY.Text.EncodingEx.IsMultiByte">
            <summary>
            Gets a value indicating whether the current encoding uses multi-byte code points.
            </summary>
        </member>
        <member name="P:MKY.Text.EncodingEx.IsUnicode">
            <summary>
            Returns whether this instance represents one of the Unicode encodings (UTF/UCS).
            </summary>
            <remarks>
            UTF-7 is *not* a Unicode encoding.
            </remarks>
        </member>
        <member name="P:MKY.Text.EncodingEx.IsUnicodeBigEndian">
            <summary>
            Returns whether this instance represents one of the big-endian Unicode encodings (UTF16BE or UTF32BE).
            </summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.GetMinByteCount">
            <summary>
            Returns the minimum byte count of this instance.
            </summary>
            <remarks>
            Method instead of property for same signature as <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)"/>,
            though without 'charCount' parameter (method is limited to return count for a single character).
            </remarks>
        </member>
        <member name="P:MKY.Text.EncodingEx.UnicodeFragmentByteCount">
            <summary>
            Returns the fragment byte count if this instance represents one of the Unicode encodings.
            </summary>
            <remarks>
            Value equals <see cref="M:MKY.Text.EncodingEx.GetMinByteCount"/> for Unicode encodings.
            </remarks>
        </member>
        <member name="M:MKY.Text.EncodingEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation,
            which is "DisplayName [CodePage]".
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Text.EncodingEx.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.Equals(MKY.Text.EncodingEx)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.op_Equality(MKY.Text.EncodingEx,MKY.Text.EncodingEx)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.op_Inequality(MKY.Text.EncodingEx,MKY.Text.EncodingEx)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.GetItems">
            <summary>
            Returns all available encodings in a useful order.
            </summary>
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:MKY.Text.EncodingEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Text.EncodingEx.Parse(System.Text.Encoding)">
            <summary></summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.TryParse(System.String,MKY.Text.EncodingEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Text.EncodingEx.op_Implicit(MKY.Text.EncodingEx)~MKY.Text.SupportedEncoding">
            <summary></summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.op_Implicit(MKY.Text.SupportedEncoding)~MKY.Text.EncodingEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.op_Implicit(MKY.Text.EncodingEx)~System.Text.Encoding">
            <summary></summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.op_Implicit(System.Text.Encoding)~MKY.Text.EncodingEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.op_Implicit(MKY.Text.EncodingEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.op_Implicit(System.Int32)~MKY.Text.EncodingEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.op_Implicit(MKY.Text.EncodingEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:MKY.Text.EncodingEx.op_Implicit(System.String)~MKY.Text.EncodingEx">
            <summary></summary>
        </member>
        <member name="P:MKY.Text.EncodingEx.EnvironmentRecommendsByteOrderMarks">
            <summary>
            Returns <c>true</c> whether environment recommends to use a BOM or not.
            </summary>
            <remarks>
            <list type="bullet">
            <item><description>Windows recommends BOM.</description></item>
            <item><description>Unix, Linux,... does not recommend BOM.</description></item>
            <item><description>Other environments unknown, thus also not recommending BOM.</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:MKY.Text.EncodingEx.EnvironmentRecommendedUTF8Encoding">
            <summary>
            Returns the environment recommended UTF-8 encoding, i.e. with or without a BOM.
            </summary>
            <remarks>
            <list type="bullet">
            <item><description>Windows recommends BOM.</description></item>
            <item><description>Unix, Linux,... does not recommend BOM.</description></item>
            <item><description>Other environments unknown, thus also not recommending BOM.</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:MKY.Text.Escape">
            <summary>
            Escape code conversions.
            </summary>
        </member>
        <member name="M:MKY.Text.Escape.ConvertToEscapeSequence(System.Int32)">
            <summary>
            Converts a character code into according escape sequence.
            </summary>
        </member>
        <member name="M:MKY.Text.Escape.Parse(System.String)">
            <summary>
            Converts an escape sequence into according character code. Case-insensitive.
            </summary>
            <exception cref="T:System.FormatException">Thrown if escape sequence unknown.</exception>
            <remarks>
            Opposed to the convention of the .NET framework, whitespace is NOT
            trimmed from <paramref name="s"/> as all escapes are whitespaces.
            </remarks>
        </member>
        <member name="M:MKY.Text.Escape.TryParse(System.String,System.Byte@)">
            <summary>
            Converts an escape sequence into according character code. Case-insensitive.
            </summary>
            <remarks>
            Opposed to the convention of the .NET framework, whitespace is NOT
            trimmed from <paramref name="s"/> as all escapes are whitespaces.
            </remarks>
        </member>
        <member name="T:MKY.Threading.ThreadEx">
            <summary>
            <see cref="T:System.Threading.Thread"/> utility methods.
            </summary>
        </member>
        <member name="F:MKY.Threading.ThreadEx.SleepIntervalDefault">
            <summary>
            The sleep interval default. High enough to not load the system more than necessary.
            </summary>
        </member>
        <member name="M:MKY.Threading.ThreadEx.SleepUntilAt(System.DateTime,System.Int32)">
            <summary>
            Sleeps until <paramref name="at"/>.
            </summary>
            <remarks>
            Use a larger <paramref name="sleepInterval"/> when sleep time is long.
            Use a smaller <paramref name="sleepInterval"/> to increase accuracy.
            Use <c>0</c> for maximum accuracy though at highest system load.
            </remarks>
            <remarks>
            Explicitly named "At" to prevent ambiguity among
            <see cref="M:MKY.Threading.ThreadEx.SleepUntilAt(System.DateTime,System.Int32)"/> and
            <see cref="M:MKY.Threading.ThreadEx.SleepUntilOffset(System.DateTime,System.Int32,System.Int32)"/> with default argument.
            </remarks>
        </member>
        <member name="M:MKY.Threading.ThreadEx.SleepUntilOffset(System.DateTime,System.TimeSpan,System.Int32)">
            <summary>
            Sleeps until <paramref name="offset"/> relative to <paramref name="baseline"/>.
            </summary>
            <remarks>
            Use a larger <paramref name="sleepInterval"/> when sleep time is long.
            Use a smaller <paramref name="sleepInterval"/> to increase accuracy.
            Use <c>0</c> for maximum accuracy though at highest system load.
            </remarks>
            <remarks>
            Explicitly named "Offset" to prevent ambiguity among
            <see cref="M:MKY.Threading.ThreadEx.SleepUntilAt(System.DateTime,System.Int32)"/> and
            <see cref="M:MKY.Threading.ThreadEx.SleepUntilOffset(System.DateTime,System.Int32,System.Int32)"/> with default argument.
            </remarks>
        </member>
        <member name="M:MKY.Threading.ThreadEx.SleepUntilOffset(System.DateTime,System.Int32,System.Int32)">
            <summary>
            Sleeps until <paramref name="offset"/> relative to <paramref name="baseline"/>.
            </summary>
            <remarks>
            Use a larger <paramref name="sleepInterval"/> when sleep time is long.
            Use a smaller <paramref name="sleepInterval"/> to increase accuracy.
            Use <c>0</c> for maximum accuracy though at highest system load.
            </remarks>
            <remarks>
            Explicitly named "Offset" to prevent ambiguity among
            <see cref="M:MKY.Threading.ThreadEx.SleepUntilAt(System.DateTime,System.Int32)"/> and
            <see cref="M:MKY.Threading.ThreadEx.SleepUntilOffset(System.DateTime,System.Int32,System.Int32)"/> with default argument.
            </remarks>
        </member>
        <member name="T:MKY.Threading.MainThreadHelper">
            <summary>
            Helper to deal with the applications main thread.
            </summary>
        </member>
        <member name="F:MKY.Threading.MainThreadHelper.InvalidThreadId">
            <summary>
            The value that identifies an invalid thread identifier.
            </summary>
        </member>
        <member name="P:MKY.Threading.MainThreadHelper.MainThreadId">
            <summary>
            Returns the main thread ID if <see cref="M:MKY.Threading.MainThreadHelper.SetCurrentThread"/> has been called before;
            otherwise, <see cref="F:MKY.Threading.MainThreadHelper.InvalidThreadId"/>.
            </summary>
        </member>
        <member name="M:MKY.Threading.MainThreadHelper.SetCurrentThread">
            <summary>
            Sets the current thread as the main thread.
            </summary>
        </member>
        <member name="P:MKY.Threading.MainThreadHelper.IsInitialized">
            <summary>
            Returns whether this helper has been fully initialized, i.e. the main thread has been
            set by calling <see cref="M:MKY.Threading.MainThreadHelper.SetCurrentThread"/>.
            </summary>
            <value>
            <c>true</c> if the helper has been fully initialized; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MKY.Threading.MainThreadHelper.IsMainThread">
            <summary>
            Returns whether the current thread is the main thread if <see cref="M:MKY.Threading.MainThreadHelper.SetCurrentThread"/>
            has been called before; otherwise, <c>false</c>.
            </summary>
            <value>
            <c>true</c> if the current thread is the main thread; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:MKY.Time.UserTimeStamp">
            <summary></summary>
        </member>
        <member name="P:MKY.Time.UserTimeStamp.TimeStamp">
            <summary></summary>
        </member>
        <member name="P:MKY.Time.UserTimeStamp.UserName">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.UserTimeStamp.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:UserTimeStamp`1"/> struct.
            </summary>
            <param name="userName">The user name.</param>
        </member>
        <member name="M:MKY.Time.UserTimeStamp.#ctor(System.DateTime,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:UserTimeStamp`1"/> struct.
            </summary>
            <param name="timeStamp">The time stamp.</param>
            <param name="userName">The user name.</param>
        </member>
        <member name="M:MKY.Time.UserTimeStamp.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Time.UserTimeStamp.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Time.UserTimeStamp.Equals(MKY.Time.UserTimeStamp)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Time.UserTimeStamp.op_Equality(MKY.Time.UserTimeStamp,MKY.Time.UserTimeStamp)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Time.UserTimeStamp.op_Inequality(MKY.Time.UserTimeStamp,MKY.Time.UserTimeStamp)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.Time.Chronometer">
            <summary></summary>
        </member>
        <member name="F:MKY.Time.Chronometer.eventHelper">
             <summary>
             A dedicated event helper to allow discarding exceptions when object got disposed.
             </summary>
             <remarks> \remind (2019-08-22 / MKY)
            
             Explicitly setting <see cref="F:MKY.EventHelper.ExceptionHandlingMode.DiscardDisposedTarget"/>
             to handle/workaround the following issue:
            
             <![CDATA[
             System.Reflection.TargetInvocationException was unhandled by user code
               Message=Ein Aufrufziel hat einen Ausnahmefehler verursacht.
               Source=mscorlib
               StackTrace:
                    bei System.RuntimeMethodHandle._InvokeMethodFast(Object target, Object[] arguments, SignatureStruct& sig, MethodAttributes methodAttributes, RuntimeTypeHandle typeOwner)
                    bei System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture, Boolean skipVisibilityChecks)
                    bei System.Delegate.DynamicInvokeImpl(Object[] args)
                    bei MKY.EventHelper.Item.InvokeOnCurrentThread(Delegate sink, Object[] args) in D:\Workspace\YAT\Trunk\MKY\MKY\EventHelper.cs:Zeile 595.
                    bei MKY.EventHelper.Item.RaiseSync[TEventArgs](Delegate eventDelegate, Object[] args) in D:\Workspace\YAT\Trunk\MKY\MKY\EventHelper.cs:Zeile 399.
                    bei MKY.Time.Chronometer.OnTimeSpanChanged(TimeSpanEventArgs e) in D:\Workspace\YAT\Trunk\MKY\MKY\Time\Chronometer.cs:Zeile 350.
                    bei MKY.Time.Chronometer.timer_Elapsed(Object sender, ElapsedEventArgs e) in D:\Workspace\YAT\Trunk\MKY\MKY\Time\Chronometer.cs:Zeile 330.
                    bei System.Timers.Timer.MyTimerCallback(Object state)
               InnerException:
                    Message=Invoke oder BeginInvoke kann fr ein Steuerelement erst aufgerufen werden, wenn das Fensterhandle erstellt wurde.
                    Source=System.Windows.Forms
                    StackTrace:
                         bei System.Windows.Forms.Control.WaitForWaitHandle(WaitHandle waitHandle)
                         bei System.Windows.Forms.Control.MarshaledInvoke(Control caller, Delegate method, Object[] args, Boolean synchronous)
                         bei System.Windows.Forms.Control.Invoke(Delegate method, Object[] args)
                         bei MKY.EventHelper.Item.InvokeSynchronized(ISynchronizeInvoke sinkTarget, Delegate sink, Object[] args) in D:\Workspace\YAT\Trunk\MKY\MKY\EventHelper.cs:Zeile 567.
                         bei MKY.EventHelper.Item.RaiseSync[TEventArgs](Delegate eventDelegate, Object[] args) in D:\Workspace\YAT\Trunk\MKY\MKY\EventHelper.cs:Zeile 397.
                         bei YAT.Model.Terminal.OnIOConnectTimeChanged(TimeSpanEventArgs e) in D:\Workspace\YAT\Trunk\YAT\YAT.Model\Terminal.cs:Zeile 5258.
                         bei YAT.Model.Terminal.totalConnectChrono_TimeSpanChanged(Object sender, TimeSpanEventArgs e) in D:\Workspace\YAT\Trunk\YAT\YAT.Model\Terminal.cs:Zeile 4204.
             ]]>
            
             The chronometers get properly disposed of, but apparently there may still be pending
             asynchronous 'zombie' callback that later throw an exception. No feasible solution
             has been found.
            
             Temporarily disabling this handling/workaround can be useful for debugging, i.e. to
             continue program execution even in case of exceptions and let the debugger handle it.
             </remarks>
        </member>
        <member name="E:MKY.Time.Chronometer.TimeSpanChanged">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Chronometer.#ctor">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Chronometer.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:MKY.Time.Chronometer.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="P:MKY.Time.Chronometer.Interval">
            <summary></summary>
        </member>
        <member name="P:MKY.Time.Chronometer.TimeSpan">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Chronometer.CalculateTimeSpan(System.DateTime)">
            <summary></summary>
        </member>
        <member name="P:MKY.Time.Chronometer.DiagnosticsName">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Chronometer.Start">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Chronometer.Start(System.DateTime)">
            <remarks>
            This overload is useful if multiple objects need to be synchronized in terms of time.
            </remarks>
        </member>
        <member name="M:MKY.Time.Chronometer.Stop">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Chronometer.StartStop">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Chronometer.Reset">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Chronometer.Reset(System.DateTime)">
            <remarks>
            This overload is useful if multiple objects need to be synchronized in terms of time.
            </remarks>
        </member>
        <member name="M:MKY.Time.Chronometer.Restart">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Chronometer.Restart(System.DateTime)">
            <remarks>
            This overload is useful if multiple objects need to be synchronized in terms of time.
            </remarks>
        </member>
        <member name="M:MKY.Time.Chronometer.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Time.Chronometer.OnTimeSpanChanged(MKY.TimeSpanEventArgs)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Chronometer.DebugMessage(System.String)">
            <remarks>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with <paramref name="message"/>, and rather than e.g. "Common" for comprehensibility.
            </remarks>
        </member>
        <member name="T:MKY.Time.Rate">
            <remarks>
            A weighted sum is used to calculate the <see cref="P:MKY.Time.Rate.Value"/> for better seeing changes.
            </remarks>
        </member>
        <member name="F:MKY.Time.Rate.IntervalDefault">
            <summary>
            The default value for <see cref="P:MKY.Time.Rate.Interval"/>.
            </summary>
        </member>
        <member name="F:MKY.Time.Rate.NumberOfBinsPerInterval">
            <summary>
            The number of bins per <see cref="P:MKY.Time.Rate.Interval"/> to calculate the value.
            </summary>
            <remarks>
            Required to allow odd interval-window-ratios. The value is yet fixed to 2.
            </remarks>
        </member>
        <member name="M:MKY.Time.Rate.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Time.Rate"/> class setting both
            <see cref="P:MKY.Time.Rate.Interval"/> and <see cref="P:MKY.Time.Rate.Window"/> to a second.
            </summary>
        </member>
        <member name="M:MKY.Time.Rate.#ctor(System.Double)">
            <param name="interval">The interval to calculate the value of the rate.</param>
            <remarks><see cref="P:MKY.Time.Rate.Window"/> will be set to <paramref name="interval"/>.</remarks>
        </member>
        <member name="M:MKY.Time.Rate.#ctor(System.Double,System.Double)">
            <param name="interval">The interval to calculate the value of the rate.</param>
            <param name="window"><see cref="P:MKY.Time.Rate.Window" />.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if 'window' is less than 'interval'.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if 'window' is not a multiple of 'interval / NumberOfBinsPerInterval'.
            </exception>
        </member>
        <member name="P:MKY.Time.Rate.Interval">
            <summary>
            The interval to calculate the value of the rate, in milliseconds.
            </summary>
            <remarks>Set to 1 to get <see cref="P:MKY.Time.Rate.Value"/> in items per millisecond.</remarks>
            <remarks>Set to 1000 to get <see cref="P:MKY.Time.Rate.Value"/> in items per second.</remarks>
            <remarks>Set to 60000 to get <see cref="P:MKY.Time.Rate.Value"/> in items per minute.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if 'Interval' is greater than 'Window'.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if 'Window' would no longer be a multiple of 'Interval / NumberOfBinsPerInterval'.
            </exception>
        </member>
        <member name="P:MKY.Time.Rate.Window">
            <summary>
            The window to calculate the rate, in milliseconds.
            </summary>
            <remarks>
            If window is larger than <see cref="P:MKY.Time.Rate.Interval"/>, a value is calculated for each interval
            and the values are weighted. The value of the less recent interval is weighed most, more
            recent intervals are weighted less.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if 'Window' is less than 'Interval'.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if 'Window' is not a multiple of 'Interval / NumberOfBinsPerInterval'.
            </exception>
        </member>
        <member name="P:MKY.Time.Rate.Value">
            <summary>
            The resulting rate value, in items per interval.
            </summary>
            <remarks>
            Using <c>int</c> rather than <c>double</c> for three reasons:
            <list type="bullet">
            <item><description>Indication whether value has changed on update is straight-forward with an <c>int</c>.</description></item>
            <item><description>Client can set the interval such it fits its needs.</description></item>
            <item><description>Client does not need to round the value.</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:MKY.Time.Rate.LastItemTimeStamp">
            <summary>
            The time stamp of the last update.
            </summary>
        </member>
        <member name="P:MKY.Time.Rate.LastItemWasWithinCurrentInterval">
            <summary></summary>
        </member>
        <member name="P:MKY.Time.Rate.NumberOfIntervalsSinceLastItem">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Rate.Update(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Rate.Update(System.Int32,System.Int32@)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Rate.Update(System.DateTime,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Rate.Update(System.DateTime,System.Int32,System.Int32@)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Rate.Update">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Rate.Update(System.Int32@)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Rate.Update(System.DateTime)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Rate.Update(System.DateTime,System.Int32@)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Rate.Reset">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.Rate.DebugUpdate(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="T:MKY.Time.RateEventArgs">
            <summary></summary>
        </member>
        <member name="P:MKY.Time.RateEventArgs.Rate">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.RateEventArgs.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="T:MKY.Time.RateProvider">
            <summary></summary>
        </member>
        <member name="F:MKY.Time.RateProvider.RateIntervalDefault">
            <summary>
            The default value for <see cref="P:MKY.Time.Rate.Interval"/>.
            </summary>
        </member>
        <member name="F:MKY.Time.RateProvider.UpdateIntervalDefault">
            <summary>
            The default value for <see cref="P:MKY.Time.RateProvider.UpdateInterval"/>.
            </summary>
        </member>
        <member name="F:MKY.Time.RateProvider.eventHelper">
             <summary>
             A dedicated event helper to allow discarding exceptions when object got disposed.
             </summary>
             <remarks> \remind (2019-08-22 / MKY)
            
             Explicitly setting <see cref="F:MKY.EventHelper.ExceptionHandlingMode.DiscardDisposedTarget"/>
             to handle/workaround a similar issue as described in <see cref="T:MKY.Time.Chronometer"/>.
            
             Temporarily disabling this handling/workaround can be useful for debugging, i.e. to
             continue program execution even in case of exceptions and let the debugger handle it.
             </remarks>
        </member>
        <member name="E:MKY.Time.RateProvider.Changed">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.RateProvider.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Time.Rate"/> class setting both
            <see cref="P:MKY.Time.Rate.Interval"/> and <see cref="P:MKY.Time.Rate.Window"/> to a second.
            </summary>
        </member>
        <member name="M:MKY.Time.RateProvider.#ctor(System.Double,System.Double)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if 'updateInterval' is greater than half the 'rateInterval'.
            </exception>
        </member>
        <member name="M:MKY.Time.RateProvider.#ctor(System.Double,System.Double,System.Double)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if 'rateWindow' is less than 'rateInterval'.
            Thrown if 'updateInterval' is greater than half the 'rateInterval'.
            </exception>
        </member>
        <member name="M:MKY.Time.RateProvider.#ctor(System.Double,System.Double,System.Double,System.String)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if 'rateWindow' is less than 'rateInterval'.
            Thrown if 'updateInterval' is greater than half the 'rateInterval'.
            </exception>
        </member>
        <member name="M:MKY.Time.RateProvider.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:MKY.Time.RateProvider.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="P:MKY.Time.RateProvider.UpdateInterval">
            <summary></summary>
        </member>
        <member name="P:MKY.Time.RateProvider.RateInterval">
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if 'Interval' is greater than 'Window'.
            </exception>
        </member>
        <member name="P:MKY.Time.RateProvider.RateWindow">
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if 'Window' is less than 'Interval'.
            </exception>
        </member>
        <member name="P:MKY.Time.RateProvider.RateValue">
            <summary></summary>
        </member>
        <member name="P:MKY.Time.RateProvider.DiagnosticsName">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.RateProvider.Start">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.RateProvider.Stop">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.RateProvider.StartStop">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.RateProvider.Update(System.Int32,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.RateProvider.Update(System.DateTime,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.RateProvider.Reset(System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.RateProvider.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Time.RateProvider.OnRateChanged(MKY.Time.RateEventArgs)">
            <summary></summary>
        </member>
        <member name="M:MKY.Time.RateProvider.DebugMessage(System.String)">
            <remarks>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with <paramref name="message"/>, and rather than e.g. "Common" for comprehensibility.
            </remarks>
        </member>
        <member name="T:MKY.Time.TimeStampItem`1">
            <summary>
            Value pair of a time stamp and an item.
            </summary>
            <typeparam name="T">The type of the time stamped item.</typeparam>
        </member>
        <member name="P:MKY.Time.TimeStampItem`1.TimeStamp">
            <summary>
            Gets or sets the time stamp.
            </summary>
            <value>The time stamp.</value>
        </member>
        <member name="P:MKY.Time.TimeStampItem`1.Item">
            <summary>
            Gets or sets the item.
            </summary>
            <value>The item.</value>
        </member>
        <member name="M:MKY.Time.TimeStampItem`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:TimeStampItem`1"/> struct.
            </summary>
            <param name="item">The second value.</param>
        </member>
        <member name="M:MKY.Time.TimeStampItem`1.#ctor(System.DateTime,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:TimeStampItem`1"/> struct.
            </summary>
            <param name="timeStamp">The time stamp.</param>
            <param name="item">The second value.</param>
        </member>
        <member name="M:MKY.Time.TimeStampItem`1.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Time.TimeStampItem`1.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Time.TimeStampItem`1.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Time.TimeStampItem`1.Equals(MKY.Time.TimeStampItem{`0})">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Time.TimeStampItem`1.op_Equality(MKY.Time.TimeStampItem{`0},MKY.Time.TimeStampItem{`0})">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Time.TimeStampItem`1.op_Inequality(MKY.Time.TimeStampItem{`0},MKY.Time.TimeStampItem{`0})">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.Time.TimeTickItem`1">
            <summary>
            Value pair of a time stamp and an item.
            </summary>
            <typeparam name="T">The type of the time stamped item.</typeparam>
        </member>
        <member name="P:MKY.Time.TimeTickItem`1.TimeTick">
            <summary>
            Gets or sets the time tick.
            </summary>
            <value>The time tick.</value>
        </member>
        <member name="P:MKY.Time.TimeTickItem`1.Item">
            <summary>
            Gets or sets the item.
            </summary>
            <value>The item.</value>
        </member>
        <member name="M:MKY.Time.TimeTickItem`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:TimeTickItem`1"/> struct.
            </summary>
            <param name="item">The second value.</param>
        </member>
        <member name="M:MKY.Time.TimeTickItem`1.#ctor(System.Int64,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:TimeTickItem`1"/> struct.
            </summary>
            <param name="timeTick">The time tick.</param>
            <param name="item">The second value.</param>
        </member>
        <member name="M:MKY.Time.TimeTickItem`1.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Time.TimeTickItem`1.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Time.TimeTickItem`1.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Time.TimeTickItem`1.Equals(MKY.Time.TimeTickItem{`0})">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Time.TimeTickItem`1.op_Equality(MKY.Time.TimeTickItem{`0},MKY.Time.TimeTickItem{`0})">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Time.TimeTickItem`1.op_Inequality(MKY.Time.TimeTickItem{`0},MKY.Time.TimeTickItem{`0})">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.DateTimeEventArgs">
            <summary></summary>
        </member>
        <member name="P:MKY.DateTimeEventArgs.DateTime">
            <summary></summary>
        </member>
        <member name="M:MKY.DateTimeEventArgs.#ctor(System.DateTime)">
            <summary></summary>
        </member>
        <member name="T:MKY.TimeSpanEx">
            <summary>
            <see cref="T:System.TimeSpan"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.TimeSpanEx.TicksToTime(System.Int64)">
            <summary>
            Converts the given number of ticks into the corresponding number of milliseconds,
            using <see cref="F:System.TimeSpan.TicksPerMillisecond"/>.
            </summary>
            <remarks>
            A similar method exists as <see cref="M:MKY.Diagnostics.StopwatchEx.TicksToTime(System.Int64)"/>.
            </remarks>
        </member>
        <member name="M:MKY.TimeSpanEx.TimeToTicks(System.Int32)">
            <summary>
            Converts the given number of milliseconds into the corresponding number of ticks,
            using <see cref="F:System.TimeSpan.TicksPerMillisecond"/>.
            </summary>
            <remarks>
            A similar method exists as <see cref="M:MKY.Diagnostics.StopwatchEx.TimeToTicks(System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:MKY.TimeSpanEx.FormatInvariantSeconds(System.TimeSpan)">
            <summary>
            Returns <paramref name="value"/> formatted as "[[[[[[d days ]h]h:]m]m:]s]s".
            </summary>
            <remarks>
            Is intended to be eliminated after having upgraded to .NET 4+, using its additional
            <see cref="T:System.TimeSpan"/> formatting capabilities instead.
            </remarks>
        </member>
        <member name="M:MKY.TimeSpanEx.FormatInvariantThousandths(System.TimeSpan)">
            <summary>
            Returns <paramref name="value"/> formatted as "[[[[[[d days ]h]h:]m]m:]s]s.fff".
            </summary>
            <remarks>
            Is intended to be eliminated after having upgraded to .NET 4+, using its additional
            <see cref="T:System.TimeSpan"/> formatting capabilities instead.
            </remarks>
        </member>
        <member name="M:MKY.TimeSpanEx.FormatInvariantSecondsEnforceMinutes(System.TimeSpan)">
            <summary>
            Returns <paramref name="value"/> formatted as "[[[[d days ]h]h:]m]m:ss".
            </summary>
            <remarks>
            Is intended to be eliminated after having upgraded to .NET 4+, using its additional
            <see cref="T:System.TimeSpan"/> formatting capabilities instead.
            </remarks>
        </member>
        <member name="M:MKY.TimeSpanEx.FormatInvariantThousandthsEnforceMinutes(System.TimeSpan)">
            <summary>
            Returns <paramref name="value"/> formatted as "[[[[d days ]h]h:]m]m:ss.fff".
            </summary>
            <remarks>
            Is intended to be eliminated after having upgraded to .NET 4+, using its additional
            <see cref="T:System.TimeSpan"/> formatting capabilities instead.
            </remarks>
        </member>
        <member name="M:MKY.TimeSpanEx.FormatInvariant(System.TimeSpan,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns <paramref name="value"/> formatted as "[[[[[[d days ]h]h:]m]m:]s]s[.f[f[f]]]".
            </summary>
            <remarks>
            Is intended to be eliminated after having upgraded to .NET 4+, using its additional
            <see cref="T:System.TimeSpan"/> formatting capabilities instead.
            </remarks>
        </member>
        <member name="M:MKY.TimeSpanEx.FormatInvariantThousandthsEnforceMinutes(System.TimeSpan,System.String)">
            <summary>
            Returns <paramref name="value"/> formatted as "[[[[d days ]h]h:]m]m:ss.fff"
            supporting additional formats "^d.ddd^", "^h.hhh^", "^mm.mmm^", "^sss.sss^", "^ffffff^".
            </summary>
            <remarks>
            Is intended to be eliminated after having upgraded to .NET 4+, using its additional
            <see cref="T:System.TimeSpan"/> formatting capabilities instead.
            </remarks>
        </member>
        <member name="M:MKY.TimeSpanEx.FormatInvariantThousandths(System.TimeSpan,System.String)">
            <summary>
            Returns <paramref name="value"/> formatted as "[[[[[[d days ]h]h:]m]m:]s]s.fff"
            supporting additional formats "^d.ddd^", "^h.hhh^", "^mm.mmm^", "^sss.sss^", "^ffffff^".
            </summary>
            <remarks>
            Is intended to be eliminated after having upgraded to .NET 4+, using its additional
            <see cref="T:System.TimeSpan"/> formatting capabilities instead.
            </remarks>
        </member>
        <member name="M:MKY.TimeSpanEx.TryFormatInvariantAdditional(System.TimeSpan,System.String,System.String@)">
            <summary>
            Returns <paramref name="value"/> formatted as "[[[[d days ]h]h:]m]m:ss.fff"
            supporting additional formats "^d.ddd^", "^h.hhh^", "^mm.mmm^", "^sss.sss^", "^ffffff^".
            </summary>
            <remarks>
            \remind (2017-06-10 / MKY)
            Additional formats shall be extended after upgrading to .NET 4+ as follows:
             > More flexibility, e.g. "^ss.sss^" and "^ss.ss^" and...
             > Combination with standard formats, i.e. split ^^ and then format each fragment individually.
                                                                   => Dynamically create the format string.
            </remarks>
            <remarks>
            Output milliseconds for readability, even though last digit only provides limited accuracy.
            </remarks>
        </member>
        <member name="T:MKY.TimeSpanEventArgs">
            <summary></summary>
        </member>
        <member name="P:MKY.TimeSpanEventArgs.TimeSpan">
            <summary></summary>
        </member>
        <member name="M:MKY.TimeSpanEventArgs.#ctor(System.TimeSpan)">
            <summary></summary>
        </member>
        <member name="T:MKY.ArrayEx">
            <summary>
            <see cref="T:System.Array"/> utility methods.
            </summary>
        </member>
        <member name="F:MKY.ArrayEx.InvalidIndex">
            <summary>
            The invalid index.
            </summary>
        </member>
        <member name="M:MKY.ArrayEx.IsNullOrEmpty(System.Array)">
            <summary>
            Indicates whether the specified array is <c>null</c> or empty.
            </summary>
            <remarks>
            Same syntax and semantic as <see cref="M:System.String.IsNullOrEmpty(System.String)"/>.
            </remarks>
            <param name="value">The array to test.</param>
            <returns>
            <c>true</c> if the value parameter is <c>null</c> or empty; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MKY.ArrayEx.CreateAndInitializeInstance``1(System.Int32,``0)">
            <summary>
            Creates an array using <see cref="M:System.Array.CreateInstance(System.Type,System.Int32)"/> and initializes
            the given number of array values with the given initial value.
            </summary>
            <typeparam name="T">The type of the array's values.</typeparam>
        </member>
        <member name="M:MKY.ArrayEx.ValuesEqual(System.Array,System.Array)">
            <summary>
            Determines whether the two arrays have value equality, i.e. contains the same number of
            values, all values are equally sequenced and have value equality.
            </summary>
            <remarks>
            This method has intentionally been called "ValuesEqual()"...
            ...for similar naming as <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> and...
            ...to emphasize difference to "Array.Equals()" which is just "object.Equals()".
            </remarks>
            <returns>
            True if arrays have value equality, otherwise false.
            </returns>
        </member>
        <member name="M:MKY.ArrayEx.ValuesToString(System.Array,System.String)">
            <summary>
            Appends all values of an array to a comma separated string and returns it.
            Values that are <c>null</c> are returned as "(null)".
            An empty <paramref name="array"/> is returned as "(empty)".
            </summary>
            <returns>
            String containing values of all items.
            </returns>
        </member>
        <member name="M:MKY.ArrayEx.ValuesToString(System.Array,System.Char)">
            <summary>
            Appends all values of an array to a comma separated string and returns it.
            Values that are <c>null</c> are returned as "(null)".
            </summary>
            <returns>
            String containing values of all items.
            </returns>
        </member>
        <member name="M:MKY.ArrayEx.ValuesToHashCode(System.Array)">
            <summary>
            Serves as a hash function that iterates over all values within the given array.
            </summary>
        </member>
        <member name="T:MKY.BitConverterEx">
            <summary>
            Utility methods extending <see cref="T:System.BitConverter"/>.
            </summary>
        </member>
        <member name="M:MKY.BitConverterEx.ToUInt32(System.Collections.Specialized.BitVector32,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.BitConverterEx.ToUInt32(System.Collections.Specialized.BitVector32,System.Int32,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.BitConverterEx.FromUInt32(System.Collections.Specialized.BitVector32@,System.UInt32,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:MKY.BitConverterEx.FromUInt32(System.Collections.Specialized.BitVector32@,System.UInt32,System.Int32,System.Int32)">
            <summary></summary>
        </member>
        <member name="T:MKY.BooleanEx">
            <summary>
            <see cref="T:System.Boolean"/>/<see cref="T:System.Boolean"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.BooleanEx.Toggle(System.Boolean@)">
            <summary>
            Toggles a boolean value.
            </summary>
        </member>
        <member name="M:MKY.BooleanEx.SetIfCleared(System.Boolean@)">
            <summary>
            Sets the value if it isn't set yet. Return whether the value has been set.
            </summary>
            <remarks>
            Calling this function is more obvious than implementing the logic directly.
            Thus, this function has been created to improve readability of the code and
            reduce potential errors.
            </remarks>
        </member>
        <member name="M:MKY.BooleanEx.ClearIfSet(System.Boolean@)">
            <summary>
            Clears the value if it is set. Return whether the value has been cleared.
            </summary>
            <remarks>
            Calling this function is more obvious than implementing the logic directly.
            Thus, this function has been created to improve readability of the code and
            reduce potential errors.
            </remarks>
        </member>
        <member name="T:MKY.ByteEx">
            <summary>
            <see cref="T:System.Byte"/>/<see cref="T:System.Byte"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.ByteEx.ConvertToBinaryString(System.Byte)">
            <summary>
            Converts value into binary string (e.g. "00010100").
            </summary>
        </member>
        <member name="M:MKY.ByteEx.ConvertToOctalString(System.Byte)">
            <summary>
            Converts value into octal string (e.g. "024").
            </summary>
        </member>
        <member name="T:MKY.CharEx">
            <summary>
            <see cref="T:System.Char"/>/<see cref="T:System.Char"/> utility methods.
            </summary>
        </member>
        <member name="F:MKY.CharEx.InvalidChar">
            <summary>
            An invalid char is represented by -1.
            </summary>
            <remarks>
            Value corresponds to the value returned by <see cref="M:System.IO.StringReader.Read"/>
            and the other read functions if no more characters can be read from the stream.
            Value also corresponds to <see cref="F:MKY.IO.StreamEx.EndOfStream"/>.
            </remarks>
        </member>
        <member name="M:MKY.CharEx.TryConvertToByte(System.Char,System.Byte@)">
            <summary>
            Tries to convert the UTF-16 encoded value into the according ASCII code.
            </summary>
        </member>
        <member name="M:MKY.CharEx.ConvertToPrintableString(System.Char)">
            <summary>
            Converts the given character to a printable string.
            </summary>
            <remarks>
            If the value is a printable character, the string contains that character.
            If the value is a control character, the ASCII mnemonic or Unicode representation is returned.
            </remarks>
        </member>
        <member name="M:MKY.CharEx.IsValidForBase64(System.Char)">
            <summary>
            Determines whether the given character is valid for Base64.
            </summary>
        </member>
        <member name="M:MKY.CharEx.IsValidForBase64Url(System.Char)">
            <summary>
            Determines whether the given character is valid for Base64Url.
            </summary>
        </member>
        <member name="M:MKY.CharEx.IsValidForUTF7(System.Char)">
            <summary>
            Determines whether the given character is valid for UTF-7, as specified
            by https://tools.ietf.org/html/rfc2152.
            </summary>
            <remarks>
            Located here instead of <see cref="T:MKY.Text.EncodingEx"/> for closeness to methods above.
            </remarks>
        </member>
        <member name="T:MKY.DecimalEx">
            <summary>
            <see cref="T:System.Decimal"/>/<see cref="T:System.Decimal"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.DecimalEx.Limit(System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Limits <paramref name="value"/> to the values specified.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="min"/> is larger than <paramref name="max"/>.
            </exception>
        </member>
        <member name="M:MKY.DecimalEx.IsWithin(System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Returns whether <paramref name="value"/> is within the values specified (including boundaries).
            </summary>
        </member>
        <member name="M:MKY.DecimalEx.RatherEqualsIntegral(System.Decimal,System.Decimal)">
            <summary>
            Evaluates whether the integral part of the two given values is equal or almost equal.
            </summary>
            <remarks>
            Same as <code>RatherEquals(lhs, rhs, 0)</code>.
            </remarks>
        </member>
        <member name="M:MKY.DecimalEx.RatherEquals(System.Decimal,System.Decimal)">
            <summary>
            Evaluates whether the two given values are equal or almost equal floating point values.
            </summary>
            <remarks>
            Same as <code>RatherEquals(lhs, rhs, 28)</code>.
            </remarks>
        </member>
        <member name="M:MKY.DecimalEx.RatherEquals(System.Decimal,System.Decimal,System.Int32)">
            <summary>
            Evaluates whether the two given values are equal or almost equal,
            taking the given number of decimals into account.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="decimals"/> is less than 0 or greater than 28.
            </exception>
            <remarks>
            Using term "decimals" same as e.g. <see cref="M:System.Math.Round(System.Decimal,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:MKY.DecimalEx.RatherNotEquals(System.Decimal,System.Decimal,System.Int32)">
            <summary>
            Evaluates whether the two given values are rather not equal,
            taking the given number of decimals into account.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="decimals"/> is less than 0 or greater than 28.
            </exception>
            <remarks>
            Using term "decimals" same as e.g. <see cref="M:System.Math.Round(System.Decimal,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:MKY.DecimalEx.RatherNotEquals(System.Decimal,System.Decimal)">
            <summary>
            Evaluates whether the two given values are rather not equal floating point values.
            </summary>
            <remarks>
            Same as <code>RatherNotEquals(lhs, rhs, 28)</code>.
            </remarks>
        </member>
        <member name="M:MKY.DecimalEx.RatherNotEqualsIntegral(System.Decimal,System.Decimal)">
            <summary>
            Evaluates whether the integral part of the two given values is rather not equal.
            </summary>
            <remarks>
            Same as <code>RatherNotEquals(lhs, rhs, 0)</code>.
            </remarks>
        </member>
        <member name="M:MKY.DecimalEx.GetMinMax(System.Collections.Generic.IEnumerable{System.Decimal},System.Decimal@,System.Decimal@)">
            <summary>
            Get the minimum and maximum within <paramref name="collection"/>.
            </summary>
        </member>
        <member name="T:MKY.DoubleEx">
            <summary>
            <see cref="T:System.Double"/>/<see cref="T:System.Double"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.DoubleEx.Limit(System.Double,System.Double,System.Double)">
            <summary>
            Limits <paramref name="value"/> to the values specified.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="min"/> is larger than <paramref name="max"/>.
            </exception>
        </member>
        <member name="M:MKY.DoubleEx.IsWithin(System.Double,System.Double,System.Double)">
            <summary>
            Returns whether <paramref name="value"/> is within the values specified (including boundaries).
            </summary>
        </member>
        <member name="M:MKY.DoubleEx.RatherEqualsIntegral(System.Double,System.Double)">
            <summary>
            Evaluates whether the integral part of the two given values is equal or almost equal.
            </summary>
            <remarks>
            Same as <code>RatherEquals(lhs, rhs, 0)</code>.
            </remarks>
        </member>
        <member name="M:MKY.DoubleEx.RatherEquals(System.Double,System.Double)">
            <summary>
            Evaluates whether the two given values are equal or almost equal floating point values.
            </summary>
            <remarks>
            Same as <code>RatherEquals(lhs, rhs, 15)</code>.
            </remarks>
        </member>
        <member name="M:MKY.DoubleEx.RatherEquals(System.Double,System.Double,System.Int32)">
            <summary>
            Evaluates whether the two given values are equal or almost equal,
            taking the given number of digits into account.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="digits"/> is less than 0 or greater than 15.
            </exception>
            <remarks>
            Using term "digits" same as e.g. <see cref="M:System.Math.Round(System.Double,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:MKY.DoubleEx.RatherNotEquals(System.Double,System.Double,System.Int32)">
            <summary>
            Evaluates whether the two given values are rather not equal,
            taking the given number of digits into account.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="digits"/> is less than 0 or greater than 15.
            </exception>
            <remarks>
            Using term "digits" same as e.g. <see cref="M:System.Math.Round(System.Double,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:MKY.DoubleEx.RatherNotEquals(System.Double,System.Double)">
            <summary>
            Evaluates whether the two given values are rather not equal floating point values.
            </summary>
            <remarks>
            Same as <code>RatherNotEquals(lhs, rhs, 15)</code>.
            </remarks>
        </member>
        <member name="M:MKY.DoubleEx.RatherNotEqualsIntegral(System.Double,System.Double)">
            <summary>
            Evaluates whether the integral part of the two given values is rather not equal.
            </summary>
            <remarks>
            Same as <code>RatherNotEquals(lhs, rhs, 0)</code>.
            </remarks>
        </member>
        <member name="M:MKY.DoubleEx.GetMinMax(System.Collections.Generic.IEnumerable{System.Double},System.Double@,System.Double@)">
            <summary>
            Get the minimum and maximum within <paramref name="collection"/>.
            </summary>
        </member>
        <member name="T:MKY.EnumEx">
             <summary>
             Extended enumeration type which offers more features that a normal enum.
             <see cref="T:MKY.EnumEx"/> uses an underlying enum to distinguish objects. Provide an enum,
             derive from <see cref="T:MKY.EnumEx"/>, define new name/value methods if necessary and implement
             the conversion methods to get a fully functional <see cref="T:MKY.EnumEx"/>.
             </summary>
             <remarks>
             Using a normal enum in a client class has the big advantage that code designers and
             features like IntelliSense can use their built-in enum support.
             As a draw-back, <see cref="T:MKY.EnumEx"/> based types are not serializable because it abstract
             underlying type <see cref="T:System.Enum"/> isn't.
             </remarks>
             <example>
            
             -------------------------------------------------------------------------------------------
             Creating a concrete EnumEx including implicit conversion operators
             -------------------------------------------------------------------------------------------
            
             <code>
             public enum Mode
             {
                 Fast = 1,
                 Normal = 2,
                 Slow = 3
             }
            
             public class ModeEx : MKY.EnumEx
             {
                 // Default is "Mode.Normal"
                 public ModeEx() : this(Mode.Normal)
                 {
                 }
            
                 protected ModeEx(Mode mode) : base(mode)
                 {
                 }
            
                 public override string ToString()
                 {
                     return (UnderlyingEnum.GetHashCode().ToString());
                 }
            
                 public static ModeEx[] GetItems()
                 {
                     var a = new List[ModeEx](3); // [] must be replaced be angle brackets
            
                     a.Add(new ModeEx(Mode.Fast));
                     a.Add(new ModeEx(Mode.Normal));
                     a.Add(new ModeEx(Mode.Slow));
            
                     return (a.ToArray());
                 }
            
                 public static ModeEx Parse(string s)
                 {
                     return ((ModeEx)int.Parse(s));
                 }
            
                 public static bool TryParse(string s, out ModeEx result)
                 {
                     Mode enumResult;
                     if (TryParse(s, out enumResult)) // TryParse() trims whitespace.
                     {
                         result = new ModeEx(enumResult);
                         return (true);
                     }
                     else
                     {
                         result = null;
                         return (false);
                     }
                 }
            
                 public static bool TryParse(string s, out Mode result)
                 {
                     int intResult;
                     if (int.TryParse(s.Trim(), out intResult)) // TryParse() trims whitespace.
                     {
                         result = (ModeEx)intResult;
                         return (true);
                     }
                     else // Invalid string!
                     {
                         result = new ModeEx(); // Default!
                         return (false);
                     }
                 }
            
                 public static implicit operator Mode(ModeEx mode)
                 {
                     return ((Mode)mode.UnderlyingEnum);
                 }
            
                 public static implicit operator ModeEx(Mode mode)
                 {
                     return (new ModeEx(mode));
                 }
            
                 public static implicit operator int(ModeEx mode)
                 {
                     return (mode.GetHashCode());
                 }
            
                 public static implicit operator ModeEx(int mode)
                 {
                     if      (mode >= (int)Mode.Slow)   return (new ModeEx(Mode.Slow));
                     else if (mode >= (int)Mode.Normal) return (new ModeEx(Mode.Normal));
                     else                               return (new ModeEx(Mode.Fast));
                 }
            
                 public static implicit operator string(ModeEx mode)
                 {
                     return (mode.ToString());
                 }
            
                 public static implicit operator ModeEx(string mode)
                 {
                    return (Parse(mode));
                 }
             }
             </code>
            
             -------------------------------------------
             Adding ModeEx design time support to a class
             -------------------------------------------
            
             <code>
             public class EnumExClient
             {
                 public Mode mode { get; set; } = Mode.Fast; // Mode is a normal enum
                 ...
             }
             </code>
             </example>
        </member>
        <member name="F:MKY.EnumEx.underlyingEnum">
            <summary>
            Underlying enum.
            </summary>
        </member>
        <member name="M:MKY.EnumEx.#ctor">
            <summary>
            Constructor that allows to specify the underlying enum within the constructor of the deriving class.
            </summary>
        </member>
        <member name="M:MKY.EnumEx.#ctor(System.Enum)">
            <summary>
            EnumEx requires an underlying enum to be constructed.
            </summary>
        </member>
        <member name="P:MKY.EnumEx.UnderlyingEnum">
            <summary>
            Underlying enum.
            </summary>
        </member>
        <member name="M:MKY.EnumEx.SetUnderlyingEnum(System.Enum)">
            <summary>
            Sets the underlying enum.
            </summary>
        </member>
        <member name="M:MKY.EnumEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.EnumEx.ToString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation using the
            specified format.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.EnumEx.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.EnumEx.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.EnumEx.Equals(MKY.EnumEx)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.EnumEx.op_Equality(MKY.EnumEx,MKY.EnumEx)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:MKY.EnumEx.op_Inequality(MKY.EnumEx,MKY.EnumEx)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="M:MKY.EnumEx.CompareTo(System.Object)">
            <summary>
            Compares this instance to a specified object and returns an indication
            of their relative values.
            </summary>
        </member>
        <member name="M:MKY.EnumEx.Compare(System.Object,System.Object)">
            <summary></summary>
        </member>
        <member name="M:MKY.EnumEx.op_LessThan(MKY.EnumEx,MKY.EnumEx)">
            <summary></summary>
        </member>
        <member name="M:MKY.EnumEx.op_GreaterThan(MKY.EnumEx,MKY.EnumEx)">
            <summary></summary>
        </member>
        <member name="M:MKY.EnumEx.op_LessThanOrEqual(MKY.EnumEx,MKY.EnumEx)">
            <summary></summary>
        </member>
        <member name="M:MKY.EnumEx.op_GreaterThanOrEqual(MKY.EnumEx,MKY.EnumEx)">
            <summary></summary>
        </member>
        <member name="M:MKY.EnumEx.Clone">
            <summary>
            Creates and returns a new object that is a deep-copy of this instance.
            </summary>
        </member>
        <member name="M:MKY.EnumEx.GetUnderlyingEnumName(System.Type,System.Object)">
            <summary>
            Retrieves the name of the underlying enum constant in the specified
            enumeration that has the specified value.
            </summary>
            <param name="enumExType">The Type of the EnumEx.</param>
            <param name="value">
            The value of a particular enumerated constant in terms of its
            underlying enum.
            </param>
            <returns>
            A string containing the name of the enumerated constant in enumExType
            whose value is value, or a <c>null</c> reference (Nothing in Visual Basic)
            if no such constant is found.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            ex or value is a <c>null</c> reference (Nothing in Visual Basic).
            </exception>
            <exception cref="T:System.ArgumentException">
            value is not of type ex.
            </exception>
        </member>
        <member name="M:MKY.EnumEx.GetUnderlyingEnumNames(System.Type)">
            <summary>
            Retrieves an array of the underlying enum names of the constants in
            the specified enumeration.
            </summary>
            <param name="enumExType">The Type of the EnumEx.</param>
            <returns>
            A string array of the names of the constants in enum type. The values
            of the array are sorted by the values of the enumerated constants.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            ex or value is a <c>null</c> reference (Nothing in Visual Basic).
            </exception>
        </member>
        <member name="M:MKY.EnumEx.GetUnderlyingEnumValues(System.Type)">
            <summary>
            Retrieves an array of the underlying enum values of the constants in
            the specified enumeration.
            </summary>
            <param name="enumExType">The Type of the EnumEx.</param>
            <returns>
            An Array of the values of the constants in enum type. The values of
            the array are sorted by the values of the enumeration constants.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            ex or value is a <c>null</c> reference (Nothing in Visual Basic).
            </exception>
        </member>
        <member name="M:MKY.EnumEx.GetUnderlyingEnumItems(System.Type)">
            <summary>
            Retrieves an array of the underlying enums in the specified enumeration.
            </summary>
            <param name="enumExType">The Type of the EnumEx.</param>
            <returns>
            An Array of the values of the constants in enum type. The values of
            the array are sorted by the values of the enumeration constants.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            ex or value is a <c>null</c> reference (Nothing in Visual Basic).
            </exception>
        </member>
        <member name="M:MKY.EnumEx.IsDefined(System.Type,System.Object)">
             <summary>
             Returns an indication whether an underlying constant with a specified
             value exists in the specified enumeration.
             </summary>
             <param name="enumExType">The Type of the EnumEx.</param>
             <param name="value">The value or name of a constant in ex.</param>
             <returns>
             <c>true</c> if a constant in enumType has a value equal to value;
             otherwise, <c>false</c>.
             </returns>
             <exception cref="T:System.ArgumentNullException">
             ex or value is a <c>null</c> reference (Nothing in Visual Basic).
             </exception>
             <exception cref="T:System.ArgumentException">
             The type of value is not an EnumEx.
            
             -or-
            
             The type of value is not an underlying type of EnumEx.
             </exception>
        </member>
        <member name="M:MKY.EnumEx.Parse(System.Type,System.String)">
             <summary>
             Converts the string representation of the name or numeric value of one
             or more enumerated constants to an equivalent enumerated object.
             </summary>
             <param name="enumExType">The Type of the EnumEx.</param>
             <param name="value">A string containing the name or value to convert.</param>
             <exception cref="T:System.ArgumentNullException">
             enumExType or value is a <c>null</c> reference (Nothing in Visual Basic).
             </exception>
             <exception cref="T:System.ArgumentException">
             value is either an empty string or only contains whitespace.
            
             -or-
            
             value is a name, but not one of the named constants defined for the
             enumeration.
             </exception>
        </member>
        <member name="M:MKY.EnumEx.Parse(System.Type,System.String,System.Boolean)">
             <summary>
             Converts the string representation of the name or numeric value of one
             or more enumerated constants to an equivalent enumerated object.
             </summary>
             <param name="enumExType">The Type of the EnumEx.</param>
             <param name="value">A string containing the name or value to convert.</param>
             <param name="ignoreCase">If true, ignore case; otherwise, regard case.</param>
             <returns>An EnumEx whose value is represented by value.</returns>
             <exception cref="T:System.ArgumentNullException">
             enumExType or value is a <c>null</c> reference (Nothing in Visual Basic).
             </exception>
             <exception cref="T:System.ArgumentException">
             value is either an empty string or only contains whitespace.
            
             -or-
            
             value is a name, but not one of the named constants defined for the
             enumeration.
             </exception>
        </member>
        <member name="M:MKY.EnumEx.Format(System.Type,System.Object,System.String)">
            <summary>
            Converts the specified value of a specified enumerated type to its
            equivalent string representation according to the specified format.
            </summary>
            <param name="enumExType">The Type of the EnumEx.</param>
            <param name="value">The value to convert.</param>
            <param name="format">The output format to use.</param>
            <returns>A string representation of value.</returns>
            <exception cref="T:System.ArgumentNullException">
            ex or value is a <c>null</c> reference (Nothing in Visual Basic).
            </exception>
            <exception cref="T:System.ArgumentException">
            The value is from an enumeration that differs in type from enum type.
            s
            -or-
            s
            The type of value is not an underlying type of enum type.
            </exception>
            <exception cref="T:System.FormatException">
            The format parameter contains an invalid value.
            </exception>
        </member>
        <member name="T:MKY.Int64Ex">
            <summary>
            <see cref="T:System.Int64"/>/<see cref="T:System.Int64"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.Int64Ex.EqualsAny(System.Int64,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Determines whether <paramref name="value"/> equals any of the specified <paramref name="values"/>.
            </summary>
            <param name="value">The value.</param>
            <param name="values">The values to compare with.</param>
            <returns>true if <paramref name="value"/> matches any of the <paramref name="values"/>; otherwise, false.</returns>
        </member>
        <member name="M:MKY.Int64Ex.Limit(System.Int64,System.Int64,System.Int64)">
            <summary>
            Limits <paramref name="value"/> to the values specified.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="min"/> is larger than <paramref name="max"/>.
            </exception>
        </member>
        <member name="M:MKY.Int64Ex.IsWithin(System.Int64,System.Int64,System.Int64)">
            <summary>
            Returns whether <paramref name="value"/> is within the values specified (including boundaries).
            </summary>
        </member>
        <member name="M:MKY.Int64Ex.IsEven(System.Int64)">
            <summary>
            Returns whether <paramref name="value"/> is even.
            </summary>
        </member>
        <member name="M:MKY.Int64Ex.IsOdd(System.Int64)">
            <summary>
            Returns whether <paramref name="value"/> is odd.
            </summary>
        </member>
        <member name="M:MKY.Int64Ex.ToEnglishSuffix(System.Int64)">
            <summary>
            Returns the according numeric suffix like "st", "nd", "rd" or "th".
            </summary>
        </member>
        <member name="M:MKY.Int64Ex.GetMinMax(System.Collections.Generic.IEnumerable{System.Int64},System.Int64@,System.Int64@)">
            <summary>
            Get the minimum and maximum within <paramref name="collection"/>.
            </summary>
        </member>
        <member name="T:MKY.Int32Ex">
            <summary>
            <see cref="T:System.Int32"/>/<see cref="T:System.Int32"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.Int32Ex.EqualsAny(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Determines whether <paramref name="value"/> equals any of the specified <paramref name="values"/>.
            </summary>
            <param name="value">The value.</param>
            <param name="values">The values to compare with.</param>
            <returns>true if <paramref name="value"/> matches any of the <paramref name="values"/>; otherwise, false.</returns>
        </member>
        <member name="M:MKY.Int32Ex.Limit(System.Int32,System.Int32,System.Int32)">
            <summary>
            Limits <paramref name="value"/> to the values specified.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="min"/> is larger than <paramref name="max"/>.
            </exception>
        </member>
        <member name="M:MKY.Int32Ex.IsWithin(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns whether <paramref name="value"/> is within the values specified (including boundaries).
            </summary>
        </member>
        <member name="M:MKY.Int32Ex.IsEven(System.Int32)">
            <summary>
            Returns whether <paramref name="value"/> is even.
            </summary>
        </member>
        <member name="M:MKY.Int32Ex.IsOdd(System.Int32)">
            <summary>
            Returns whether <paramref name="value"/> is odd.
            </summary>
        </member>
        <member name="M:MKY.Int32Ex.ToEnglishSuffix(System.Int32)">
            <summary>
            Returns the according numeric suffix like "st", "nd", "rd" or "th".
            </summary>
        </member>
        <member name="M:MKY.Int32Ex.GetMinMax(System.Collections.Generic.IEnumerable{System.Int32},System.Int32@,System.Int32@)">
            <summary>
            Get the minimum and maximum within <paramref name="collection"/>.
            </summary>
        </member>
        <member name="T:MKY.ObjectEx">
            <summary>
            <see cref="T:System.Object"/>/<see cref="T:System.Object"/> utility methods.
            </summary>
        </member>
        <member name="F:MKY.ObjectEx.InvalidComparisonResult">
            <summary>
            -1 is specified as the 'invalid comparison' result in .NET.
            </summary>
        </member>
        <member name="M:MKY.ObjectEx.Equals(System.Object,System.Object)">
             <summary>
             Determines whether the specified <see cref="T:System.Object"/> instances are considered equal.
             </summary>
             <remarks>
             This method is simply a wrapper to <see cref="M:System.Object.Equals(System.Object,System.Object)"/>. It can
             e.g. be used to implement an overloaded Equals() method. Calling this method is preferred
             over directly calling <see cref="M:System.Object.Equals(System.Object,System.Object)"/> or the respective base
             method <see cref="M:System.Object.Equals(System.Object,System.Object)"/> to prevent code check from
             suggesting to simply call <see cref="M:MKY.ObjectEx.Equals(System.Object,System.Object)"/> as that could result in
             an unintended call stack as soon as a class overloads that method.
            
             Note the logic behind <see cref="M:System.Object.Equals(System.Object,System.Object)"/>:
              - If both objects represent the same object reference, it returns true.
              - If either or object is <c>null</c>, it returns false.
              - Otherwise, it calls objA.Equals(objB) and returns the result.
             </remarks>
             <param name="objA">The first <see cref="T:System.Object"/> to compare.</param>
             <param name="objB">The second <see cref="T:System.Object"/> to compare.</param>
             <returns><c>true</c> if the instances are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.ObjectEx.CreateDeepCloneOfSerializableItem``1(``0)">
            <summary>
            Returns a deep-cloned instance of the given object.
            </summary>
            <typeparam name="T">
            The type of the object, must be decorated with the <see cref="T:System.SerializableAttribute"/>.
            </typeparam>
        </member>
        <member name="T:MKY.SingleEx">
            <summary>
            <see cref="T:System.Single"/>/<see cref="T:System.Single"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.SingleEx.Limit(System.Single,System.Single,System.Single)">
            <summary>
            Limits <paramref name="value"/> to the values specified.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="min"/> is larger than <paramref name="max"/>.
            </exception>
        </member>
        <member name="M:MKY.SingleEx.IsWithin(System.Single,System.Single,System.Single)">
            <summary>
            Returns whether <paramref name="value"/> is within the values specified (including boundaries).
            </summary>
        </member>
        <member name="M:MKY.SingleEx.RatherEqualsIntegral(System.Single,System.Single)">
            <summary>
            Evaluates whether the integral part of the two given values is equal or almost equal.
            </summary>
            <remarks>
            Same as <code>RatherEquals(lhs, rhs, 0)</code>.
            </remarks>
        </member>
        <member name="M:MKY.SingleEx.RatherEquals(System.Single,System.Single)">
            <summary>
            Evaluates whether the two given values are equal or almost equal floating point values.
            </summary>
            <remarks>
            Same as <code>RatherEquals(lhs, rhs, 7)</code>.
            </remarks>
        </member>
        <member name="M:MKY.SingleEx.RatherEquals(System.Single,System.Single,System.Int32)">
            <summary>
            Evaluates whether the two given values are equal or almost equal,
            taking the given number of digits into account.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="digits"/> is less than 0 or greater than 7.
            </exception>
            <remarks>
            Using term "digits" same as e.g. <see cref="M:System.Math.Round(System.Double,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:MKY.SingleEx.RatherNotEquals(System.Single,System.Single,System.Int32)">
            <summary>
            Evaluates whether the two given values are rather not equal,
            taking the given number of digits into account.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="digits"/> is less than 0 or greater than 7.
            </exception>
            <remarks>
            Using term "digits" same as e.g. <see cref="M:System.Math.Round(System.Double,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:MKY.SingleEx.RatherNotEquals(System.Single,System.Single)">
            <summary>
            Evaluates whether the two given values are rather not equal floating point values.
            </summary>
            <remarks>
            Same as <code>RatherNotEquals(lhs, rhs, 7)</code>.
            </remarks>
        </member>
        <member name="M:MKY.SingleEx.RatherNotEqualsIntegral(System.Single,System.Single)">
            <summary>
            Evaluates whether the integral part of the two given values is rather not equal.
            </summary>
            <remarks>
            Same as <code>RatherNotEquals(lhs, rhs, 0)</code>.
            </remarks>
        </member>
        <member name="M:MKY.SingleEx.GetMinMax(System.Collections.Generic.IEnumerable{System.Single},System.Single@,System.Single@)">
            <summary>
            Get the minimum and maximum within <paramref name="collection"/>.
            </summary>
        </member>
        <member name="T:MKY.StringEx">
            <summary>
            <see cref="T:System.String"/>/<see cref="T:System.String"/> utility methods.
            </summary>
        </member>
        <member name="F:MKY.StringEx.InvalidIndex">
            <summary>
            An invalid index is represented by -1.
            </summary>
        </member>
        <member name="F:MKY.StringEx.Ellipsis">
            <summary>
            Text ellipsis which are "..." by definition.
            </summary>
        </member>
        <member name="F:MKY.StringEx.ListInitialCapacityDefault">
            <remarks>
            16 is an arbitrary value.
            </remarks>
        </member>
        <member name="M:MKY.StringEx.CompareOrdinalIgnoreCase(System.String,System.String)">
            <summary>
            Compares two specified <see cref="T:System.String"/> objects ignoring culture and case.
            The method returns an integer that indicates the relationship of the two
            <see cref="T:System.String"/> objects to one another in the sort order.
            </summary>
            <param name="strA">The first <see cref="T:System.String"/> object.</param>
            <param name="strB">The second <see cref="T:System.String"/> object.</param>
            <returns>
            A 32-bit signed integer indicating the lexical relationship between the two comparands.
            Value Condition:
             - Less than zero <paramref name="strA"/> is less than <paramref name="strB"/>.
             - Zero <paramref name="strA"/> equals <paramref name="strB"/>.
             - Greater than zero <paramref name="strA"/> is greater than <paramref name="strB"/>.
            </returns>
        </member>
        <member name="M:MKY.StringEx.EqualsOrdinal(System.String,System.String)">
            <summary>
            Compares two specified <see cref="T:System.String"/> objects ignoring culture.
            </summary>
        </member>
        <member name="M:MKY.StringEx.ValuesEqualOrdinal(System.String[],System.String[])">
            <summary>
            Compares two specified <see cref="T:System.String"/> arrays ignoring culture.
            </summary>
            <remarks>
            There are overloads for <see cref="T:System.String"/> arrays as well as
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> for optimal performance.
            </remarks>
        </member>
        <member name="M:MKY.StringEx.ItemsEqualOrdinal(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Compares two specified <see cref="T:System.String"/> enumerables ignoring culture.
            </summary>
            <remarks>
            There are overloads for <see cref="T:System.String"/> arrays as well as
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> for optimal performance.
            </remarks>
        </member>
        <member name="M:MKY.StringEx.EqualsOrdinalIgnoreCase(System.String,System.String)">
            <summary>
            Compares two specified <see cref="T:System.String"/> objects ignoring culture and case.
            </summary>
        </member>
        <member name="M:MKY.StringEx.ValuesEqualOrdinalIgnoreCase(System.String[],System.String[])">
            <summary>
            Compares two specified <see cref="T:System.String"/> arrays ignoring culture and case.
            </summary>
            <remarks>
            There are overloads for <see cref="T:System.String"/> arrays as well as
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> for optimal performance.
            </remarks>
        </member>
        <member name="M:MKY.StringEx.ItemsEqualOrdinalIgnoreCase(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Compares two specified <see cref="T:System.String"/> enumerables ignoring culture and case.
            </summary>
            <remarks>
            There are overloads for <see cref="T:System.String"/> arrays as well as
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> for optimal performance.
            </remarks>
        </member>
        <member name="M:MKY.StringEx.EqualsAnyOrdinalIgnoreCase(System.String,System.String[])">
            <summary>
            Compares whether <paramref name="strA"/> matches any <paramref name="strB"/>.
            </summary>
        </member>
        <member name="M:MKY.StringEx.EqualsAnyOrdinalIgnoreCase(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Compares whether <paramref name="strA"/> matches any <paramref name="strB"/>.
            </summary>
        </member>
        <member name="M:MKY.StringEx.CountLeft(System.String,System.Char[])">
            <summary>
            Counts the number of <paramref name="countChars"/> to the left of <paramref name="str"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.CountRight(System.String,System.Char[])">
            <summary>
            Counts the number of <paramref name="countChars"/> to the right of <paramref name="str"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.ContainingCount(System.String,System.String,System.StringComparison)">
            <summary>
            Determines how many occurrences of <paramref name="value"/> are contained in <paramref name="str"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.ContainingWholeWordCount(System.String,System.String,System.StringComparison)">
            <summary>
            Determines how many occurrences of <paramref name="value"/> are contained in <paramref name="str"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.ContainsAny(System.String,System.Char[])">
            <summary>
            Determines whether <paramref name="str"/> contains any of the <paramref name="anyOf"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.ContainsAny(System.String,System.String[])">
            <summary>
            Determines whether <paramref name="str"/> matches one of the specified <paramref name="values"/>.
            </summary>
            <param name="str">The string.</param>
            <param name="values">The strings to compare with.</param>
            <returns>true if <paramref name="str"/> matches the beginning of a comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException">One of the <paramref name="values"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.ContainsAny(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether <paramref name="str"/> matches one of the specified <paramref name="values"/>.
            </summary>
            <param name="str">The string.</param>
            <param name="values">The strings to compare with.</param>
            <returns>true if <paramref name="str"/> matches the beginning of a comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException">One of the <paramref name="values"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.StartsWithOrdinal(System.String,System.String)">
            <summary>
            Determines whether the beginning of <paramref name="str"/> matches the specified <paramref name="value"/>.
            </summary>
            <param name="str">The string.</param>
            <param name="value">The string to compare with.</param>
            <returns>true if <paramref name="str"/> matches the beginning of the comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.StartsWithOrdinalIgnoreCase(System.String,System.String)">
            <summary>
            Determines whether the beginning of <paramref name="str"/> matches the specified <paramref name="value"/>.
            </summary>
            <param name="str">The string.</param>
            <param name="value">The string to compare with.</param>
            <returns>true if <paramref name="str"/> matches the beginning of the comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.StartsWithAny(System.String,System.String[])">
            <summary>
            Determines whether the beginning of <paramref name="str"/> matches one of the specified <paramref name="values"/>.
            </summary>
            <param name="str">The string.</param>
            <param name="values">The strings to compare with.</param>
            <returns>true if <paramref name="str"/> matches the beginning of a comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException">One of the <paramref name="values"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.StartsWithAny(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether the beginning of <paramref name="str"/> matches one of the specified <paramref name="values"/>.
            </summary>
            <param name="str">The string.</param>
            <param name="values">The strings to compare with.</param>
            <returns>true if <paramref name="str"/> matches the beginning of a comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException">One of the <paramref name="values"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.StartsWithAny(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Determines whether the beginning of <paramref name="str"/> matches one of the specified <paramref name="values"/>
            when compared using the specified culture.
            </summary>
            <param name="str">The string.</param>
            <param name="values">The strings to compare with.</param>
            <param name="ignoreCase">true to ignore case when comparing this string and value; otherwise, false.</param>
            <param name="culture">Cultural information that determines how this string and value are compared. If culture is null, the current culture is used.</param>
            <returns>true if <paramref name="str"/> matches the beginning of a comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException">One of the <paramref name="values"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.StartsWithAny(System.String,System.Collections.Generic.IEnumerable{System.String},System.StringComparison)">
            <summary>
            Determines whether the beginning of <paramref name="str"/> matches one of the specified <paramref name="values"/>
            when compared using the specified comparison type.
            </summary>
            <param name="str">The string.</param>
            <param name="values">The strings to compare with.</param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values that determines how the strings and the value are compared.</param>
            <returns>true if <paramref name="str"/> matches the beginning of a comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException">One of the <paramref name="values"/> is null.</exception>
            <exception cref="T:System.ArgumentException">comparisonType is not a <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:MKY.StringEx.StartsWithAnyOrdinalIgnoreCase(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether the beginning of <paramref name="str"/> matches one of the specified <paramref name="values"/>.
            </summary>
            <param name="str">The string.</param>
            <param name="values">The strings to compare with.</param>
            <returns>true if <paramref name="str"/> matches the beginning of a comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException">One of the <paramref name="values"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.StartsWithAnyOrdinalIgnoreCase(System.String,System.String[])">
            <summary>
            Determines whether the beginning of <paramref name="str"/> matches one of the specified <paramref name="values"/>.
            </summary>
            <param name="str">The string.</param>
            <param name="values">The strings to compare with.</param>
            <returns>true if <paramref name="str"/> matches the beginning of a comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException">One of the <paramref name="values"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.EndsWithOrdinalIgnoreCase(System.String,System.String)">
            <summary>
            Determines whether the end of <paramref name="str"/> matches the specified <paramref name="value"/>.
            </summary>
            <param name="str">The string.</param>
            <param name="value">The string to compare with.</param>
            <returns>true if <paramref name="str"/> matches the end of the comparing string; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.Left(System.String,System.Int32)">
            <summary>
            Truncates <paramref name="str"/> to the <paramref name="length"/> leftmost characters.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.Mid(System.String,System.Int32,System.Int32)">
            <summary>
            Truncates <paramref name="str"/> from <paramref name="begin"/> to <paramref name="end"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.Right(System.String,System.Int32)">
            <summary>
            Truncates <paramref name="str"/> to the <paramref name="length"/> rightmost characters.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.Limit(System.String,System.Int32)">
            <summary>
            Limits the give string to the specified max length. If the string exceed the max length,
            <see cref="F:MKY.StringEx.Ellipsis"/> are appended.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.SplitLeft(System.String,System.Int32)">
            <summary>
            Splits <paramref name="str"/> to the <paramref name="length"/> leftmost characters.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.SplitRight(System.String,System.Int32)">
            <summary>
            Splits <paramref name="str"/> to the <paramref name="length"/> rightmost characters.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.SplitFixedLength(System.String,System.Int32)">
            <summary>
            Splits <paramref name="str"/> into chunks of <paramref name="desiredChunkLength"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.SplitLexically(System.String,System.Int32)">
            <summary>
            Splits <paramref name="str"/> into chunks of <paramref name="desiredChunkLength"/>,
            taking word boundaries into account.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.SplitLexicallyWithoutTakingNewLineIntoAccount(System.String,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.Trim(System.String,System.Int32,System.Char[])">
            <summary>
            Removes up to <paramref name="maxLength"/> leading and trailing occurrences of a set
            of characters specified in an array from the current <see cref="T:System.String"/> object.
            </summary>
            <param name="str">The string to trim.</param>
            <param name="maxLength">The maximum number of characters to trim at both ends.</param>
            <param name="trimChars">An array of Unicode characters to remove or null.</param>
            <returns>
            The string that remains after all occurrences of the characters in the trimChars
            parameter are removed from the start and end of the current <see cref="T:System.String"/>
            object. If <paramref name="trimChars"/> is null, white-space characters are removed
            instead.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.TrimSymmetrical(System.String,System.Int32,System.Char[])">
            <summary>
            Removes up to <paramref name="maxLength"/> leading and trailing occurrences of a set
            of characters specified in an array from the current <see cref="T:System.String"/> object,
            but only if they occur to both ends of the string.
            </summary>
            <param name="str">The string to trim.</param>
            <param name="maxLength">The maximum number of characters to trim at both ends.</param>
            <param name="trimChars">An array of Unicode characters to remove or null.</param>
            <returns>
            The string that remains after all occurrences of the characters in the trimChars
            parameter are removed from the start and end of the current <see cref="T:System.String"/>
            object. If <paramref name="trimChars"/> is null, white-space characters are removed
            instead.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.TrimSymmetrical(System.String,System.Char[])">
            <summary>
            Removes all leading and trailing occurrences of a set of characters specified in an
            array from the current <see cref="T:System.String"/> object, but only if they occur to
            both ends of the string.
            </summary>
            <param name="str">The string to trim.</param>
            <param name="trimChars">An array of Unicode characters to remove or null.</param>
            <returns>
            The string that remains after all occurrences of the characters in the trimChars
            parameter are removed from the start and end of the current <see cref="T:System.String"/>
            object. If <paramref name="trimChars"/> is null, white-space characters are removed
            instead.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.Space(System.String)">
            <summary>
            Spaces all characters of a <see cref="T:System.String"/> object.
            </summary>
            <param name="str">The string to space.</param>
            <returns>
            A new string that contains the spaced version of <paramref name="str"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.Space(System.String,System.Char)">
            <summary>
            Spaces all characters of a <see cref="T:System.String"/> object.
            </summary>
            <param name="str">The string to space.</param>
            <param name="space">The character to use as space.</param>
            <returns>
            A new string that contains the spaced version of <paramref name="str"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.IndexOfSameCharacterClass(System.String,System.Int32)">
            <summary>
            Reports the index of the first occurrence of the same character class in <paramref name="str"/>.
            </summary>
            <param name="str">The <see cref="T:System.String"/> object to process.</param>
            <param name="startIndex">The search starting position.</param>
            <returns>
            The zero-based index position of the start of the same character class in the string.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.IndexOfWholeWord(System.String,System.String,System.StringComparison)">
            <summary>
            Reports the index of the first occurrence of the specified word in <paramref name="str"/>.
            </summary>
            <param name="str">The <see cref="T:System.String"/> object to process.</param>
            <param name="value">The word to search for.</param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values.</param>
            <returns>
            The zero-based index position of the start of the same character class in the string.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.IndexOfWholeWord(System.String,System.String,System.Int32,System.StringComparison)">
            <summary>
            Reports the index of the first occurrence of the specified word in <paramref name="str"/>.
            </summary>
            <param name="str">The <see cref="T:System.String"/> object to process.</param>
            <param name="value">The word to search for.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values.</param>
            <returns>
            The zero-based index position of the start of the same character class in the string.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.IndexOfOutsideDoubleQuotes(System.String,System.String,System.StringComparison)">
            <summary>
            Reports the index of the first occurrence of the specified string in <paramref name="str"/>.
            Parameters specify the starting search position in the string, the number of characters
            in the current string to search, and the type of search to use for the specified string.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
        </member>
        <member name="M:MKY.StringEx.IndexOfOutsideDoubleQuotes(System.String,System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Reports the index of the first occurrence of the specified string in <paramref name="str"/>.
            Parameters specify the starting search position in the string, the number of characters
            in the current string to search, and the type of search to use for the specified string.
            </summary>
            <param name="str">The <see cref="T:System.String"/> object to process.</param>
            <param name="searchString">The <see cref="T:System.String"/> object to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values.</param>
            <returns>
            The zero-based index position of the value parameter if that string is found,
            or <see cref="F:MKY.StringEx.InvalidIndex"/> if it is not. If value is <see cref="F:System.String.Empty"/>,
            the return value is <paramref name="startIndex"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="searchString"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> or <paramref name="startIndex"/> is negative.  -or- <paramref name="count"/> plus <paramref name="startIndex"/> specify a position that is not within this instance.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:MKY.StringEx.ConvertToPrintableString(System.String)">
            <summary>
            Converts the given value to a printable string.
            </summary>
            <remarks>
            Printable characters are kept, control characters are converted into the ASCII mnemonic
            or Unicode representation as required.
            </remarks>
        </member>
        <member name="T:MKY.UInt64Ex">
            <summary>
            <see cref="T:System.UInt64"/>/<see cref="T:System.UInt64"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.UInt64Ex.EqualsAny(System.UInt64,System.Collections.Generic.IEnumerable{System.UInt64})">
            <summary>
            Determines whether <paramref name="value"/> equals any of the specified <paramref name="values"/>.
            </summary>
            <param name="value">The value.</param>
            <param name="values">The values to compare with.</param>
            <returns>true if <paramref name="value"/> matches any of the <paramref name="values"/>; otherwise, false.</returns>
        </member>
        <member name="M:MKY.UInt64Ex.ConvertToBinaryString(System.UInt64)">
            <summary>
            Converts the value into a binary string (e.g. "0000000000000000000000000000000000000000000000000000000000010100").
            </summary>
        </member>
        <member name="M:MKY.UInt64Ex.ConvertToBinaryString(System.UInt64,System.UInt64)">
            <summary>
            Converts the value into a binary string (e.g. "0000000000000000000000000000000000000000000000000000000000010100").
            </summary>
        </member>
        <member name="M:MKY.UInt64Ex.ConvertToOctalString(System.UInt64)">
            <summary>
            Converts value into octal string (e.g. "000000000000000000024").
            </summary>
        </member>
        <member name="M:MKY.UInt64Ex.ConvertToOctalString(System.UInt64,System.UInt64)">
            <summary>
            Converts value into octal string (e.g. "000000000000000000024").
            </summary>
        </member>
        <member name="M:MKY.UInt64Ex.ConvertToNumericBaseString(System.Int32,System.UInt64,System.UInt64)">
            <summary>
            Converts value into a string with the given numeric base.
            </summary>
            <param name="numericBase">Numeric base (e.g. 4 or 8).</param>
            <param name="value">Value to be converted.</param>
            <param name="max">Maximum value.</param>
        </member>
        <member name="M:MKY.UInt64Ex.ConvertToByteArray(System.UInt64)">
            <summary>
            Converts value into a byte array. Negative numbers can optionally be converted,
            they are aligned to the specified boundary.
            </summary>
            <param name="value">Value to convert.</param>
            <returns>Converted byte array.</returns>
        </member>
        <member name="M:MKY.UInt64Ex.ConvertToByteArray(System.UInt64,System.Int32,System.Boolean)">
            <summary>
            Converts value into a byte array. Negative numbers can optionally be converted,
            they are aligned to the specified boundary.
            </summary>
            <param name="value">Value to convert.</param>
            <param name="boundary">
            byte boundary (e.g. 1/2/4/8 bytes). Set to 0 for
            automatic expansion to next 1/2/4/8 byte boundary.
            </param>
            <param name="useBigEndian">Use big endian instead of little endian.</param>
            <returns>Converted byte array.</returns>
        </member>
        <member name="M:MKY.UInt64Ex.ConvertToByteArray(System.UInt64,System.Boolean,System.Boolean)">
            <summary>
            Converts value into a byte array. Negative numbers can optionally be converted,
            they are aligned to the specified boundary.
            </summary>
            <param name="value">Value to convert.</param>
            <param name="expandNegative">True to expand negative values.</param>
            <param name="useBigEndian">Use big endian instead of little endian.</param>
            <returns>Converted byte array.</returns>
        </member>
        <member name="M:MKY.UInt64Ex.ConvertToByteArray(System.UInt64,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Converts value into a byte array. Negative numbers can optionally be converted,
            they are aligned to the specified boundary.
            </summary>
            <param name="value">Value to convert.</param>
            <param name="boundary">
            byte boundary (e.g. 1/2/4/8 bytes). Set to 0 for
            automatic expansion to next 1/2/4/8 byte boundary.
            </param>
            <param name="expandNegative">True to expand negative values.</param>
            <param name="useBigEndian">Use big endian instead of little endian.</param>
            <returns>Converted byte array.</returns>
        </member>
        <member name="M:MKY.UInt64Ex.TryParseBinary(System.String,System.UInt64@)">
            <summary>
            Parses a binary string (e.g. "00101011"). String must not contain
            other characters than '0' or '1'.
            </summary>
            <param name="s">String to be parsed.</param>
            <param name="result">
            When this method returns, contains the 64-bit unsigned value value equivalent to the
            number contained in <paramref name="s"/>, if the conversion succeeded, or zero if
            the conversion failed. The conversion fails if the <paramref name="s"/> parameter
            is <c>null</c>, is not of the correct format, or represents a number less than
            <see cref="F:System.UInt64.MinValue"/> or greater than <see cref="F:System.UInt64.MaxValue"/>.
            This parameter is passed uninitialized.
            </param>
            <returns>The corresponding integer value.</returns>
        </member>
        <member name="M:MKY.UInt64Ex.TryParseOctal(System.String,System.UInt64@)">
            <summary>
            Parses a octal string (e.g. "54"). String must not contain other
            characters than '0' to '7'.
            </summary>
            <param name="s">String to be parsed.</param>
            <param name="result">
            When this method returns, contains the 64-bit unsigned value value equivalent to the
            number contained in <paramref name="s"/>, if the conversion succeeded, or zero if
            the conversion failed. The conversion fails if the <paramref name="s"/> parameter
            is <c>null</c>, is not of the correct format, or represents a number less than
            <see cref="F:System.UInt64.MinValue"/> or greater than <see cref="F:System.UInt64.MaxValue"/>.
            This parameter is passed uninitialized.
            </param>
            <returns>The corresponding integer value.</returns>
        </member>
        <member name="M:MKY.UInt64Ex.TryParseNumericBase(System.Int32,System.String,System.UInt64@)">
            <summary>
            Parses a string containing a value in any numeric base. String must not
            contain leading or trailing non-numeric characters.
            </summary>
            <param name="numericBase">Numeric base (e.g. 4 or 8).</param>
            <param name="s">String to be parsed.</param>
            <param name="result">
            When this method returns, contains the 64-bit unsigned value value equivalent to the
            number contained in <paramref name="s"/>, if the conversion succeeded, or zero if
            the conversion failed. The conversion fails if the <paramref name="s"/> parameter
            is <c>null</c>, is not of the correct format, or represents a number less than
            <see cref="F:System.UInt64.MinValue"/> or greater than <see cref="F:System.UInt64.MaxValue"/>.
            This parameter is passed uninitialized.
            </param>
            <returns>The corresponding integer value.</returns>
        </member>
        <member name="T:MKY.Usb.Descriptors">
            <summary>
            Encapsulates USB items.
            </summary>
        </member>
        <member name="F:MKY.Usb.Descriptors.MaxStringDescriptorCharLength">
            <summary>
            Maximum of 126 characters in UCS-2 format.
            </summary>
        </member>
        <member name="M:MKY.Usb.Descriptors.GetCultureInfoFromLanguageString(System.String)">
            <summary>
            Retrieves available culture information from language string.
            </summary>
        </member>
        <member name="T:MKY.Windows.Forms.FormEx">
            <summary>
            <see cref="T:System.Windows.Forms.Form"/> utility methods.
            </summary>
        </member>
        <member name="T:MKY.Windows.Forms.FilePathDialogResult">
            <summary></summary>
        </member>
        <member name="P:MKY.Windows.Forms.FilePathDialogResult.Result">
            <summary>
            Gets or sets the dialog result.
            </summary>
            <value>The dialog result.</value>
        </member>
        <member name="P:MKY.Windows.Forms.FilePathDialogResult.FilePath">
            <summary>
            Gets the file path.
            </summary>
            <value>The file path.</value>
        </member>
        <member name="M:MKY.Windows.Forms.FilePathDialogResult.#ctor(System.Windows.Forms.DialogResult)">
            <summary>
            Initializes a new instance of the <see cref="T:SaveAsDialogResult"/> struct.
            </summary>
            <param name="result">The dialog result.</param>
        </member>
        <member name="M:MKY.Windows.Forms.FilePathDialogResult.#ctor(System.Windows.Forms.DialogResult,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SaveAsDialogResult"/> struct.
            </summary>
            <param name="result">The dialog result.</param>
            <param name="filePath">The file path.</param>
        </member>
        <member name="M:MKY.Windows.Forms.FilePathDialogResult.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.FilePathDialogResult.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.FilePathDialogResult.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.FilePathDialogResult.Equals(MKY.Windows.Forms.FilePathDialogResult)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.FilePathDialogResult.op_Equality(MKY.Windows.Forms.FilePathDialogResult,MKY.Windows.Forms.FilePathDialogResult)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.FilePathDialogResult.op_Inequality(MKY.Windows.Forms.FilePathDialogResult,MKY.Windows.Forms.FilePathDialogResult)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.Windows.Forms.ApplicationEx">
            <summary>
            <see cref="N:System.Windows.Forms"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.ApplicationEx.EnableVisualStylesAndSetTextRenderingIfNotInitializedYet">
            <summary>
            Helper method to deal with application startup requirements of .NET 2.0 and later.
            </summary>
            <remarks>
            <see cref="M:System.Windows.Forms.Application.EnableVisualStyles"/> must be called before creating any
            controls in the application. Typically, it is the first line in the Main function.
            <see cref="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)"/> has to be set to false
            for all controls included with Windows Forms 2.0 or later. However, this method can
            only be called before the first window is created by the application. This helper
            method ensures that this only happens once. This is particularly useful when
            calling application startup from a test environment such as NUnit.
            </remarks>
        </member>
        <member name="T:MKY.Windows.Forms.ComboBoxHelper">
            <summary></summary>
        </member>
        <member name="T:MKY.Windows.Forms.ComboBoxHelper.CursorAndSelection">
            <summary></summary>
        </member>
        <member name="P:MKY.Windows.Forms.ComboBoxHelper.CursorAndSelection.PreviousCursorIsAtEnd">
            <summary>
            Gets or sets whether the previous cursor position is at the end of the editable portion of the combo box.
            </summary>
        </member>
        <member name="P:MKY.Windows.Forms.ComboBoxHelper.CursorAndSelection.PreviousSelectionStart">
            <summary>
            Gets or sets the previous starting index of text selected in the combo box.
            </summary>
        </member>
        <member name="P:MKY.Windows.Forms.ComboBoxHelper.CursorAndSelection.PreviousSelectionLength">
            <summary>
            Gets or sets the previous number of characters selected in the editable portion of the combo box.
            </summary>
        </member>
        <member name="P:MKY.Windows.Forms.ComboBoxHelper.CursorAndSelection.PreviousSelectionSpansEnd">
            <summary>
            Gets or sets whether the previous selection spans to the end of the editable portion of the combo box.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.ComboBoxHelper.CursorAndSelection.Remember(System.Windows.Forms.ComboBox)">
            <summary>
            Remembers the current cursor position and text selection of the specified control.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.ComboBoxHelper.CursorAndSelection.Restore(System.Windows.Forms.ComboBox)">
            <summary>
            Restores the previously remembered cursor position and text selection on the specified control.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.ComboBoxHelper.Select(System.Windows.Forms.ComboBox,System.Object,System.String)">
             <summary>
             Selects the given item in a <see cref="T:System.Windows.Forms.ComboBox"/> while staying in edit,
             i.e. cursor location and text selection is kept.
             </summary>
             <remarks>
             If <paramref name="item"/> is not contained, <see cref="P:System.Windows.Forms.ComboBox.SelectedIndex"/>
             is set to <see cref="F:MKY.Windows.Forms.ControlEx.InvalidIndex"/>. Optionally, the text is set to the
             given <paramref name="fallbackText"/>.
             </remarks>
             <remarks>
             Separate <paramref name="fallbackText"/> need to selectively chose the way the item is
             converted into a string. This can e.g. be an implicit string conversion operator,
             or the item's ToString() method, or something else.
             </remarks>
             <remarks>
             Attention, <see cref="T:System.Windows.Forms.ComboBox"/> objects have a limitation regarding case sensitivity:
             If <see cref="P:System.Windows.Forms.ComboBox.Text"/> is e.g. set to "aa" while <see cref="P:System.Windows.Forms.ComboBox.Items"/>
             contain "AA", that item is wrongly selected.
            
             Issue is documented as YAT bug #347.
             </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ComboBoxHelper.Deselect(System.Windows.Forms.ComboBox)">
            <remarks>
            <see cref="P:System.Windows.Forms.ComboBox.SelectedIndex"/> is set to <see cref="F:MKY.Windows.Forms.ControlEx.InvalidIndex"/>.
            </remarks>
            <remarks>
            Provided for symmetricity with <see cref="M:MKY.Windows.Forms.ComboBoxHelper.Select(System.Windows.Forms.ComboBox,System.Object,System.String)"/> above.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ComboBoxHelper.UpdateTextKeepingCursorAndSelection(System.Windows.Forms.ComboBox,System.String)">
             <summary>
             Updates the text of the <see cref="T:System.Windows.Forms.ComboBox"/> while staying in edit,
             i.e. cursor location and text selection is kept.
             </summary>
             <remarks>
             Attention, <see cref="T:System.Windows.Forms.ComboBox"/> objects have a limitation regarding case sensitivity:
             If <see cref="P:System.Windows.Forms.ComboBox.Text"/> is e.g. set to "abc" while <see cref="P:System.Windows.Forms.ComboBox.Items"/>
             contain "ABC", that item is wrongly selected.
            
             Issue is documented as YAT bug #347.
             </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ComboBoxHelper.UpdateItemsKeepingCursorAndSelection(System.Windows.Forms.ComboBox,System.Object[])">
             <summary>
             Updates the items of the <see cref="T:System.Windows.Forms.ComboBox"/> while staying in edit,
             i.e. cursor location and text selection is kept.
             </summary>
             <remarks>
             Attention, <see cref="T:System.Windows.Forms.ComboBox"/> objects have a limitation regarding case sensitivity:
             If <see cref="P:System.Windows.Forms.ComboBox.Text"/> is e.g. set to "abc" while <see cref="P:System.Windows.Forms.ComboBox.Items"/>
             contain "ABC", that item is wrongly selected.
            
             Issue is documented as YAT bug #347.
             </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ComboBoxHelper.ClearItemsKeepingCursorAndSelection(System.Windows.Forms.ComboBox)">
            <summary>
            Clears the items of the <see cref="T:System.Windows.Forms.ComboBox"/> while staying in edit,
            i.e. cursor location and text selection is kept.
            </summary>
        </member>
        <member name="T:MKY.Windows.Forms.ContextMenuStripShortcutModalFormWorkaround">
             <summary>
             Implementation of a workaround to fix a bug in Windows.Forms. The bug appears when using
             shortcuts in context menus and a dialog is open. Such shortcuts are processed and executed
             even when a modal form is open. An example stack trace demonstrating this issue is shown
             above (out of doc tag due to words not recognized by StyleCop).
            
             It doesn't matter whether the initial dialog has been opened via the context menu shortcut
             workaround below or the main menu as show by the stack trace above. And it doesn't matter
             which dialog is open, it can be reproduced by e.g. opening the "PredefinedCommandSettings"
             or "TerminalSettings", in both cases shortcuts [Shift+F?] or [Ctrl+Shift+ArrowLeft/Right]
             are still executed.
            
             As a consequence:
              > A workaround to this issue cannot be implemented in a simple way, e.g. inherently by
                the <see cref="T:MKY.Windows.Forms.ContextMenuStripShortcutTargetWorkaround"/>.
              > A workaround to this issue can only be implemented by setting and checking a flag at
                each potentially called "ShowDialog" and context menu handler.
             </summary>
             <remarks>
             Note bug #460 "Issues with ContextMenuStripShortcutModalFormWorkaround".
             </remarks>
        </member>
        <member name="P:MKY.Windows.Forms.ContextMenuStripShortcutModalFormWorkaround.IsCurrentlyShowingModalForm">
            <summary>
            Gets a value indicating whether a modal dialog is currently being shown.
            </summary>
            <value>
            <c>true</c> if a modal dialog is currently being shown; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:MKY.Windows.Forms.ContextMenuStripShortcutModalFormWorkaround.EnterModalForm">
            <summary>
            To be called each time before showing a modal dialog using <see cref="M:System.Windows.Forms.Form.ShowDialog(System.Windows.Forms.IWin32Window)"/>.
            </summary>
            <remarks>
            Showing a common dialog using <see cref="M:System.Windows.Forms.CommonDialog.ShowDialog"/> works fine, thus
            no workaround is needed for common dialogs. Also, <see cref="M:System.Windows.Forms.MessageBox.Show(System.String)"/>
            works fine.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ContextMenuStripShortcutModalFormWorkaround.LeaveModalForm">
            <summary>
            To be called each time after showing a modal dialog using <see cref="M:System.Windows.Forms.Form.ShowDialog"/>.
            </summary>
            <remarks>
            Showing a common dialog using <see cref="M:System.Windows.Forms.CommonDialog.ShowDialog"/> works fine, thus
            no workaround is needed for common dialogs. Also, <see cref="M:System.Windows.Forms.MessageBox.Show(System.String)"/>
            works fine.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ContextMenuStripShortcutModalFormWorkaround.InvokeShowDialog(System.Windows.Forms.Form,System.Windows.Forms.IWin32Window)">
            <summary>
            Invokes <see cref="M:System.Windows.Forms.Form.Show(System.Windows.Forms.IWin32Window)"/> on the given form.
            </summary>
        </member>
        <member name="T:MKY.Windows.Forms.ContextMenuStripShortcutTargetWorkaround">
            <summary>
            Implementation of a workaround to fix a bug in Windows.Forms. The bug appears in MDI forms
            when using shortcuts in context menus. Such shortcuts are always passed to the first MDI
            child instead of the active child.
            To workaround this bug, all potential shortcuts shall be collected when creating the form.
            Then, the shortcuts can manually be handled in the <see cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)"/> method.
            </summary>
            <remarks>
            To improve performance, the items are collected in a dictionary, taking the shortcut keys
            as lookup key. Thus, this workaround object needs to be re-created in case shortcut keys
            are changed in a context menu.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ContextMenuStripShortcutTargetWorkaround.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Windows.Forms.ContextMenuStripShortcutTargetWorkaround"/>
            class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.ContextMenuStripShortcutTargetWorkaround.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.Windows.Forms.ContextMenuStripShortcutTargetWorkaround"/>
            class that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">
            The initial number of items that the underlying collection can contain.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="capacity"/>capacity is less than 0.
            </exception>
        </member>
        <member name="M:MKY.Windows.Forms.ContextMenuStripShortcutTargetWorkaround.Add(System.Windows.Forms.ToolStrip)">
            <summary>
            Add a tool strip to the workaround and let its shortcut items get collected.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.ContextMenuStripShortcutTargetWorkaround.Add(System.Windows.Forms.ToolStripMenuItem)">
            <summary>
            Optionally, add an additional menu item.
            </summary>
        </member>
        <member name="P:MKY.Windows.Forms.ContextMenuStripShortcutTargetWorkaround.Count">
            <summary>
            Gets the number of items actually contained in this workaround object.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.ContextMenuStripShortcutTargetWorkaround.ProcessCmdKey(System.Windows.Forms.Keys)">
            <summary>
            Evaluates the shortcuts and invokes the assigned event if a shortcut is
            assigned to the <paramref name="keyData"/>.
            </summary>
            <returns>
            <c>true</c> if a shortcut has been invoked; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:MKY.Windows.Forms.ControlEx">
            <summary>
            <see cref="T:System.Windows.Forms.Control"/> utility methods.
            </summary>
        </member>
        <member name="F:MKY.Windows.Forms.ControlEx.InvalidIndex">
            <summary>
            An invalid index is represented by -1 in <see cref="N:System.Windows.Forms"/> controls.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.ControlEx.CalculateManualCenterParentLocation(System.Windows.Forms.Control,System.Windows.Forms.Control)">
            <summary>
            Manual <see cref="F:System.Windows.Forms.FormStartPosition.CenterParent"/> because automatic doesn't work
            if not shown as dialog.
            </summary>
            <remarks>
            Located here in <see cref="T:MKY.Windows.Forms.ControlEx"/> rather than <see cref="T:MKY.Windows.Forms.FormEx"/> as this method
            takes <see cref="T:System.Windows.Forms.Control"/> objects as arguments.
            </remarks>
            <param name="parent">Parent form.</param>
            <param name="child">Child form to be placed to the center of the parent.</param>
            <returns>Center parent location.</returns>
        </member>
        <member name="M:MKY.Windows.Forms.ControlEx.TagToInt32(System.Object)">
            <summary>
            Converts the tag property of <paramref name="sender"/> into an integer value.
            </summary>
            <param name="sender">Control to retrieve the tag from.</param>
            <returns>
            Value of the tag property of <paramref name="sender"/>.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="sender"/> is not a <see cref="T:System.Windows.Forms.Control"/>.</exception>
            <exception cref="T:System.ArgumentException">The tag property of <paramref name="sender"/> is not a string.</exception>
            <exception cref="T:System.OverflowException">The tag property of <paramref name="sender"/> represents a number less than <see cref="F:System.Int32.MinValue"/> or greater than <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.OverflowException">The tag property of <paramref name="sender"/> includes non-zero, fractional digits.</exception>
        </member>
        <member name="M:MKY.Windows.Forms.ControlEx.SetOrForwardFocus(System.Object)">
            <summary>
            Set focus to <paramref name="sender"/> if that can have the focus; otherwise, focus is
            forwarded to the next possible control.
            </summary>
            <param name="sender">Control to set or forward focus.</param>
            <returns><c>true</c> if focus was set or forwarded, <c>false</c> if failed.</returns>
        </member>
        <member name="M:MKY.Windows.Forms.ControlEx.SuspendUpdate(System.Windows.Forms.Control)">
            <summary>
            Suspends painting of the specified control.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.ControlEx.ResumeUpdate(System.Windows.Forms.Control)">
            <summary>
            Resumes painting of the specified control.
            </summary>
        </member>
        <member name="T:MKY.Windows.Forms.KeysEx">
            <summary>
            <see cref="N:System.Windows.Forms"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.KeysEx.TryConvertFunctionKey(System.Windows.Forms.Keys,System.Int32@)">
            <summary>
            Tries to convert the key data into the according function key value.
            </summary>
            <param name="keyData">A <see cref="T:System.Windows.Forms.Keys"/> value that represents a key.</param>
            <param name="functionKey">The according function key value; 0 if no function key.</param>
            <returns><c>true</c> if key data is a function key; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:MKY.Windows.Forms.LayoutInfo">
            <remarks>
            Must be a reference type to ease handling within the layout dictionary.
            </remarks>
        </member>
        <member name="P:MKY.Windows.Forms.LayoutInfo.Left">
            <summary></summary>
        </member>
        <member name="P:MKY.Windows.Forms.LayoutInfo.Top">
            <summary></summary>
        </member>
        <member name="P:MKY.Windows.Forms.LayoutInfo.Width">
            <summary></summary>
        </member>
        <member name="P:MKY.Windows.Forms.LayoutInfo.Height">
            <summary></summary>
        </member>
        <member name="P:MKY.Windows.Forms.LayoutInfo.FontSize">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.LayoutInfo.#ctor">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.LayoutInfo.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary></summary>
        </member>
        <member name="T:MKY.Windows.Forms.LinkHelper">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.LinkHelper.TryBrowseUriAndShowErrorIfItFails(System.Windows.Forms.IWin32Window,System.Windows.Forms.LinkLabelLinkClickedEventArgs)">
            <summary>
            Clicks the link of the given <see cref="T:System.Windows.Forms.LinkLabel"/>.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.LinkHelper.TryBrowseUriAndShowErrorIfItFails(System.Windows.Forms.IWin32Window,System.String)">
            <summary>
            Clicks the given <paramref name="linkUri"/>.
            </summary>
        </member>
        <member name="T:MKY.Windows.Forms.MenuEx">
            <summary>
            System.Windows.Forms utility methods.
            </summary>
            <remarks>
            This class is intentionally not placed into <c>MKY.Windows.Forms</c> since it's a
            pure utility containing no visual contents.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.MenuEx.PrependIndex(System.Int32,System.String)">
            <summary>
            Convert a menu index into a prependable string, e.g. "1: ".
            Indices will be accessible via ALT + numeric key.
            </summary>
            <remarks>
            Ampersand is used as mark.
            </remarks>
        </member>
        <member name="T:MKY.Windows.Forms.MessageBoxEx">
            <summary>
            This improved version of <see cref="T:System.Windows.Forms.MessageBox"/> implements an RTL (right-to-left)
            aware message box as suggested by FxCop rule CA1300 "Specify MessageBoxOptions" in
            the MSDN at http://msdn.microsoft.com/library/ms182191.aspx.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.MessageBoxEx.Show(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.MessageBoxEx.Show(System.String,System.String,System.Windows.Forms.MessageBoxButtons)">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.MessageBoxEx.Show(System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon)">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.MessageBoxEx.Show(System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon,System.Windows.Forms.MessageBoxDefaultButton)">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.MessageBoxEx.Show(System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon,System.Windows.Forms.MessageBoxDefaultButton,System.Windows.Forms.MessageBoxOptions)">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.MessageBoxEx.Show(System.Windows.Forms.IWin32Window,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.MessageBoxEx.Show(System.Windows.Forms.IWin32Window,System.String,System.String,System.Windows.Forms.MessageBoxButtons)">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.MessageBoxEx.Show(System.Windows.Forms.IWin32Window,System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon)">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.MessageBoxEx.Show(System.Windows.Forms.IWin32Window,System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon,System.Windows.Forms.MessageBoxDefaultButton)">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.MessageBoxEx.Show(System.Windows.Forms.IWin32Window,System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon,System.Windows.Forms.MessageBoxDefaultButton,System.Windows.Forms.MessageBoxOptions)">
            <summary></summary>
        </member>
        <member name="T:MKY.Windows.Forms.ModalBehaviorContractAttribute">
            <summary>
            This <see cref="N:System.Windows.Forms"/> contract attribute can be used to emphasize that a
            method is always or sometimes shown modal. The attribute can then be used to find all modal
            and potentially modal locations within a the application.
            </summary>
            <remarks>
            Sealed to improve performance during reflection on custom attributes according to FxCop:CA1813.
            </remarks>
        </member>
        <member name="P:MKY.Windows.Forms.ModalBehaviorContractAttribute.Behavior">
            <summary></summary>
        </member>
        <member name="P:MKY.Windows.Forms.ModalBehaviorContractAttribute.Approval">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.ModalBehaviorContractAttribute.#ctor(MKY.Windows.Forms.ModalBehavior)">
            <summary></summary>
        </member>
        <member name="T:MKY.Windows.Forms.NativeMessageCallback">
            <summary>
            Native message handler delegate.
            </summary>
            <param name="m">
            A System.Windows.Forms.Message that is associated with the current Windows message.
            </param>
        </member>
        <member name="T:MKY.Windows.Forms.NativeMessageHandler">
            <summary>
            Utility class that simplifies processing native messages. The class acts as an interface
            between consumers of native messages and the main form. The main form is needed to provide
            the window handle. Without this handle, consumers cannot properly register callbacks.
            </summary>
            <remarks>
            This class helps to reduce the coupling among the main form and other parts of the system.
            The main form and the consumer need to access this handler, but they don't need to know of
            each other. Thus, this class implements a simple form of the mediator pattern.
            </remarks>
        </member>
        <member name="P:MKY.Windows.Forms.NativeMessageHandler.MessageSourceIsRegistered">
            <summary>
            Returns whether a message source has previously been registered and this class is ready
            to create handlers.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.NativeMessageHandler.RegisterMainForm(System.Windows.Forms.Form)">
            <remarks>
            Using term "MainForm" same as the argument of the <see cref="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)"/>
            method. Obviously, Windows.Forms uses the concept of a "MainForm".
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.NativeMessageHandler.UnregisterMainForm">
            <remarks>
            Using term "MainForm" same as the argument of the <see cref="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)"/>
            method. Obviously, Windows.Forms uses the concept of a "MainForm".
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.NativeMessageHandler.#ctor(MKY.Windows.Forms.NativeMessageCallback)">
            <remarks>
            Ensure <see cref="P:MKY.Windows.Forms.NativeMessageHandler.MessageSourceIsRegistered"/> returns <c>true</c> before calling this
            constructor; <c>InvalidOperationException</c> will be thrown otherwise.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Thrown if no message source has previously been registered.
            </exception>
        </member>
        <member name="M:MKY.Windows.Forms.NativeMessageHandler.Register(System.Windows.Forms.Form)">
            <remarks>
            Using term 'mainForm' same as the argument of the <see cref="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)"/>
            method. Obviously, Windows.Forms uses the concept of a "MainForm".
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="mainForm"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:MKY.Windows.Forms.NativeMessageHandler.Unregister">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.NativeMessageHandler.Close">
            <remarks>
            Intentionally using the term 'Close' opposed to 'Dispose', to indicate that nothing gets
            free'd but rather this handler gets closed.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.NativeMessageHandler.WndProc(System.Windows.Forms.Message@)">
            <summary>
            Invokes the default window procedure associated with this window.
            </summary>
            <param name="m">
            A System.Windows.Forms.Message that is associated with the current Windows message.
            </param>
        </member>
        <member name="T:MKY.Windows.Forms.OrientationEx">
            <summary>
            Extended enum OrientationEx which extends <see cref="T:System.Windows.Forms.Orientation"/>.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:MKY.Windows.Forms.OrientationEx.Default">
            <summary>Default is <see cref="F:System.Windows.Forms.Orientation.Horizontal"/>.</summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.#ctor">
            <summary>Default is <see cref="F:MKY.Windows.Forms.OrientationEx.Default"/>.</summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.#ctor(System.Windows.Forms.Orientation)">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.TryParse(System.String,MKY.Windows.Forms.OrientationEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.TryParse(System.String,System.Windows.Forms.Orientation@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.SizeToWidthOrHeight(System.Windows.Forms.Control,System.Windows.Forms.Orientation)">
            <summary>
            Gets <see cref="P:System.Windows.Forms.Control.Width"/> or <see cref="P:System.Windows.Forms.Control.Height"/> of <paramref name="control"/>,
            depending on <see cref="P:System.Windows.Forms.SplitContainer.Orientation"/> of <paramref name="orientation"/>.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.SizeToWidthOrHeight(System.Drawing.Size,System.Windows.Forms.Orientation)">
            <summary>
            Gets <see cref="P:System.Drawing.Size.Width"/> or <see cref="P:System.Drawing.Size.Height"/> of <paramref name="size"/>,
            depending on <see cref="P:System.Windows.Forms.SplitContainer.Orientation"/> of <paramref name="orientation"/>.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.SizeToWidthOrHeight(System.Drawing.SizeF,System.Windows.Forms.Orientation)">
            <summary>
            Gets <see cref="P:System.Drawing.SizeF.Width"/> or <see cref="P:System.Drawing.SizeF.Height"/> of <paramref name="size"/>,
            depending on <see cref="P:System.Windows.Forms.SplitContainer.Orientation"/> of <paramref name="orientation"/>.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.op_Implicit(MKY.Windows.Forms.OrientationEx)~System.Windows.Forms.Orientation">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.op_Implicit(System.Windows.Forms.Orientation)~MKY.Windows.Forms.OrientationEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.op_Implicit(MKY.Windows.Forms.OrientationEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.op_Implicit(System.Int32)~MKY.Windows.Forms.OrientationEx">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.op_Implicit(MKY.Windows.Forms.OrientationEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.OrientationEx.op_Implicit(System.String)~MKY.Windows.Forms.OrientationEx">
            <summary></summary>
        </member>
        <member name="T:MKY.Windows.Forms.ScreenEx">
            <summary>
            <see cref="T:System.Windows.Forms.Screen"/> utility methods.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.ScreenEx.IsWithinAnyBounds(System.Drawing.Rectangle)">
            <summary>
            Evaluates whether the given <paramref name="rect"/> is completely located within the
            bounds of any of the screens.
            </summary>
            <param name="rect">The rectangle to be evaluated.</param>
            <returns><c>true</c> if within; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Windows.Forms.ScreenEx.IsWithinAnyWorkingArea(System.Drawing.Rectangle)">
            <summary>
            Evaluates whether the given <paramref name="rect"/> is completely located within the
            working area of any of the screens.
            </summary>
            <param name="rect">The rectangle to be evaluated.</param>
            <returns><c>true</c> if within; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.Windows.Forms.ScreenEx.CalculateLocationWithinWorkingArea(System.Drawing.Point,System.Drawing.Size)">
            <summary>
            Fits the requested rectangle to the screen's working area.
            </summary>
            <param name="location">The location of the requested rectangle.</param>
            <param name="size">The size of the requested rectangle.</param>
            <returns>Location that fits screen.</returns>
        </member>
        <member name="T:MKY.Windows.Forms.SuspendUpdateHelper">
            <summary>
            <see cref="N:System.Windows.Forms"/> utility methods.
            </summary>
            <remarks>
            Struct instead of class to allow same declaration as if this was just a simple bool.
            </remarks>
        </member>
        <member name="P:MKY.Windows.Forms.SuspendUpdateHelper.IsSuspended">
            <summary>
            Gets a value indicating whether the parent of this instance is currently setting the
            values of its <see cref="T:System.Windows.Forms.Control"/> objects.
            </summary>
            <value>
            <c>true</c> if the parent of this instance is setting controls; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:MKY.Windows.Forms.SuspendUpdateHelper.Suspend(System.Windows.Forms.Control)">
            <summary>
            Suspends painting of the specified control.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SuspendUpdateHelper.Resume(System.Windows.Forms.Control)">
            <summary>
            Resumes painting of the specified control.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SuspendUpdateHelper.op_Implicit(MKY.Windows.Forms.SuspendUpdateHelper)~System.Boolean">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.SuspendUpdateHelper.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.SuspendUpdateHelper.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SuspendUpdateHelper.Equals(MKY.Windows.Forms.SuspendUpdateHelper)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SuspendUpdateHelper.op_Equality(MKY.Windows.Forms.SuspendUpdateHelper,MKY.Windows.Forms.SuspendUpdateHelper)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SuspendUpdateHelper.op_Inequality(MKY.Windows.Forms.SuspendUpdateHelper,MKY.Windows.Forms.SuspendUpdateHelper)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.Windows.Forms.SettingControlsHelper">
            <summary>
            <see cref="N:System.Windows.Forms"/> utility methods.
            </summary>
            <remarks>
            Struct instead of class to allow same declaration as if this was just a simple bool.
            </remarks>
        </member>
        <member name="P:MKY.Windows.Forms.SettingControlsHelper.IsSettingControls">
            <summary>
            Gets a value indicating whether the parent of this instance is currently setting the
            values of its <see cref="T:System.Windows.Forms.Control"/> objects.
            </summary>
            <value>
            <c>true</c> if the parent of this instance is setting controls; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:MKY.Windows.Forms.SettingControlsHelper.Enter">
            <summary>
            To be called each time before setting the values of the <see cref="T:System.Windows.Forms.Control"/> objects
            of the parent of this instance.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SettingControlsHelper.Leave">
            <summary>
            To be called each time after setting the values of the <see cref="T:System.Windows.Forms.Control"/> objects
            of the parent of this instance.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SettingControlsHelper.op_Implicit(MKY.Windows.Forms.SettingControlsHelper)~System.Boolean">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.SettingControlsHelper.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.SettingControlsHelper.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SettingControlsHelper.Equals(MKY.Windows.Forms.SettingControlsHelper)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SettingControlsHelper.op_Equality(MKY.Windows.Forms.SettingControlsHelper,MKY.Windows.Forms.SettingControlsHelper)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SettingControlsHelper.op_Inequality(MKY.Windows.Forms.SettingControlsHelper,MKY.Windows.Forms.SettingControlsHelper)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.Windows.Forms.SizeHelper">
            <summary>
            Helper for handling changed DPI settings.
            </summary>
            <remarks>
            Based on https://www.codeproject.com/Tips/786170/Proper-Resizing-of-SplitterContainer-Controls-at-a.
            </remarks>
        </member>
        <member name="P:MKY.Windows.Forms.SizeHelper.Scale">
            <summary>
            Gets or sets the current scale.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SizeHelper.AdjustScale(System.Drawing.SizeF)">
            <summary>
            Adjusts the scale by the given factor.
            </summary>
        </member>
        <member name="T:MKY.Windows.Forms.SplitContainerHelper">
            <summary>
            Properly scales a <see cref="T:System.Windows.Forms.SplitContainer"/> when DPI settings are changed.
            </summary>
            <remarks>
            Based on https://www.codeproject.com/Tips/786170/Proper-Resizing-of-SplitterContainer-Controls-at-a.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.SplitContainerHelper.PerformScaling(System.Windows.Forms.Control)">
            <summary>
            Scales all <see cref="T:System.Windows.Forms.SplitContainer"/> within the specified parent.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SplitContainerHelper.CalculateScaledDistanceFromUnscaled(System.Windows.Forms.SplitContainer,System.Int32)">
            <summary>
            Calculates the scaled splitter distance from the unscaled splitter distance.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SplitContainerHelper.CalculateUnscaledDistanceFromScaled(System.Windows.Forms.SplitContainer,System.Int32)">
            <summary>
            Calculates the scaled splitter distance from the unscaled splitter distance.
            </summary>
        </member>
        <member name="M:MKY.Windows.Forms.SplitContainerHelper.TryLimitSplitterDistance(System.Windows.Forms.SplitContainer,System.Int32,System.Int32@)">
            <summary>
            Limits <paramref name="distance"/> according to the preconditions of the
            <see cref="P:System.Windows.Forms.SplitContainer.SplitterDistance"/> property.
            </summary>
        </member>
        <member name="T:MKY.Windows.Forms.ToolStripMenuItemEx">
            <summary>
            <see cref="T:System.Windows.Forms.ToolStripMenuItem"/> utility methods.
            </summary>
            <remarks>
            Dedicated methods are required because <see cref="T:System.Windows.Forms.ToolStripMenuItem"/> is no <see cref="T:System.Windows.Forms.Control"/>.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ToolStripMenuItemEx.TagToInt32(System.Object)">
            <summary>
            Converts the tag property of <paramref name="sender"/> into an integer value.
            </summary>
            <param name="sender">Control to retrieve the tag from.</param>
            <returns>
            Value of the tag property of <paramref name="sender"/>.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="sender"/> is not a <see cref="T:System.Windows.Forms.Control"/>.</exception>
            <exception cref="T:System.ArgumentException">The tag property of <paramref name="sender"/> is not a string.</exception>
            <exception cref="T:System.OverflowException">The tag property of <paramref name="sender"/> represents a number less than <see cref="F:System.Int32.MinValue"/> or greater than <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.OverflowException">The tag property of <paramref name="sender"/> includes non-zero, fractional digits.</exception>
        </member>
        <member name="T:MKY.Windows.Forms.ToolStripComboBoxHelper">
            <summary></summary>
        </member>
        <member name="M:MKY.Windows.Forms.ToolStripComboBoxHelper.Select(System.Windows.Forms.ToolStripComboBox,System.Object,System.String)">
             <summary>
             Selects the given item in a <see cref="T:System.Windows.Forms.ToolStripComboBox"/> while staying in edit,
             i.e. cursor location and text selection is kept.
             </summary>
             <remarks>
             If <paramref name="item"/> is not contained, <see cref="P:System.Windows.Forms.ComboBox.SelectedIndex"/>
             is set to <see cref="F:MKY.Windows.Forms.ControlEx.InvalidIndex"/>. Optionally, the text is set to the
             given <paramref name="fallbackText"/>.
             </remarks>
             <remarks>
             Separate <paramref name="fallbackText"/> need to selectively chose the way the item is
             converted into a string. This can e.g. be an implicit string conversion operator,
             or the item's ToString() method, or something else.
             </remarks>
             <remarks>
             Attention, <see cref="T:System.Windows.Forms.ComboBox"/> objects have a limitation regarding case sensitivity:
             If <see cref="P:System.Windows.Forms.ComboBox.Text"/> is e.g. set to "aa" while <see cref="P:System.Windows.Forms.ComboBox.Items"/>
             contain "AA", that item is wrongly selected.
            
             Issue is documented as YAT bug #347.
             </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ToolStripComboBoxHelper.Deselect(System.Windows.Forms.ToolStripComboBox)">
            <remarks>
            <see cref="P:System.Windows.Forms.ToolStripComboBox.SelectedIndex"/> is set to <see cref="F:MKY.Windows.Forms.ControlEx.InvalidIndex"/>.
            </remarks>
            <remarks>
            Provided for symmetricity with <see cref="M:MKY.Windows.Forms.ToolStripComboBoxHelper.Select(System.Windows.Forms.ToolStripComboBox,System.Object,System.String)"/> above.
            </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ToolStripComboBoxHelper.UpdateTextKeepingCursorAndSelection(System.Windows.Forms.ToolStripComboBox,System.String)">
             <summary>
             Updates the text of the <see cref="T:System.Windows.Forms.ToolStripComboBox"/> while staying in edit,
             i.e. cursor location and text selection is kept.
             </summary>
             <remarks>
             Attention, <see cref="T:System.Windows.Forms.ComboBox"/> objects have a limitation regarding case sensitivity:
             If <see cref="P:System.Windows.Forms.ComboBox.Text"/> is e.g. set to "abc" while <see cref="P:System.Windows.Forms.ComboBox.Items"/>
             contain "ABC", that item is wrongly selected.
            
             Issue is documented as YAT bug #347.
             </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ToolStripComboBoxHelper.UpdateItemsKeepingCursorAndSelection(System.Windows.Forms.ToolStripComboBox,System.Object[])">
             <summary>
             Updates the items of the <see cref="T:System.Windows.Forms.ToolStripComboBox"/> while staying in edit,
             i.e. cursor location and text selection is kept.
             </summary>
             <remarks>
             Attention, <see cref="T:System.Windows.Forms.ComboBox"/> objects have a limitation regarding case sensitivity:
             If <see cref="P:System.Windows.Forms.ComboBox.Text"/> is e.g. set to "abc" while <see cref="P:System.Windows.Forms.ComboBox.Items"/>
             contain "ABC", that item is wrongly selected.
            
             Issue is documented as YAT bug #347. Issue shall again check after upgrade to .NET 4+.
             </remarks>
        </member>
        <member name="M:MKY.Windows.Forms.ToolStripComboBoxHelper.ClearItemsKeepingCursorAndSelection(System.Windows.Forms.ToolStripComboBox)">
            <summary>
            Clears the items of the <see cref="T:System.Windows.Forms.ToolStripComboBox"/> while staying in edit,
            i.e. cursor location and text selection is kept.
            </summary>
        </member>
        <member name="T:MKY.Xml.Schema.XmlSchemaEx">
            <summary>
            XML schema extensions.
            </summary>
        </member>
        <member name="P:MKY.Xml.Schema.XmlSchemaEx.GuidSchema">
             <summary>
             GUID serialization by default does work, but compiling or saving a schema containing a
             GUID throws an exception (type 'http://microsoft.com/wsdl/types/:guid' is not declared)
             as the GUID type somehow got forgotten in the default /wsdl/types. This XML schema
             provides the missing schema.
             </summary>
             <remarks>
             The code has be taken from the following link:
             http://stackoverflow.com/questions/687884/what-is-the-correct-way-of-using-the-guid-type-in-a-xsd-file
            
             Saying hello to StyleCop ;-.
             </remarks>
             <remarks>
             Must be implemented as property (instead of a readonly) since <see cref="T:System.Xml.Schema.XmlSchema"/>
             is a mutable reference type. Defining a readonly would correctly result in FxCop
             message CA2104 "DoNotDeclareReadOnlyMutableReferenceTypes" (Microsoft.Security).
             </remarks>
        </member>
        <member name="M:MKY.Xml.Schema.XmlSchemaEx.WriteToFile(System.Type,System.String,System.String,System.String)">
            <summary>
            Writes the XML schema of the default document of the given XML document to the given path and file name.
            </summary>
            <remarks>
            If the document contains multiple schemas, multiple files will be saved.
            </remarks>
            <remarks>
            Using UTF-8 encoding with (Windows) or without (Unix, Linux,...) BOM.
            </remarks>
            <param name="type">The type.</param>
            <param name="path">The path.</param>
            <param name="intendedFileNameWithoutExtension">Name of the intended file.</param>
            <param name="fileExtension">Extension of the file.</param>
        </member>
        <member name="M:MKY.Xml.Schema.XmlSchemaEx.WriteToFile(System.Type,System.Text.Encoding,System.String,System.String,System.String)">
            <summary>
            Writes the XML schema of the default document of the given XML document to the given path and file name.
            </summary>
            <remarks>
            If the document contains multiple schemas, multiple files will be saved.
            </remarks>
            <param name="type">The type.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="path">The path.</param>
            <param name="intendedFileNameWithoutExtension">Name of the intended file.</param>
            <param name="fileExtension">Extension of the file.</param>
        </member>
        <member name="M:MKY.Xml.Schema.XmlSchemaEx.WriteToFile(System.Xml.XmlDocument,System.String,System.String,System.String)">
            <summary>
            Writes the XML schema of the given XML document to the given path and file name.
            </summary>
            <remarks>
            If the document contains multiple schemas, multiple files will be saved.
            </remarks>
            <remarks>
            Using UTF-8 encoding with (Windows) or without (Unix, Linux,...) BOM.
            </remarks>
            <param name="document">The document.</param>
            <param name="path">The path.</param>
            <param name="intendedFileNameWithoutExtension">Name of the intended file.</param>
            <param name="fileExtension">Extension of the file.</param>
        </member>
        <member name="M:MKY.Xml.Schema.XmlSchemaEx.WriteToFile(System.Xml.XmlDocument,System.Text.Encoding,System.String,System.String,System.String)">
            <summary>
            Writes the XML schema of the given XML document to the given path and file name.
            </summary>
            <remarks>
            If the document contains multiple schemas, multiple files will be saved.
            </remarks>
            <param name="document">The document.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="path">The path.</param>
            <param name="intendedFileNameWithoutExtension">Name of the intended file.</param>
            <param name="fileExtension">Extension of the file.</param>
        </member>
        <member name="M:MKY.Xml.Schema.XmlSchemaEx.WriteToFile(System.Xml.Schema.XmlSchema,System.String,System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Writes the given XML schema to the given path and file name.
            </summary>
            <remarks>
            If the number of schemas is greater than 1, the effective file name will be postfixed with <paramref name="index"/>.
            </remarks>
            <remarks>
            Using UTF-8 encoding with (Windows) or without (Unix, Linux,...) BOM.
            </remarks>
            <param name="schema">The schema.</param>
            <param name="path">The path.</param>
            <param name="intendedFileNameWithoutExtension">Name of the intended file.</param>
            <param name="count">The number of schemas to save in total.</param>
            <param name="index">The index of the current schema to save.</param>
            <param name="fileExtension">Extension of the file.</param>
        </member>
        <member name="M:MKY.Xml.Schema.XmlSchemaEx.WriteToFile(System.Xml.Schema.XmlSchema,System.Text.Encoding,System.String,System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Writes the given XML schema to the given path and file name.
            </summary>
            <remarks>
            If the number of schemas is greater than 1, the effective file name will be postfixed with <paramref name="index"/>.
            </remarks>
            <param name="schema">The schema.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="path">The path.</param>
            <param name="intendedFileNameWithoutExtension">Name of the intended file.</param>
            <param name="count">The number of schemas to save in total.</param>
            <param name="index">The index of the current schema to save.</param>
            <param name="fileExtension">Extension of the file.</param>
        </member>
        <member name="T:MKY.Xml.Serialization.AlternateTolerantXmlSerializer">
            <summary>
            Extends <see cref="T:MKY.Xml.Serialization.TolerantXmlSerializer"/> such that it is capable to replace XML nodes
            by nodes with an alternate name.
            </summary>
        </member>
        <member name="M:MKY.Xml.Serialization.AlternateTolerantXmlSerializer.#ctor(System.Type,System.Collections.Generic.IEnumerable{MKY.Xml.AlternateXmlElement})">
            <summary></summary>
        </member>
        <member name="M:MKY.Xml.Serialization.AlternateTolerantXmlSerializer.TryToMatchAttribute(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator@)">
            <summary>
            Tries to match a given input attribute to the given output attribute.
            </summary>
            <remarks>
            <see cref="M:MKY.Xml.Serialization.TolerantXmlSerializer.CopyTolerantly(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)"/> on why input must be matched to output and not vice-versa.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.AlternateTolerantXmlSerializer.TryToMatchChild(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator@)">
            <summary>
            Tries to match a given input child to the given output child.
            </summary>
            <remarks>
            <see cref="M:MKY.Xml.Serialization.TolerantXmlSerializer.CopyTolerantly(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)"/> on why input must be matched to output and not vice-versa.
            </remarks>
        </member>
        <member name="T:MKY.Xml.Serialization.TolerantXmlSerializer">
            <summary>
            Provides methods to treat XML serialization more tolerantly than <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </summary>
        </member>
        <member name="M:MKY.Xml.Serialization.TolerantXmlSerializer.#ctor(System.Type)">
            <summary></summary>
        </member>
        <member name="M:MKY.Xml.Serialization.TolerantXmlSerializer.Deserialize(System.Xml.XmlReader)">
            <summary>
            Deserializes the XML document from by the specified input stream. This implementation
            is more tolerant regarding the XML structure than
            <see cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)"/>.
            </summary>
            <remarks>
            For example, it allows that XML elements in the input have a different schema type than
            the required output type. This is pretty handy if a settings file slightly changes over
            time, e.g. an enumerated settings value is replaced by an integer value. In such case,
            <see cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)"/> throws an exception. In contrast, this
            implementation handles the mismatch by simply setting the new value to its default.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.TolerantXmlSerializer.TryToMatchAttribute(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator@)">
            <summary>
            Tries to match a given input attribute to the given output attribute.
            </summary>
            <remarks>
            <see cref="M:MKY.Xml.Serialization.TolerantXmlSerializer.CopyTolerantly(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)"/> on why input must be matched to output and not vice-versa.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.TolerantXmlSerializer.TryToMatchChild(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator@)">
            <summary>
            Tries to match a given input child to the given output child.
            </summary>
            <remarks>
            <see cref="M:MKY.Xml.Serialization.TolerantXmlSerializer.CopyTolerantly(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)"/> on why input must be matched to output and not vice-versa.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.TolerantXmlSerializer.CopyDocumentTolerantly(System.Xml.XmlDocument,System.Xml.XmlDocument)">
            <summary>
            Recursively traverses documents node-by-node and copies compatible nodes.
            </summary>
        </member>
        <member name="M:MKY.Xml.Serialization.TolerantXmlSerializer.CopyTolerantly(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
             <summary>
             Recursively traverses nodes and tries to copy elements that have the same name.
             </summary>
             <remarks>
             This method assumes that both navigators are pointing to an XML node with the same name.
            
             Important:
             Input navigator must be used as the primary navigator to ensure that all elements of
             the input are traversed, including those that are not available/filled on an empty
             XML tree. This is i.e. the case for arrays which are empty by default.
             </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.TolerantXmlSerializer.TryToCopyValue(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
            <summary>
            Tries to copy the value if both navigators are pointing to an element with a compatible type.
            </summary>
        </member>
        <member name="M:MKY.Xml.Serialization.TolerantXmlSerializer.TryToCopyNode(System.Xml.XPath.XPathNavigator,System.Xml.XPath.XPathNavigator)">
            <summary>
            Tries to copy a complete node.
            </summary>
        </member>
        <member name="T:MKY.Xml.Serialization.XmlSerializerEx">
            <summary>
            XML serialization extensions.
            </summary>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.SerializeToFile(System.Type,System.Object,System.String)">
            <remarks>
            Using UTF-8 encoding with (Windows) or without (Unix, Linux,...) BOM.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/> and <see cref="T:System.Object"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.SerializeToFile(System.Type,System.Object,System.String,System.Text.Encoding)">
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/> and <see cref="T:System.Object"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.SerializeToString(System.Type,System.Object,System.IFormatProvider,System.Text.StringBuilder@)">
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/> and <see cref="T:System.Object"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.SerializeToWriter(System.Type,System.Object,System.IO.TextWriter)">
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/> and <see cref="T:System.Object"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.DeserializeFromFile(System.Type,System.String)">
            <remarks>
            Assuming UTF-8 with or without BOM.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.DeserializeFromFile(System.Type,System.String,System.Text.Encoding,System.Boolean)">
            <remarks>
            Not implementable using default arguments because <see cref="P:System.Text.Encoding.UTF8"/> is non-const.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.DeserializeFromString(System.Type,System.String)">
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.DeserializeFromReader(System.Type,System.IO.TextReader)">
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.TolerantDeserializeFromFile(System.Type,System.String)">
            <remarks>
            For details on tolerant serialization <see cref="T:MKY.Xml.Serialization.TolerantXmlSerializer"/>.
            </remarks>
            <remarks>
            Assuming UTF-8 with or without BOM.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.TolerantDeserializeFromFile(System.Type,System.String,System.Text.Encoding,System.Boolean)">
            <remarks>
            For details on tolerant serialization <see cref="T:MKY.Xml.Serialization.TolerantXmlSerializer"/>.
            </remarks>
            <remarks>
            Not implementable using default arguments because <see cref="P:System.Text.Encoding.UTF8"/> is non-const.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.TolerantDeserializeFromString(System.Type,System.String)">
            <remarks>
            For details on tolerant serialization <see cref="T:MKY.Xml.Serialization.TolerantXmlSerializer"/>.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.TolerantDeserializeFromReader(System.Type,System.IO.TextReader)">
            <remarks>
            For details on tolerant serialization <see cref="T:MKY.Xml.Serialization.TolerantXmlSerializer"/>.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.AlternateTolerantDeserializeFromFile(System.Type,System.Collections.Generic.IEnumerable{MKY.Xml.AlternateXmlElement},System.String)">
            <remarks>
            For details on tolerant serialization <see cref="T:MKY.Xml.Serialization.AlternateTolerantXmlSerializer"/>.
            </remarks>
            <remarks>
            Assuming UTF-8 with or without BOM.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.AlternateTolerantDeserializeFromFile(System.Type,System.Collections.Generic.IEnumerable{MKY.Xml.AlternateXmlElement},System.String,System.Text.Encoding,System.Boolean)">
            <remarks>
            For details on tolerant serialization <see cref="T:MKY.Xml.Serialization.AlternateTolerantXmlSerializer"/>.
            </remarks>
            <remarks>
            Not implementable using default arguments because <see cref="P:System.Text.Encoding.UTF8"/> is non-const.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.AlternateTolerantDeserializeFromString(System.Type,System.Collections.Generic.IEnumerable{MKY.Xml.AlternateXmlElement},System.String)">
            <remarks>
            For details on tolerant serialization <see cref="T:MKY.Xml.Serialization.AlternateTolerantXmlSerializer"/>.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.AlternateTolerantDeserializeFromReader(System.Type,System.Collections.Generic.IEnumerable{MKY.Xml.AlternateXmlElement},System.IO.TextReader)">
            <remarks>
            For details on tolerant serialization <see cref="T:MKY.Xml.Serialization.AlternateTolerantXmlSerializer"/>.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/> and <see cref="T:System.Object"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.DeserializeFromFileInsisting(System.Type,System.Collections.Generic.IEnumerable{MKY.Xml.AlternateXmlElement},System.String)">
            <summary>
            This method loads settings from a reader. If the schema of the settings doesn't match,
            this method tries to load the settings using tolerant XML interpretation by making use
            of <see cref="T:MKY.Xml.Serialization.TolerantXmlSerializer"/> or <see cref="T:MKY.Xml.Serialization.AlternateTolerantXmlSerializer"/>.
            </summary>
            <remarks>
            Assuming UTF-8 with or without BOM.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/> and <see cref="T:System.Object"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.DeserializeFromFileInsisting(System.Type,System.Collections.Generic.IEnumerable{MKY.Xml.AlternateXmlElement},System.String,System.Text.Encoding,System.Boolean)">
            <summary>
            This method loads settings from a reader. If the schema of the settings doesn't match,
            this method tries to load the settings using tolerant XML interpretation by making use
            of <see cref="T:MKY.Xml.Serialization.TolerantXmlSerializer"/> or <see cref="T:MKY.Xml.Serialization.AlternateTolerantXmlSerializer"/>.
            </summary>
            <remarks>
            Not implementable using default arguments because <see cref="P:System.Text.Encoding.UTF8"/> is non-const.
            </remarks>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/> and <see cref="T:System.Object"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.DeserializeFromStringInsisting(System.Type,System.Collections.Generic.IEnumerable{MKY.Xml.AlternateXmlElement},System.String)">
            <summary>
            This method loads settings from a reader. If the schema of the settings doesn't match,
            this method tries to load the settings using tolerant XML interpretation by making use
            of <see cref="T:MKY.Xml.Serialization.TolerantXmlSerializer"/> or <see cref="T:MKY.Xml.Serialization.AlternateTolerantXmlSerializer"/>.
            </summary>
            <remarks>
            Using non-generic generic signature using <see cref="T:System.Type"/> and <see cref="T:System.Object"/>
            same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </remarks>
        </member>
        <member name="M:MKY.Xml.Serialization.XmlSerializerEx.DeserializeFromReaderInsisting(System.Type,System.Collections.Generic.IEnumerable{MKY.Xml.AlternateXmlElement},System.IO.TextReader)">
             <summary>
             This method loads settings from a reader. If the schema of the settings doesn't match,
             this method tries to load the settings using tolerant XML interpretation by making use
             of <see cref="T:MKY.Xml.Serialization.TolerantXmlSerializer"/> or <see cref="T:MKY.Xml.Serialization.AlternateTolerantXmlSerializer"/>.
             </summary>
             <remarks>
             There are some issues with tolerant XML interpretation in case of lists. See YAT bug
             #3537940>#232 "Issues with TolerantXmlSerializer" for details. The following solutions
             could fix these issues:
              > Fix these issues in <see cref="T:MKY.Xml.Serialization.TolerantXmlSerializer"/>
              > Implement a different variant of tolerant XML interpretation
                 > Use of the default XML serialization to only process parts of the XML tree
              > Use of SerializationBinder (feature request #3392369)
              > Use of XSLT
                 > Requires that every setting's schema is archived
                 > Requires an incremental XSLT chain from every former schema
                   (Alternatively, an immediate XSLT from every former schema)
            
             Decision 2012-06: For the moment, the current solution is kept, rationale:
              > Creating an XSLT is time consuming for each release
              > Creating an XSLT fully or partly automatically requires an (expensive) tool
              > Current solution isn't perfect but good enough and easy to handle (no efforts)
              > Current solution also works for other software that makes use of MKY or YAT code
            
             Saying hello to StyleCop ;-.
             </remarks>
             <remarks>
             Using non-generic generic signature using <see cref="T:System.Type"/> and <see cref="T:System.Object"/>
             same as <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
             </remarks>
        </member>
        <member name="T:MKY.Xml.AlternateXmlElement">
            <summary></summary>
        </member>
        <member name="P:MKY.Xml.AlternateXmlElement.XmlPath">
            <summary></summary>
        </member>
        <member name="P:MKY.Xml.AlternateXmlElement.LocalName">
            <summary></summary>
        </member>
        <member name="P:MKY.Xml.AlternateXmlElement.AlternateLocalNames">
            <summary></summary>
        </member>
        <member name="M:MKY.Xml.AlternateXmlElement.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary></summary>
        </member>
        <member name="M:MKY.Xml.AlternateXmlElement.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Xml.AlternateXmlElement.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:MKY.Xml.AlternateXmlElement.Equals(MKY.Xml.AlternateXmlElement)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:MKY.Xml.AlternateXmlElement.op_Equality(MKY.Xml.AlternateXmlElement,MKY.Xml.AlternateXmlElement)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:MKY.Xml.AlternateXmlElement.op_Inequality(MKY.Xml.AlternateXmlElement,MKY.Xml.AlternateXmlElement)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:MKY.Xml.IAlternateXmlElementProvider">
            <summary>
            Interface for XML contents that have alternate XML elements, e.g. when an XML element
            has changed its name.
            </summary>
        </member>
        <member name="P:MKY.Xml.IAlternateXmlElementProvider.AlternateXmlElements">
            <summary>
            Alternate XML elements. Applies to any kind of XML nodes.
            </summary>
        </member>
        <member name="T:MKY.Xml.XmlDocumentEx">
            <summary>
            XML document extensions.
            </summary>
        </member>
        <member name="M:MKY.Xml.XmlDocumentEx.LoadFromReader(System.Xml.XmlReader)">
            <summary>
            Reads XML input stream into a document.
            </summary>
        </member>
        <member name="M:MKY.Xml.XmlDocumentEx.SaveToObjectTree(System.Xml.XmlDocument,System.Type)">
            <summary>
            Creates and returns an object tree of the given type from a document.
            </summary>
        </member>
        <member name="M:MKY.Xml.XmlDocumentEx.CreateDefaultDocument(System.Type,System.Xml.Schema.XmlSchema[])">
            <summary>
            Creates and returns the default document of the given type.
            </summary>
            <param name="type">The type to be used.</param>
            <param name="requiredSchema">Schema(s) required in addition to the default schema.</param>
        </member>
        <member name="M:MKY.Xml.XmlDocumentEx.SaveToFile(System.Xml.XmlDocument,System.String,System.String,System.String)">
            <summary>
            Writes the given XML document to the given path and file name.
            </summary>
            <remarks>
            Using UTF-8 encoding with (Windows) or without (Unix, Linux,...) BOM.
            </remarks>
            <remarks>
            Named 'Save' following <see cref="M:System.Xml.XmlDocument.Save(System.String)"/>.
            </remarks>
            <param name="document">The document.</param>
            <param name="path">The path.</param>
            <param name="fileNameWithoutExtension">Name of the intended file.</param>
            <param name="fileExtension">Extension of the file.</param>
        </member>
        <member name="M:MKY.Xml.XmlDocumentEx.SaveToFile(System.Xml.XmlDocument,System.Text.Encoding,System.String,System.String,System.String)">
            <summary>
            Writes the given XML document to the given path and file name.
            </summary>
            <remarks>
            Named 'Save' following <see cref="M:System.Xml.XmlDocument.Save(System.String)"/>.
            </remarks>
            <param name="document">The document.</param>
            <param name="encoding">The character encoding to use.</param>
            <param name="path">The path.</param>
            <param name="fileNameWithoutExtension">Name of the intended file.</param>
            <param name="fileExtension">Extension of the file.</param>
        </member>
        <member name="M:MKY.Xml.XmlDocumentEx.SaveToWriter(System.Xml.XmlDocument,System.IO.TextWriter)">
            <summary>
            Writes the given XML document to the given output writer.
            </summary>
            <remarks>
            Named 'Save' following <see cref="M:System.Xml.XmlDocument.Save(System.String)"/>.
            </remarks>
        </member>
        <member name="T:MKY.ConvertEx">
            <summary></summary>
        </member>
        <member name="M:MKY.ConvertEx.ToHexString(System.Byte)">
            <summary>
            Converts the given values into a hexadecimal string (e.g. "0A").
            </summary>
        </member>
        <member name="M:MKY.ConvertEx.ToHexString(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Converts the given values into a hexadecimal string (e.g. "0A FF 20").
            </summary>
        </member>
        <member name="M:MKY.ConvertEx.ToHexString(System.String,System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Converts the given values into a hexadecimal string (e.g. "0x0A 0xFF 0x20").
            </summary>
        </member>
        <member name="M:MKY.ConvertEx.ToHexString(System.Collections.Generic.IEnumerable{System.Byte},System.String)">
            <summary>
            Converts the given values into a hexadecimal string (e.g. "0Ah FFh 20h").
            </summary>
        </member>
        <member name="T:MKY.EnvironmentEx">
            <summary></summary>
        </member>
        <member name="F:MKY.EnvironmentEx.NewLineConstWorkaround">
            <summary>
            Constant string to use "NewLine" in places where <see cref="P:System.Environment.NewLine"/>
            cannot be used, e.g. in case of attribute arguments.
            </summary>
            <remarks>
            "\n" should be sufficient and work in case of Windows ("\r\n") as well as Unixoids and
            Mac since OS X ("\n"). Other operating systems are not supported by this workaround.
            </remarks>
        </member>
        <member name="P:MKY.EnvironmentEx.IsWindows">
            <summary>
            Returns <c>true</c> if operating system is any Microsoft Windows including CE or Xbox.
            </summary>
        </member>
        <member name="P:MKY.EnvironmentEx.IsStandardWindows">
            <summary>
            Returns <c>true</c> if operating system is Win32 or Win64 or compatible.
            </summary>
        </member>
        <member name="P:MKY.EnvironmentEx.IsStandardWindows64">
            <summary>
            Returns <c>true</c> if operating system is Win64 or compatible.
            </summary>
        </member>
        <member name="P:MKY.EnvironmentEx.IsWindowsVistaOrLater">
            <summary>
            Returns <c>true</c> if operating system is Windows Vista or later.
            </summary>
        </member>
        <member name="P:MKY.EnvironmentEx.IsWindowsXpOrLater">
            <summary>
            Returns <c>true</c> if operating system is Windows XP or later.
            </summary>
        </member>
        <member name="P:MKY.EnvironmentEx.IsWindows98Standard">
            <summary>
            Returns <c>true</c> if operating system is Windows 98 Standard Edition.
            </summary>
        </member>
        <member name="M:MKY.EnvironmentEx.TryGetValueFromEnvironmentVariable(System.String,System.String@)">
            <summary>
            Tries to get value from environment variable.
            </summary>
            <param name="environmentVariableName">Name of the environment variable.</param>
            <param name="result">The resulting value.</param>
        </member>
        <member name="M:MKY.EnvironmentEx.TryGetFilePathFromEnvironmentVariableAndVerify(System.String,System.String@)">
            <summary>
            Tries to get file path from environment variable and verify.
            </summary>
            <param name="environmentVariableName">Name of the environment variable.</param>
            <param name="filePath">The file path.</param>
        </member>
        <member name="M:MKY.EnvironmentEx.TryStartFile(System.String)">
            <summary>
            Tries to open/start the given file with the system's default application.
            </summary>
            <remarks>
            Named 'Start' rather than 'Open' for not confusing with e.g. <see cref="M:System.IO.File.Open(System.String,System.IO.FileMode)"/>.
            </remarks>
            <param name="filePath">File to open/start.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:MKY.EnvironmentEx.TryStartFile(System.String,System.Exception@)">
            <summary>
            Tries to open/start the given file with the system's default application.
            </summary>
            <remarks>
            Named 'Start' rather than 'Open' for not confusing with e.g. <see cref="M:System.IO.File.Open(System.String,System.IO.FileMode)"/>.
            </remarks>
            <param name="filePath">File to open/start.</param>
            <param name="exceptionOnFailure">Exception object, in case of failure.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:MKY.EventHelper">
            <summary>
            Helper to publish events throughout an application or library. Provides the
            <see cref="P:MKY.EventHelper.ExceptionHandling"/> property to configure the runtime behavior.
            </summary>
            <remarks>
            Different patterns to handle events exist, use of such a helper may be questioned given the
            simplified event handling features of modern C#. However, there are also a few goodies in
            using such helper, especially when it comes to shutdown of a system.
            <list type="bullet">
            <item>
            <description>Preventing <see cref="T:System.ComponentModel.InvalidAsynchronousStateException"/></description>
            <![CDATA["Fehler beim Aufrufen der Methode. Der Zielthread ist nicht mehr vorhanden."]]> can
            happen when the sink gets disposed of while an async callback is still pending. Preventing
            this without such helper can be fairly tricky, as all calling back instances within a system
            would have to be notified about a shutdown and then get polled for completion.
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:MKY.EventHelper.EventRaisingMode">
            <summary>
            Flags to configure the event handling mode of the <see cref="T:MKY.EventHelper"/>.
            </summary>
        </member>
        <member name="F:MKY.EventHelper.EventRaisingMode.RaiseAll">
            <summary>
            All events will be raised.
            </summary>
        </member>
        <member name="F:MKY.EventHelper.EventRaisingMode.DiscardMainThread">
            <summary>
            Events on the main thread will be discarded.
            </summary>
            <remarks>
            The main thread can be set by <see cref="M:MKY.Threading.MainThreadHelper.SetCurrentThread"/>.
            </remarks>
        </member>
        <member name="F:MKY.EventHelper.EventRaisingMode.DiscardNonMainThread">
            <summary>
            Events on all non-main threads will be discarded.
            </summary>
            <remarks>
            The main thread can be set by <see cref="M:MKY.Threading.MainThreadHelper.SetCurrentThread"/>.
            </remarks>
        </member>
        <member name="F:MKY.EventHelper.EventRaisingMode.DiscardAll">
            <summary>
            All events will be discarded.
            </summary>
        </member>
        <member name="T:MKY.EventHelper.ExceptionHandlingMode">
            <summary>
            Flags to configure the exception handling mode of the <see cref="T:MKY.EventHelper"/>.
            </summary>
        </member>
        <member name="F:MKY.EventHelper.ExceptionHandlingMode.None">
            <summary>
            All exceptions will be tolerated, i.e. not handled be the helper but rather by
            a <see cref="E:System.AppDomain.UnhandledException"/> or
            <see cref="E:System.Windows.Forms.Application.ThreadException"/> or
            <see cref="E:MKY.EventHelper.UnhandledExceptionOnNonMainThread"/> or
            <see cref="E:MKY.EventHelper.UnhandledExceptionOnMainThread"/> or catch-all handler.
            </summary>
        </member>
        <member name="F:MKY.EventHelper.ExceptionHandlingMode.DiscardMainThread">
            <summary>
            Exceptions on the main thread will be discarded, i.e. will *not* be propagated to
            a <see cref="E:MKY.EventHelper.UnhandledExceptionOnMainThread"/> or catch-all handler.
            Exceptions on all other threads will be rethrown, i.e. may be handled by
            a <see cref="E:MKY.EventHelper.UnhandledExceptionOnNonMainThread"/> or
            <see cref="E:System.Windows.Forms.Application.ThreadException"/> or
            <see cref="E:System.AppDomain.UnhandledException"/> handler.
            </summary>
            <remarks>
            The main thread can be set by <see cref="M:MKY.Threading.MainThreadHelper.SetCurrentThread"/>.
            </remarks>
        </member>
        <member name="F:MKY.EventHelper.ExceptionHandlingMode.DiscardNonMainThread">
            <summary>
            Exceptions on all non-main threads will be discarded, i.e. will *not* be propagated
            to a <see cref="E:System.AppDomain.UnhandledException"/> or
            <see cref="E:System.Windows.Forms.Application.ThreadException"/> or
            <see cref="E:MKY.EventHelper.UnhandledExceptionOnNonMainThread"/> handler.
            Exceptions on the main thread will be rethrown, i.e. may be handled by
            a <see cref="E:MKY.EventHelper.UnhandledExceptionOnMainThread"/> or catch-all handler.
            </summary>
            <remarks>
            The main thread can be set by <see cref="M:MKY.Threading.MainThreadHelper.SetCurrentThread"/>.
            </remarks>
        </member>
        <member name="F:MKY.EventHelper.ExceptionHandlingMode.DiscardDisposedTarget">
            <summary>
            Events that got raised on targets even if <see cref="P:MKY.IDisposableEx.IsUndisposed"/>
            is not indicated likely result in an <see cref="T:System.ObjectDisposedException"/> or even
            a <see cref="T:System.Reflection.TargetInvocationException"/>. It is not possible to discard such events
            upfront, i.e. not raising them at all, since the target could get disposed AFTER the
            check has been done. Therefore this additional option tell the helper whether or not
            to discard such exceptions.
            </summary>
        </member>
        <member name="F:MKY.EventHelper.ExceptionHandlingMode.DiscardAll">
            <summary>
            All exceptions will be discarded, i.e. will neither be propagated
            to a <see cref="E:System.AppDomain.UnhandledException"/> nor
            <see cref="E:System.Windows.Forms.Application.ThreadException"/> nor
            <see cref="E:MKY.EventHelper.UnhandledExceptionOnNonMainThread"/> nor
            <see cref="E:MKY.EventHelper.UnhandledExceptionOnMainThread"/> nor catch-all handler.
            </summary>
        </member>
        <member name="F:MKY.EventHelper.ExceptionHandlingMode.RethrowAll">
            <summary>
            All exceptions will be rethrown, i.e. initially handled be the helper including
            outputting debug information, but then rethrown and handled by
            a <see cref="E:System.AppDomain.UnhandledException"/> or
            <see cref="E:System.Windows.Forms.Application.ThreadException"/> or
            <see cref="E:MKY.EventHelper.UnhandledExceptionOnNonMainThread"/> or
            <see cref="E:MKY.EventHelper.UnhandledExceptionOnMainThread"/> or catch-all handler.
            </summary>
        </member>
        <member name="F:MKY.EventHelper.EventRaisingDefault">
            <summary></summary>
        </member>
        <member name="F:MKY.EventHelper.ExceptionHandlingDefault">
            <summary></summary>
        </member>
        <member name="T:MKY.EventHelper.Item">
            <summary></summary>
        </member>
        <member name="P:MKY.EventHelper.Item.Owner">
            <summary></summary>
        </member>
        <member name="P:MKY.EventHelper.Item.EventRaising">
            <summary></summary>
        </member>
        <member name="P:MKY.EventHelper.Item.ExceptionHandling">
            <summary></summary>
        </member>
        <member name="E:MKY.EventHelper.Item.UnhandledExceptionOnMainThread">
            <summary></summary>
        </member>
        <member name="E:MKY.EventHelper.Item.UnhandledExceptionOnNonMainThread">
            <summary></summary>
        </member>
        <member name="M:MKY.EventHelper.Item.#ctor(MKY.EventHelper.EventRaisingMode,MKY.EventHelper.ExceptionHandlingMode)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.EventHelper.Item"/> class that is by default configured as follows:
             - <see cref="P:MKY.EventHelper.Item.EventRaising"/>: <see cref="F:MKY.EventHelper.EventRaisingMode.RaiseAll"/>.
             - <see cref="P:MKY.EventHelper.Item.ExceptionHandling"/>: <see cref="F:MKY.EventHelper.ExceptionHandlingMode.None"/>.
            </summary>
        </member>
        <member name="M:MKY.EventHelper.Item.#ctor(System.String,MKY.EventHelper.EventRaisingMode,MKY.EventHelper.ExceptionHandlingMode)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.EventHelper.Item"/> class that is by default configured as follows:
             - <see cref="P:MKY.EventHelper.Item.EventRaising"/>: <see cref="F:MKY.EventHelper.EventRaisingMode.RaiseAll"/>.
             - <see cref="P:MKY.EventHelper.Item.ExceptionHandling"/>: <see cref="F:MKY.EventHelper.ExceptionHandlingMode.None"/>.
            </summary>
            <remarks>
            Could be extended such that <paramref name="owner"/> could also be provided as callback method.
            </remarks>
        </member>
        <member name="M:MKY.EventHelper.Item.DiscardAllEvents">
            <remarks>
            Convenience method, identical to setting <see cref="P:MKY.EventHelper.Item.EventRaising"/> to
            <see cref="F:MKY.EventHelper.EventRaisingMode.DiscardAll"/>. Useful e.g. when disposing or
            closing or shutting down objects or the whole application.
            </remarks>
        </member>
        <member name="M:MKY.EventHelper.Item.DiscardAllExceptions">
            <remarks>
            Convenience method, identical to setting <see cref="P:MKY.EventHelper.Item.ExceptionHandling"/> to
            <see cref="F:MKY.EventHelper.ExceptionHandlingMode.DiscardAll"/>. Useful e.g. when disposing or
            closing or shutting down objects or the whole application.
            </remarks>
        </member>
        <member name="M:MKY.EventHelper.Item.DiscardAllEventsAndExceptions">
            <remarks>
            Convenience method, identical to calling <see cref="M:MKY.EventHelper.Item.DiscardAllEvents"/> and
            <see cref="M:MKY.EventHelper.Item.DiscardAllExceptions"/>. Useful e.g. when disposing or closing or
            shutting down objects or the whole application.
            </remarks>
        </member>
        <member name="M:MKY.EventHelper.Item.RaiseSync(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments synchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on the current
            thread.
            </summary>
        </member>
        <member name="M:MKY.EventHelper.Item.RaiseSync``1(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments synchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on the current
            thread.
            </summary>
            <typeparam name="TEventArgs">The type of the EventArgs of the requested event.</typeparam>
        </member>
        <member name="M:MKY.EventHelper.Item.RaiseSync``2(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments synchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on the current
            thread.
            </summary>
            <remarks>
            This overloaded method is provided for backward compatibility with .NET 1.0/1.1 style events.
            </remarks>
            <typeparam name="TEventArgs">The type of the EventArgs of the requested event.</typeparam>
            <typeparam name="TEventHandler">The type of the requested event.</typeparam>
        </member>
        <member name="M:MKY.EventHelper.Item.RaiseAsync(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments asynchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on a thread
            from the thread pool.
            </summary>
        </member>
        <member name="M:MKY.EventHelper.Item.RaiseAsync``1(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments asynchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on a thread
            from the thread pool.
            </summary>
            <typeparam name="TEventArgs">The type of the EventArgs of the requested event.</typeparam>
        </member>
        <member name="M:MKY.EventHelper.Item.RaiseAsync``2(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments asynchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on a thread
            from the thread pool.
            </summary>
            <remarks>
            This overloaded method is provided for backward compatibility with .NET 1.0/1.1 style events.
            </remarks>
            <typeparam name="TEventArgs">The type of the EventArgs of the requested event.</typeparam>
            <typeparam name="TEventHandler">The type of the requested event.</typeparam>
        </member>
        <member name="M:MKY.EventHelper.Item.DebugWriteDisposedTargetAndEventToDebugOutput(System.Delegate)">
            <summary></summary>
        </member>
        <member name="M:MKY.EventHelper.Item.DebugWriteExceptionAndEventToDebugOutput(System.Exception,System.Delegate,System.Boolean,System.Boolean,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:MKY.EventHelper.CreateItem(MKY.EventHelper.EventRaisingMode,MKY.EventHelper.ExceptionHandlingMode)">
            <remarks>
            Creates an <see cref="T:MKY.EventHelper.Item"/> that is by default configured as follows:
             - <see cref="P:MKY.EventHelper.EventRaising"/>: <see cref="F:MKY.EventHelper.EventRaisingMode.RaiseAll"/>.
             - <see cref="P:MKY.EventHelper.ExceptionHandling"/>: <see cref="F:MKY.EventHelper.ExceptionHandlingMode.None"/>.
            </remarks>
        </member>
        <member name="M:MKY.EventHelper.CreateItem(System.String,MKY.EventHelper.EventRaisingMode,MKY.EventHelper.ExceptionHandlingMode)">
            <remarks>
            Creates an <see cref="T:MKY.EventHelper.Item"/> that is by default configured as follows:
             - <see cref="P:MKY.EventHelper.EventRaising"/>: <see cref="F:MKY.EventHelper.EventRaisingMode.RaiseAll"/>.
             - <see cref="P:MKY.EventHelper.ExceptionHandling"/>: <see cref="F:MKY.EventHelper.ExceptionHandlingMode.None"/>.
            </remarks>
            <remarks>
            Could be extended such that <paramref name="owner"/> could also be provided as callback method.
            </remarks>
        </member>
        <member name="E:MKY.EventHelper.UnhandledExceptionOnMainThread">
            <summary></summary>
        </member>
        <member name="E:MKY.EventHelper.UnhandledExceptionOnNonMainThread">
            <summary></summary>
        </member>
        <member name="P:MKY.EventHelper.EventRaising">
            <summary></summary>
        </member>
        <member name="P:MKY.EventHelper.ExceptionHandling">
            <summary></summary>
        </member>
        <member name="M:MKY.EventHelper.DiscardAllEvents">
            <remarks>
            Convenience method, identical to setting <see cref="P:MKY.EventHelper.EventRaising"/> to
            <see cref="F:MKY.EventHelper.EventRaisingMode.DiscardAll"/>. Useful e.g. when disposing or
            closing or shutting down objects or the whole application.
            </remarks>
        </member>
        <member name="M:MKY.EventHelper.DiscardAllExceptions">
            <remarks>
            Convenience method, identical to setting <see cref="P:MKY.EventHelper.ExceptionHandling"/> to
            <see cref="F:MKY.EventHelper.ExceptionHandlingMode.DiscardAll"/>. Useful e.g. when disposing or
            closing or shutting down objects or the whole application.
            </remarks>
        </member>
        <member name="M:MKY.EventHelper.DiscardAllEventsAndExceptions">
            <remarks>
            Convenience method, identical to calling <see cref="M:MKY.EventHelper.DiscardAllEvents"/> and
            <see cref="M:MKY.EventHelper.DiscardAllExceptions"/>. Useful e.g. when disposing or closing or
            shutting down objects or the whole application.
            </remarks>
        </member>
        <member name="M:MKY.EventHelper.RaiseSync(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments synchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on the current
            thread.
            </summary>
        </member>
        <member name="M:MKY.EventHelper.RaiseSync``1(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments synchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on the current
            thread.
            </summary>
            <typeparam name="TEventArgs">The type of the EventArgs of the requested event.</typeparam>
        </member>
        <member name="M:MKY.EventHelper.RaiseSync``2(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments synchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on the current
            thread.
            </summary>
            <remarks>
            This overloaded method is provided for backward compatibility with .NET 1.0/1.1 style events.
            </remarks>
            <typeparam name="TEventArgs">The type of the EventArgs of the requested event.</typeparam>
            <typeparam name="TEventHandler">The type of the requested event.</typeparam>
        </member>
        <member name="M:MKY.EventHelper.RaiseAsync(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments asynchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on a thread from
            the thread pool.
            </summary>
        </member>
        <member name="M:MKY.EventHelper.RaiseAsync``1(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments asynchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on a thread from
            the thread pool.
            </summary>
            <typeparam name="TEventArgs">The type of the EventArgs of the requested event.</typeparam>
        </member>
        <member name="M:MKY.EventHelper.RaiseAsync``2(System.Delegate,System.Object[])">
            <summary>
            Raises event with supplied arguments asynchronously. Event is raised safely,
            exceptions are caught. If an event sink implements <see cref="T:System.ComponentModel.ISynchronizeInvoke"/>,
            the event is invoked on that thread. Otherwise, the event is invoked on a thread from
            the thread pool.
            </summary>
            <remarks>
            This overloaded method is provided for backward compatibility with .NET 1.0/1.1 style events.
            </remarks>
            <typeparam name="TEventArgs">The type of the EventArgs of the requested event.</typeparam>
            <typeparam name="TEventHandler">The type of the requested event.</typeparam>
        </member>
        <member name="T:MKY.EventArgs`1">
             <summary>
             Generic event args with a (simple) type.
             </summary>
             <remarks>
             \remind (2017-07-23 / MKY)
             Attention, do not use this generic type with WinForms controls and forms up to at least
             VS2015 as its designer cannot cope with generic event args! Findings:
              > Designer cannot display the 'SendCommandRequest' of 'SendText' as well as 'Send'.
              > It crashes again and again! But is this indeed the root cause?
            
             \todo
             Check again with VS2017+. If OK, revert 'YAT.View.Controls.SendTextOptionEventArgs'.
             </remarks>
             <typeparam name="T">(Simple) type of the event args.</typeparam>
        </member>
        <member name="P:MKY.EventArgs`1.Value">
            <summary></summary>
        </member>
        <member name="M:MKY.EventArgs`1.#ctor(`0)">
            <summary></summary>
        </member>
        <member name="T:MKY.EventHandlerHelper">
            <summary>
            Provides static methods to help with event handlers.
            </summary>
            <remarks>
            Based on http://www.codeproject.com/Articles/103542/Removing-Event-Handlers-using-Reflection.
            </remarks>
        </member>
        <member name="M:MKY.EventHandlerHelper.GetEventSinks(System.Object,System.String)">
            <summary>
            Gets all event sinks for the given event, or all events if <paramref name="eventName"/>
            is <c>null</c> or <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="obj">The object.</param>
            <param name="eventName">Name of the event.</param>
            <returns>All event sinks for the given object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> must be an object.</exception>
        </member>
        <member name="M:MKY.EventHandlerHelper.RemoveAllEventHandlers(System.Object)">
            <summary>
            Removes all event handlers from the given object.
            </summary>
            <param name="obj">The object.</param>
        </member>
        <member name="M:MKY.EventHandlerHelper.RemoveEventHandler(System.Object,System.String)">
            <summary>
            Removes the event handler.
            </summary>
            <param name="obj">The object.</param>
            <param name="eventName">Name of the event.</param>
        </member>
        <member name="T:MKY.ExceptionHelper">
            <summary>
            Helper to deal with exceptions.
            </summary>
        </member>
        <member name="P:MKY.ExceptionHelper.Owner">
            <summary>
            Gets or sets the owner of this helper object.
            </summary>
        </member>
        <member name="M:MKY.ExceptionHelper.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MKY.ExceptionHelper"/> class.
            </summary>
            <param name="owner">The owner of this helper object.</param>
        </member>
        <member name="M:MKY.ExceptionHelper.IgnoreExceptionType(System.Type)">
            <summary>
            Ignores the given exception type.
            </summary>
        </member>
        <member name="M:MKY.ExceptionHelper.RevertIgnoredExceptionType(System.Type)">
            <summary>
            No longer ignores the given exception type.
            </summary>
        </member>
        <member name="M:MKY.ExceptionHelper.ExceptionTypeIsIgnored(System.Type)">
            <summary>
            Evaluates whether the given <paramref name="type"/> is currently being ignored.
            </summary>
            <remarks>
            Used to prevent that multiple unhandled exceptions also generate multiple unhandled exception dialogs.
            Any exception of the same type of a type that <see cref="M:System.Type.IsAssignableFrom(System.Type)"/> will be ignored.
            </remarks>
        </member>
        <member name="M:MKY.ExceptionHelper.TerminateExceptionIgnoring">
            <summary>
            Terminates the exception ignoring, e.g. during shutdown, or if the user requests to disable it.
            </summary>
        </member>
        <member name="M:MKY.ExceptionHelper.DebugMessage(System.String)">
            <remarks>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with <paramref name="message"/>, and rather than e.g. "Common" for comprehensibility.
            </remarks>
        </member>
        <member name="T:MKY.IDisposableEx">
            <summary></summary>
        </member>
        <member name="P:MKY.IDisposableEx.IsUndisposed">
            <remarks>
            See remarks at <see cref="P:MKY.DisposableBase.IsUndisposed"/>.
            </remarks>
        </member>
        <member name="T:MKY.MessageHelper">
            <summary>
            User message utility methods.
            </summary>
        </member>
        <member name="F:MKY.MessageHelper.InvalidExecutionPreambleDefault">
            <summary>
            The default invalid execution preamble is <![CDATA["Program execution must never get here! "]]>.
            </summary>
            <remarks>
            Note the adjacent space.
            </remarks>
        </member>
        <member name="F:MKY.MessageHelper.RequestSupportDefault">
            <summary>
            The default support request message is <![CDATA["Support may be requested at the origin of this software."]]>.
            </summary>
        </member>
        <member name="F:MKY.MessageHelper.RequestFeatureDefault">
            <summary>
            The default feature request message is <![CDATA["New features may be requested at the origin of this software. Describe your request as detailed as possible (use case or user story, preconditions, postconditions,...)."]]>.
            </summary>
        </member>
        <member name="F:MKY.MessageHelper.RequestChangeDefault">
            <summary>
            The default change request message is <![CDATA["Changes may be requested at the origin of this software. Describe your request as detailed as possible (use case or user story, preconditions, postconditions,...)."]]>.
            </summary>
        </member>
        <member name="F:MKY.MessageHelper.SubmitBugDefault">
            <summary>
            The default bug submission message is <![CDATA["Please report this issue at the origin of this software."]]>.
            </summary>
        </member>
        <member name="P:MKY.MessageHelper.InvalidExecutionPreamble">
            <summary>
            The currently active invalid execution preamble.
            By default <see cref="F:MKY.MessageHelper.InvalidExecutionPreambleDefault"/>.
            </summary>
        </member>
        <member name="P:MKY.MessageHelper.RequestSupport">
            <summary>
            The currently active support request message.
            By default <see cref="F:MKY.MessageHelper.RequestSupportDefault"/>.
            </summary>
        </member>
        <member name="P:MKY.MessageHelper.RequestFeature">
            <summary>
            The currently active feature request message.
            By default <see cref="F:MKY.MessageHelper.RequestFeatureDefault"/>.
            </summary>
        </member>
        <member name="P:MKY.MessageHelper.RequestChange">
            <summary>
            The currently active change request message.
            By default <see cref="F:MKY.MessageHelper.RequestChangeDefault"/>.
            </summary>
        </member>
        <member name="P:MKY.MessageHelper.SubmitBug">
            <summary>
            The currently active bug submission message.
            By default <see cref="F:MKY.MessageHelper.SubmitBugDefault"/>.
            </summary>
        </member>
        <member name="T:MKY.UnusedEvent">
            <summary></summary>
        </member>
        <member name="M:MKY.UnusedEvent.PreventCompilerWarning(System.EventHandler,System.String)">
             <summary>
             Utility method that can be applied to unused events to prevent compiler warnings.
             </summary>
             <remarks>
             <paramref name="justification"/> is mandatory, same as SA1404:CSharp.Maintainability
             "A Code Analysis suppression must contain a non-empty justification describing the
             reason for the suppression."
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.UnusedEvent.PreventCompilerWarning``1(System.EventHandler{``0},System.String)">
             <summary>
             Utility method that can be applied to unused events to prevent compiler warnings.
             </summary>
             <remarks>
             <paramref name="justification"/> is mandatory, same as SA1404:CSharp.Maintainability
             "A Code Analysis suppression must contain a non-empty justification describing the
             reason for the suppression."
            
             Saying hello to StyleCop ;-.
             </remarks>
             <typeparam name="T">The type of the generic event handler.</typeparam>
        </member>
        <member name="T:MKY.UnusedArg">
            <summary></summary>
        </member>
        <member name="M:MKY.UnusedArg.PreventCompilerWarning(System.Object,System.String)">
             <summary>
             Utility method that can be applied to unused arguments to prevent compiler warnings.
             </summary>
             <remarks>
             <paramref name="justification"/> is mandatory, same as SA1404:CSharp.Maintainability
             "A Code Analysis suppression must contain a non-empty justification describing the
             reason for the suppression."
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.UnusedArg.PreventAnalysisWarning(System.Object,System.String)">
            <summary>
            Utility method that can be applied to unused arguments to prevent code analysis warnings (e.g. FxCop).
            </summary>
            <remarks>
            Prevents FxCop "CA1801:ReviewUnusedParameters".
            </remarks>
            <remarks>
            <paramref name="justification"/> is mandatory, same as SA1404:CSharp.Maintainability
            "A Code Analysis suppression must contain a non-empty justification describing the
            reason for the suppression."
            </remarks>
        </member>
        <member name="T:MKY.UnusedLocal">
            <summary></summary>
        </member>
        <member name="M:MKY.UnusedLocal.PreventCompilerWarning(System.Object,System.String)">
             <summary>
             Utility method that can be applied to unused local variables to prevent compiler warnings.
             </summary>
             <remarks>
             <paramref name="justification"/> is mandatory, same as SA1404:CSharp.Maintainability
             "A Code Analysis suppression must contain a non-empty justification describing the
             reason for the suppression."
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:MKY.UnusedLocal.PreventAnalysisWarning(System.Object,System.String)">
            <summary>
            Utility method that can be applied to unused local variables to prevent code analysis warnings (e.g. FxCop).
            </summary>
            <remarks>
            Prevents FxCop "CA1804:RemoveUnusedLocals".
            </remarks>
            <remarks>
            <paramref name="justification"/> is mandatory, same as SA1404:CSharp.Maintainability
            "A Code Analysis suppression must contain a non-empty justification describing the
            reason for the suppression."
            </remarks>
        </member>
        <member name="T:MKY.UnusedField">
            <summary></summary>
        </member>
        <member name="M:MKY.UnusedField.PreventCompilerWarning``1(``0@,System.String)">
             <summary>
             Utility method that can be applied to unused fields to prevent compiler warnings.
             </summary>
             <remarks>
             <paramref name="justification"/> is mandatory, same as SA1404:CSharp.Maintainability
             "A Code Analysis suppression must contain a non-empty justification describing the
             reason for the suppression."
            
             Saying hello to StyleCop ;-.
             </remarks>
             <typeparam name="T">The type of the object.</typeparam>
        </member>
    </members>
</doc>
