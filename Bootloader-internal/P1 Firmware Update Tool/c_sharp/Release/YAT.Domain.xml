<?xml version="1.0"?>
<doc>
    <assembly>
        <name>YAT.Domain</name>
    </assembly>
    <members>
        <member name="T:YAT.Domain.BinaryTerminal">
            <remarks>
            This partial class implements the process part of <see cref="T:YAT.Domain.BinaryTerminal"/>.
            </remarks>
            <remarks>
            This partial class implements the send part of <see cref="T:YAT.Domain.BinaryTerminal"/>.
            </remarks>
            <summary>
            <see cref="T:YAT.Domain.Terminal"/> implementation with binary semantics.
            </summary>
            <remarks>
            This class is implemented using partial classes separating sending/processing functionality.
            Using partial classes rather than aggregated sender, processor,... so far for these reasons:
            <list type="bullet">
            <item><description>Simpler for implementing text/binary specialization.</description></item>
            <item><description>Simpler for implementing synchronization among Tx and Rx.</description></item>
            <item><description>Less simple-stupid-forwarder, e.g. directly raising events.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.InitializeProcess">
            <remarks>
            <c>private</c> rather than <c>protected override</c> because method depends on code
            sequence in constructors.
            </remarks>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.ResetProcess(YAT.Domain.RepositoryType)">
            <summary>
            Resets the processing state for the given <paramref name="repositoryType"/>.
            </summary>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.GetBinaryUnidirState(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <remarks>
            This method shall not be overridden as it accesses the private members
            <see cref="F:YAT.Domain.BinaryTerminal.binaryTxState"/>, <see cref="F:YAT.Domain.BinaryTerminal.binaryRxState"/>,
            <see cref="F:YAT.Domain.BinaryTerminal.binaryBidirTxState"/>, <see cref="F:YAT.Domain.BinaryTerminal.binaryBidirRxState"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.ProcessByteOfChunk(YAT.Domain.RepositoryType,System.Byte,System.DateTime,System.String,YAT.Domain.IODirection,System.Boolean,System.Boolean,YAT.Domain.DisplayElementCollection@,YAT.Domain.DisplayLineCollection@,System.Boolean@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.DoLineContentCheck(YAT.Domain.RepositoryType,YAT.Domain.ProcessState,System.DateTime,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.DoLineBegin(YAT.Domain.RepositoryType,YAT.Domain.ProcessState,System.DateTime,System.String,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.DoLineEnd(YAT.Domain.RepositoryType,YAT.Domain.ProcessState,System.DateTime,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection@,YAT.Domain.DisplayLineCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.ProcessInLineKeywords(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.Parser.KeywordResult,System.Collections.Generic.Queue{System.Byte},System.Boolean@,System.Boolean@)">
            <remarks>Shall not be called if keywords are disabled.</remarks>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.DoSendFileItem(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.FileSendItem)">
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.DoSendBinaryFileItem(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.FileSendItem)">
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.#ctor(YAT.Domain.Settings.TerminalSettings)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.#ctor(YAT.Domain.Settings.TerminalSettings,YAT.Domain.Terminal)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:YAT.Domain.BinaryTerminal.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="P:YAT.Domain.BinaryTerminal.BinaryTerminalSettings">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.BinaryTerminal.TxSequenceBefore">
            <summary>
            Gets the Tx sequence before.
            </summary>
        </member>
        <member name="P:YAT.Domain.BinaryTerminal.RxSequenceBefore">
            <summary>
            Gets the Rx sequence before.
            </summary>
        </member>
        <member name="P:YAT.Domain.BinaryTerminal.TxSequenceAfter">
            <summary>
            Gets the Tx sequence after.
            </summary>
        </member>
        <member name="P:YAT.Domain.BinaryTerminal.RxSequenceAfter">
            <summary>
            Gets the Rx sequence after.
            </summary>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.TryParse(System.String,YAT.Domain.Radix,YAT.Domain.Parser.Mode,YAT.Domain.Parser.Result[]@,System.String@)">
            <summary>
            Tries to parse <paramref name="s"/>, taking the current settings into account.
            </summary>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.TryParse(System.String,YAT.Domain.Radix,System.Byte[]@)">
            <summary>
            Tries to parse <paramref name="s"/>, taking the current settings into account.
            </summary>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.RemoveFraming(System.Byte[])">
            <summary>
            Removes the framing from the given data.
            </summary>
            <remarks>
            For text terminals, framing is typically defined by EOL.
            For binary terminals, framing is optionally defined by sequence before/after.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The Tx and/or Rx <see cref="P:YAT.Domain.Settings.BinaryDisplaySettings.SequenceLineBreakBefore"/> and
            <see cref="P:YAT.Domain.Settings.BinaryDisplaySettings.SequenceLineBreakAfter"/> have different values.
            </exception>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.RemoveFraming(System.Byte[],YAT.Domain.IODirection)">
            <summary>
            Removes the framing from the given data.
            </summary>
            <remarks>
            For text terminals, framing is typically defined by EOL.
            For binary terminals, framing is optionally defined by sequence before/after.
            </remarks>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.RemoveFraming(System.Byte[],System.Boolean,System.Byte[],System.Boolean,System.Byte[])">
            <summary>
            Removes the framing from the given data.
            </summary>
            <remarks>
            For text terminals, framing is typically defined by EOL.
            For binary terminals, framing is optionally defined by sequence before/after.
            </remarks>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.GetBinaryDisplaySettings(YAT.Domain.IODirection)">
            <remarks>
            This method shall not be overridden as it accesses the quasi-private member
            <see cref="P:YAT.Domain.BinaryTerminal.BinaryTerminalSettings"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.BinaryTerminal.ToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.BinaryTerminal.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="T:YAT.Domain.BinaryUnidirState">
            <remarks>
            So far, only unidirectional state must be kept. Opposed to <see cref="T:YAT.Domain.ProcessState"/> which
            is kept three times (Tx/Bidir/Rx), the binary terminal specific state is limited to a "line"
            state which is instantiated four times (Tx/TxBidir/RxBidir/Rx), "line" meaning "display line".
            </remarks>
            <remarks>
            Ideas for potential future refinement of this class:
            <list type="bullte">
            <item><description>Migrate this class to a "BinaryProcessState". Difficulty: Bidir requires an aggregated state.</description></item>
            <item><description>Split into "BinaryUnidirState" and "BinaryBidirState" classes.</description></item>
            <item><description>Add a "BinaryOverallState" in addition to this class.</description></item>
            <item><description>...</description></item>
            </list>
            State shall be renamed or migrated or whatever when meeting the need to do so.
            </remarks>
        </member>
        <member name="P:YAT.Domain.BinaryUnidirState.SequenceBefore">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.BinaryUnidirState.SequenceAfter">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.BinaryUnidirState.SequenceBeforeOfGivenDevice">
            <remarks>
            To be preserved across lines, because sequence break also applies on active chunk or timed line break.
            </remarks>
        </member>
        <member name="P:YAT.Domain.BinaryUnidirState.SequenceAfterOfGivenDevice">
            <remarks>
            To be preserved across lines, because sequence break also applies on active chunk or timed line break.
            </remarks>
        </member>
        <member name="P:YAT.Domain.BinaryUnidirState.RetainedUnconfirmedHiddenSequenceBeforeElements">
            <remarks>Must not be a <see cref="T:YAT.Domain.DisplayElementCollection"/> to prevent elements from being appended/merged.</remarks>
        </member>
        <member name="M:YAT.Domain.BinaryUnidirState.#ctor(System.Byte[],System.Byte[])">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.BinaryUnidirState.InitializeValues">
            <summary>
            Initializes the state.
            </summary>
        </member>
        <member name="M:YAT.Domain.BinaryUnidirState.Reset">
            <summary>
            Resets the state, i.e. restarts processing with an empty repository.
            </summary>
        </member>
        <member name="T:YAT.Domain.ProcessTimeout">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.ProcessTimeout.eventHelper">
            <summary>
            A dedicated event helper to allow discarding exceptions when object got disposed.
            </summary>
        </member>
        <member name="E:YAT.Domain.ProcessTimeout.Elapsed">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.ProcessTimeout.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.ProcessTimeout.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:YAT.Domain.ProcessTimeout.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="M:YAT.Domain.ProcessTimeout.Start(System.DateTime)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="at"/> is <see cref="F:System.DateTime.MinValue"/> or <see cref="F:System.DateTime.MaxValue"/>.
            </exception>
        </member>
        <member name="M:YAT.Domain.ProcessTimeout.ToDueTime(System.DateTime)">
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="at"/> is <see cref="F:System.DateTime.MinValue"/> or <see cref="F:System.DateTime.MaxValue"/>.
            </exception>
        </member>
        <member name="M:YAT.Domain.ProcessTimeout.Stop">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.ProcessTimeout.OnElapsed(MKY.EventArgs{System.DateTime})">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Settings.BinaryDisplaySettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.BinaryDisplaySettings.ChunkLineBreakEnabledDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.BinaryDisplaySettings.LengthLineBreakLengthDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.BinaryDisplaySettings.LengthLineBreakDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.BinaryDisplaySettings.SequenceLineBreakBeforeDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.BinaryDisplaySettings.SequenceLineBreakAfterDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.BinaryDisplaySettings.TimedLineBreakTimeoutDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.BinaryDisplaySettings.TimedLineBreakDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryDisplaySettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryDisplaySettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryDisplaySettings.#ctor(YAT.Domain.Settings.BinaryDisplaySettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryDisplaySettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.BinaryDisplaySettings.ChunkLineBreakEnabled">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.BinaryDisplaySettings.LengthLineBreak">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.BinaryDisplaySettings.SequenceLineBreakBefore">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.BinaryDisplaySettings.SequenceLineBreakAfter">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.BinaryDisplaySettings.TimedLineBreak">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryDisplaySettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryDisplaySettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryDisplaySettings.Equals(YAT.Domain.Settings.BinaryDisplaySettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryDisplaySettings.op_Equality(YAT.Domain.Settings.BinaryDisplaySettings,YAT.Domain.Settings.BinaryDisplaySettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryDisplaySettings.op_Inequality(YAT.Domain.Settings.BinaryDisplaySettings,YAT.Domain.Settings.BinaryDisplaySettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.BinarySequenceSettingTuple">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.BinarySequenceSettingTuple.Enabled">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.BinarySequenceSettingTuple.Sequence">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinarySequenceSettingTuple.#ctor(System.Boolean,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinarySequenceSettingTuple.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BinarySequenceSettingTuple.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinarySequenceSettingTuple.Equals(YAT.Domain.Settings.BinarySequenceSettingTuple)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BinarySequenceSettingTuple.op_Equality(YAT.Domain.Settings.BinarySequenceSettingTuple,YAT.Domain.Settings.BinarySequenceSettingTuple)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinarySequenceSettingTuple.op_Inequality(YAT.Domain.Settings.BinarySequenceSettingTuple,YAT.Domain.Settings.BinarySequenceSettingTuple)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.CharActionSettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.CharActionSettings.BeepOnBellDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharActionSettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharActionSettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharActionSettings.#ctor(YAT.Domain.Settings.CharActionSettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.CharActionSettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.CharActionSettings.BeepOnBell">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharActionSettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.CharActionSettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharActionSettings.Equals(YAT.Domain.Settings.CharActionSettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.CharActionSettings.op_Equality(YAT.Domain.Settings.CharActionSettings,YAT.Domain.Settings.CharActionSettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharActionSettings.op_Inequality(YAT.Domain.Settings.CharActionSettings,YAT.Domain.Settings.CharActionSettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.CharHideSettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.CharHideSettings.HideXOnXOffDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.CharHideSettings.Hide0x00Default">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.CharHideSettings.Hide0xFFDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharHideSettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharHideSettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharHideSettings.#ctor(YAT.Domain.Settings.CharHideSettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.CharHideSettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.CharHideSettings.HideXOnXOff">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.CharHideSettings.Hide0x00">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.CharHideSettings.Hide0xFF">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharHideSettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.CharHideSettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharHideSettings.Equals(YAT.Domain.Settings.CharHideSettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.CharHideSettings.op_Equality(YAT.Domain.Settings.CharHideSettings,YAT.Domain.Settings.CharHideSettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharHideSettings.op_Inequality(YAT.Domain.Settings.CharHideSettings,YAT.Domain.Settings.CharHideSettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.CharReplaceSettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.CharReplaceSettings.ReplaceControlCharsDefault">
            <remarks>
            Default is <see cref="F:YAT.Domain.Settings.CharReplaceSettings.ReplaceControlCharsBinaryDefault"/> as its value of
            <c>false</c> is less intrusive.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Settings.CharReplaceSettings.ReplaceControlCharsTextDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.CharReplaceSettings.ReplaceControlCharsBinaryDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.CharReplaceSettings.ControlCharRadixDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.CharReplaceSettings.ReplaceBackspaceDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.CharReplaceSettings.ReplaceTabDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.CharReplaceSettings.ReplaceSpaceDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.CharReplaceSettings.SpaceReplaceChar">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharReplaceSettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharReplaceSettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharReplaceSettings.#ctor(YAT.Domain.Settings.CharReplaceSettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.CharReplaceSettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.CharReplaceSettings.ReplaceControlChars">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.CharReplaceSettings.ControlCharRadix">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.CharReplaceSettings.ReplaceBackspace">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.CharReplaceSettings.ReplaceTab">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.CharReplaceSettings.ReplaceSpace">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharReplaceSettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.CharReplaceSettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharReplaceSettings.Equals(YAT.Domain.Settings.CharReplaceSettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.CharReplaceSettings.op_Equality(YAT.Domain.Settings.CharReplaceSettings,YAT.Domain.Settings.CharReplaceSettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.CharReplaceSettings.op_Inequality(YAT.Domain.Settings.CharReplaceSettings,YAT.Domain.Settings.CharReplaceSettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.SendSettingsText">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettingsText.KeepSendTextDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettingsText.SendImmediatelyDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettingsText.EnableEscapesDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsText.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsText.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsText.#ctor(YAT.Domain.Settings.SendSettingsText)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsText.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettingsText.KeepSendText">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettingsText.SendImmediately">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettingsText.EnableEscapes">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsText.ToParseMode">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsText.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsText.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsText.Equals(YAT.Domain.Settings.SendSettingsText)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsText.op_Equality(YAT.Domain.Settings.SendSettingsText,YAT.Domain.Settings.SendSettingsText)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsText.op_Inequality(YAT.Domain.Settings.SendSettingsText,YAT.Domain.Settings.SendSettingsText)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.StatusSettings">
            <remarks>
            The settings 'ShowConnectTime' and 'ShowCounters' were initially located in
            <see cref="T:YAT.Domain.Settings.DisplaySettings"/>. They were relocated here to better differentiate between
            settings that need a reload of the monitors and those which don't, i.e. those below.
            Now it is possible to show/hide the status labels without reloading the monitors, thus
            saving time, especially in case of large data.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Settings.StatusSettings.ShowConnectTimeDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.StatusSettings.ShowCountAndRateDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.StatusSettings.ShowFlowControlCountDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.StatusSettings.ShowBreakCountDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.StatusSettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.StatusSettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.StatusSettings.#ctor(YAT.Domain.Settings.StatusSettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.StatusSettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.StatusSettings.ShowConnectTime">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.StatusSettings.ShowCountAndRate">
            <summary></summary>
            <remarks>Data count is singular even that there is a count per direction.</remarks>
        </member>
        <member name="P:YAT.Domain.Settings.StatusSettings.ShowFlowControlCount">
            <summary></summary>
            <remarks>Signal count is singular even that there are multiple counts per port.</remarks>
        </member>
        <member name="P:YAT.Domain.Settings.StatusSettings.ShowBreakCount">
            <summary></summary>
            <remarks>Break count is singular even that there are multiple counts per port.</remarks>
        </member>
        <member name="M:YAT.Domain.Settings.StatusSettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.StatusSettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.StatusSettings.Equals(YAT.Domain.Settings.StatusSettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.StatusSettings.op_Equality(YAT.Domain.Settings.StatusSettings,YAT.Domain.Settings.StatusSettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.StatusSettings.op_Inequality(YAT.Domain.Settings.StatusSettings,YAT.Domain.Settings.StatusSettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.IOSettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.IOSettings.IOTypeDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.IOSettings.EndiannessDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.IOSettings.IndicateSerialPortBreakStatesDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.IOSettings.SerialPortOutputBreakIsModifiableDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.IOSettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.IOSettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.IOSettings.#ctor(YAT.Domain.Settings.IOSettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.IOSettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.IOType">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.SerialPort">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.Socket">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.UsbSerialHidDevice">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.Endianness">
            <remarks>
            \remind (2017-12-11 / MKY)
            The endianness is currently fixed to 'Big-Endian (Network, Motorola)'.
            It was used by former versions of YAT but is currently not used anymore.
            Still, the setting is kept for future enhancements as documented in bug #343.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.IndicateSerialPortBreakStates">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.SerialPortOutputBreakIsModifiable">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.IOTypeIsSocket">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.IOTypeIsTcpSocket">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.IOTypeIsUdpSocket">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.IOTypeIsServerSocket">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.ApproximateTypicalNumberOfBytesPerMillisecond">
             <remarks>
             Value is approximate! It may be off by a factor of 2..5, depending on environment and I/O related settings!
            
             Saying hello to StyleCop ;-.
             </remarks>
             <remarks>
             Named "Bytes" rather than "Octets" as that is more common, and .NET uses "Byte" as well.
             </remarks>
             <remarks>
             Named this long to make inaccuracy obvious.
             </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.CalculatedApproximateTypicalNumberOfBytesPerMillisecond_SerialPort">
             <remarks>
             Value is approximate! It may be off by a factor of 2..5, depending on environment and I/O related settings!
            
             Saying hello to StyleCop ;-.
             </remarks>
             <remarks>
             Named "Bytes" rather than "Octets" as that is more common, and .NET uses "Byte" as well.
             </remarks>
             <remarks>
             Named this long to make inaccuracy obvious.
             </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.SupportsHideXOnXOff">
            <summary>
            Hiding XOn/XOff only makes sense for I/O where XOn/XOff is known to be used.
            </summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.FlowControlIsInUse">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.FlowControlUsesXOnXOff">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.FlowControlManagesXOnXOffManually">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.FlowControlUsesXOnXOffAutomatically">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.IOSettings.SignalXOnWhenOpened">
            <remarks>Intentionally not orthogonal, returning <c>false</c> on get but throwing on set.</remarks>
        </member>
        <member name="M:YAT.Domain.Settings.IOSettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.IOSettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.IOSettings.Equals(YAT.Domain.Settings.IOSettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.IOSettings.ToShortIOString">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.IOSettings.op_Equality(YAT.Domain.Settings.IOSettings,YAT.Domain.Settings.IOSettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.IOSettings.op_Inequality(YAT.Domain.Settings.IOSettings,YAT.Domain.Settings.IOSettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.LengthSettingTuple">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.LengthSettingTuple.Enabled">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.LengthSettingTuple.Length">
            <summary>In chars or bytes.</summary>
        </member>
        <member name="M:YAT.Domain.Settings.LengthSettingTuple.#ctor(System.Boolean,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.LengthSettingTuple.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.LengthSettingTuple.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.LengthSettingTuple.Equals(YAT.Domain.Settings.LengthSettingTuple)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.LengthSettingTuple.op_Equality(YAT.Domain.Settings.LengthSettingTuple,YAT.Domain.Settings.LengthSettingTuple)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.LengthSettingTuple.op_Inequality(YAT.Domain.Settings.LengthSettingTuple,YAT.Domain.Settings.LengthSettingTuple)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.TimeoutSettingTuple">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TimeoutSettingTuple.Enabled">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TimeoutSettingTuple.Timeout">
            <summary>Time-out in milliseconds.</summary>
        </member>
        <member name="M:YAT.Domain.Settings.TimeoutSettingTuple.#ctor(System.Boolean,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TimeoutSettingTuple.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TimeoutSettingTuple.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TimeoutSettingTuple.Equals(YAT.Domain.Settings.TimeoutSettingTuple)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TimeoutSettingTuple.op_Equality(YAT.Domain.Settings.TimeoutSettingTuple,YAT.Domain.Settings.TimeoutSettingTuple)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TimeoutSettingTuple.op_Inequality(YAT.Domain.Settings.TimeoutSettingTuple,YAT.Domain.Settings.TimeoutSettingTuple)">
            <summary>
            Determines whether the two specified objects have inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.PeriodicSettingTuple">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.PeriodicSettingTuple.Enabled">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.PeriodicSettingTuple.Interval">
            <summary>Interval of reconnect in milliseconds.</summary>
        </member>
        <member name="M:YAT.Domain.Settings.PeriodicSettingTuple.#ctor(System.Boolean,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.PeriodicSettingTuple.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.PeriodicSettingTuple.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.PeriodicSettingTuple.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.PeriodicSettingTuple.Equals(YAT.Domain.Settings.PeriodicSettingTuple)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.PeriodicSettingTuple.op_Equality(YAT.Domain.Settings.PeriodicSettingTuple,YAT.Domain.Settings.PeriodicSettingTuple)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.PeriodicSettingTuple.op_Inequality(YAT.Domain.Settings.PeriodicSettingTuple,YAT.Domain.Settings.PeriodicSettingTuple)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.SendSettingsFile">
            <remarks>
            Named 'SendSettingsFile' instead of 'SendFileSettings' to prevent XML invalid operation
            exception "type 'A.X' and 'B.X' use the XML type name 'X' in namespace" when reflecting the
            settings.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettingsFile.SkipEmptyLinesDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettingsFile.EnableEscapesDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsFile.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsFile.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsFile.#ctor(YAT.Domain.Settings.SendSettingsFile)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsFile.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettingsFile.SkipEmptyLines">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettingsFile.EnableEscapes">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsFile.ToParseMode">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsFile.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsFile.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsFile.Equals(YAT.Domain.Settings.SendSettingsFile)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsFile.op_Equality(YAT.Domain.Settings.SendSettingsFile,YAT.Domain.Settings.SendSettingsFile)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettingsFile.op_Inequality(YAT.Domain.Settings.SendSettingsFile,YAT.Domain.Settings.SendSettingsFile)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.TextDisplaySettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextDisplaySettings.ChunkLineBreakEnabledDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextDisplaySettings.LengthLineBreakLengthDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextDisplaySettings.LengthLineBreakDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextDisplaySettings.TimedLineBreakTimeoutDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextDisplaySettings.TimedLineBreakDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextDisplaySettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextDisplaySettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextDisplaySettings.#ctor(YAT.Domain.Settings.TextDisplaySettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextDisplaySettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.TextDisplaySettings.ChunkLineBreakEnabled">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextDisplaySettings.LengthLineBreak">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextDisplaySettings.TimedLineBreak">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextDisplaySettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextDisplaySettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextDisplaySettings.Equals(YAT.Domain.Settings.TextDisplaySettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextDisplaySettings.op_Equality(YAT.Domain.Settings.TextDisplaySettings,YAT.Domain.Settings.TextDisplaySettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextDisplaySettings.op_Inequality(YAT.Domain.Settings.TextDisplaySettings,YAT.Domain.Settings.TextDisplaySettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.TextExclusionSettings">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextExclusionSettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextExclusionSettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextExclusionSettings.#ctor(YAT.Domain.Settings.TextExclusionSettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextExclusionSettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.TextExclusionSettings.Enabled">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextExclusionSettings.Patterns">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextExclusionSettings.UpdateRegexes">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextExclusionSettings.Regexes">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextExclusionSettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextExclusionSettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextExclusionSettings.Equals(YAT.Domain.Settings.TextExclusionSettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextExclusionSettings.op_Equality(YAT.Domain.Settings.TextExclusionSettings,YAT.Domain.Settings.TextExclusionSettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextExclusionSettings.op_Inequality(YAT.Domain.Settings.TextExclusionSettings,YAT.Domain.Settings.TextExclusionSettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.TextLineSendDelaySettingTuple">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextLineSendDelaySettingTuple.Enabled">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextLineSendDelaySettingTuple.Delay">
            <summary>Delay in milliseconds.</summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextLineSendDelaySettingTuple.LineInterval">
            <remarks>Interval here means "each n lines".</remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextLineSendDelaySettingTuple.#ctor(System.Boolean,System.Int32,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextLineSendDelaySettingTuple.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextLineSendDelaySettingTuple.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextLineSendDelaySettingTuple.Equals(YAT.Domain.Settings.TextLineSendDelaySettingTuple)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextLineSendDelaySettingTuple.op_Equality(YAT.Domain.Settings.TextLineSendDelaySettingTuple,YAT.Domain.Settings.TextLineSendDelaySettingTuple)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextLineSendDelaySettingTuple.op_Inequality(YAT.Domain.Settings.TextLineSendDelaySettingTuple,YAT.Domain.Settings.TextLineSendDelaySettingTuple)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.TextWaitForResponseSettingTuple">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextWaitForResponseSettingTuple.Enabled">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextWaitForResponseSettingTuple.ResponseLineCount">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextWaitForResponseSettingTuple.ClearanceLineCount">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextWaitForResponseSettingTuple.Timeout">
            <summary>Time-out in milliseconds.</summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextWaitForResponseSettingTuple.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextWaitForResponseSettingTuple.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextWaitForResponseSettingTuple.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextWaitForResponseSettingTuple.Equals(YAT.Domain.Settings.TextWaitForResponseSettingTuple)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextWaitForResponseSettingTuple.op_Equality(YAT.Domain.Settings.TextWaitForResponseSettingTuple,YAT.Domain.Settings.TextWaitForResponseSettingTuple)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextWaitForResponseSettingTuple.op_Inequality(YAT.Domain.Settings.TextWaitForResponseSettingTuple,YAT.Domain.Settings.TextWaitForResponseSettingTuple)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.BinaryTerminalSettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.BinaryTerminalSettings.SeparateTxRxDisplayDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.BinaryTerminalSettings.EncodingFixed">
            <summary>
            Binary terminals are (yet) fixed to <see cref="P:System.Text.Encoding.Default"/> which is limited to
            an ANSI code page, i.e. always a single byte character set (SBCS).
            </summary>
            <remarks>
            Rationale:
            <list type="bullet">
            <item>
            Binary terminals are intended to mainly be used with numeric radices and the encoding is
            only needed for parsing and displaying char/string.
            </item>
            <item>
            Non-SBCS are not implemented (yet).
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryTerminalSettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryTerminalSettings.#ctor(MKY.Settings.SettingsType)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryTerminalSettings.#ctor(YAT.Domain.Settings.BinaryTerminalSettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryTerminalSettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.BinaryTerminalSettings.SeparateTxRxDisplay">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.BinaryTerminalSettings.TxDisplay">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.BinaryTerminalSettings.RxDisplay">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryTerminalSettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryTerminalSettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryTerminalSettings.Equals(YAT.Domain.Settings.BinaryTerminalSettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryTerminalSettings.op_Equality(YAT.Domain.Settings.BinaryTerminalSettings,YAT.Domain.Settings.BinaryTerminalSettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.BinaryTerminalSettings.op_Inequality(YAT.Domain.Settings.BinaryTerminalSettings,YAT.Domain.Settings.BinaryTerminalSettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.BufferSettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.BufferSettings.BufferSizeDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BufferSettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BufferSettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BufferSettings.#ctor(YAT.Domain.Settings.BufferSettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BufferSettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.BufferSettings.TxBufferSize">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.BufferSettings.RxBufferSize">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.BufferSettings.BidirBufferSize">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.BufferSettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BufferSettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.BufferSettings.Equals(YAT.Domain.Settings.BufferSettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.BufferSettings.op_Equality(YAT.Domain.Settings.BufferSettings,YAT.Domain.Settings.BufferSettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.BufferSettings.op_Inequality(YAT.Domain.Settings.BufferSettings,YAT.Domain.Settings.BufferSettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.TerminalSettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TerminalSettings.TerminalTypeDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.#ctor(MKY.Settings.SettingsType)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.#ctor(YAT.Domain.Settings.TerminalSettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.TerminalType">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.IO">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.Status">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.Buffer">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.Display">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.CharReplace">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.CharHide">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.CharAction">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.Send">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.TextTerminal">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.BinaryTerminal">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.TxDisplayChunkLineBreakEnabled">
            <remarks>
            Supported for text and binary terminals, but settings are separated to allow setting and
            keeping them separate, as e.g. chunk and timed line breaks make more sense on a binary
            than a text terminal.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.RxDisplayChunkLineBreakEnabled">
            <remarks>
            Supported for text and binary terminals, but settings are separated to allow setting and
            keeping them separate, as e.g. chunk and timed line breaks make more sense on a binary
            than a text terminal.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.TxDisplayTimedLineBreak">
            <remarks>
            Supported for text and binary terminals, but settings are separated to allow setting and
            keeping them separate, as e.g. chunk and timed line breaks make more sense on a binary
            than a text terminal.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.RxDisplayTimedLineBreak">
            <remarks>
            Supported for text and binary terminals, but settings are separated to allow setting and
            keeping them separate, as e.g. chunk and timed line breaks make more sense on a binary
            than a text terminal.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.TxRadixIsStringOrChar">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.RxRadixIsStringOrChar">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.AnyRadixIsStringOrChar">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.SupportsHide0xFF">
            <summary>
            For text terminals, hide 0xFF is only supported if encoding is single byte.
            For binary terminals, hide 0xFF is always supported.
            </summary>
        </member>
        <member name="P:YAT.Domain.Settings.TerminalSettings.SupportsHideXOnXOff">
            <summary>
            Hiding XOn/XOff only makes sense for I/O where XOn/XOff is known to be used.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.UpdateAllDependentSettings">
            <remarks>
            \remind (2019-08-22 / MKY)
            Not a 'nice' solution, but it works... At least as long nobody forgets to call these methods...
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.UpdateTerminalTypeDependentSettings">
            <remarks>
            \remind (2019-04-27 / MKY)
            Not a 'nice' solution, but it works... At least as long nobody forgets to call these methods...
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.UpdateTerminalTypeDependentSettings(System.Boolean)">
            <remarks>
            \remind (2019-04-27 / MKY)
            Not a 'nice' solution, but it works... At least as long nobody forgets to call these methods...
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.UpdateIOTypeDependentSettings">
            <remarks>
            \remind (2018-02-23 / MKY)
            Not a 'nice' solution, but it works... At least as long nobody forgets to call these methods...
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.UpdateIOTypeDependentSettings(System.Boolean)">
            <remarks>
            \remind (2018-02-23 / MKY)
            Not a 'nice' solution, but it works... At least as long nobody forgets to call these methods...
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.IOTypeDependentSettingsWereDefaults(System.Boolean)">
            <remarks>
            \remind (2018-02-23 / MKY)
            Not a 'nice' solution, but it works... At least as long nobody forgets to call these methods...
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.UpdateIOSettingsDependentSettings">
            <remarks>
            \remind (2019-08-22 / MKY)
            Not a 'nice' solution, but it works... At least as long nobody forgets to call these methods...
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.UpdateIOSettingsDependentSettings(System.Boolean)">
            <remarks>
            \remind (2019-08-22 / MKY)
            Not a 'nice' solution, but it works... At least as long nobody forgets to call these methods...
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.IOSettingsDependentSettingsWereDefaults(System.Boolean)">
            <remarks>
            \remind (2019-08-22 / MKY)
            Not a 'nice' solution, but it works... At least as long nobody forgets to call these methods...
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.Equals(YAT.Domain.Settings.TerminalSettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.op_Equality(YAT.Domain.Settings.TerminalSettings,YAT.Domain.Settings.TerminalSettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TerminalSettings.op_Inequality(YAT.Domain.Settings.TerminalSettings,YAT.Domain.Settings.TerminalSettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.DisplaySettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.SeparateTxRxRadixDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.RadixDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.RadixTextDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.RadixBinaryDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ShowRadixDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ShowLineNumbersDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.LineNumberSelectionDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ShowTimeStampDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.TimeStampFormatDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.TimeStampUseUtcDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ShowTimeSpanDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.TimeSpanFormatDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ShowTimeDeltaDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.TimeDeltaFormatDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ShowDeviceDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ShowDirectionDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ShowLengthDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.LengthSelectionDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.LengthSelectionTextDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.LengthSelectionBinaryDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ShowDurationDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.TimeDurationFormatDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.IncludeIOControlDefault">
            <remarks>
            Prepended "IO" for distinction with ASCII "Control" characters.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.IncludeIOWarningsDefault">
            <remarks>
            Prepended "IO" for orthogonality with <see cref="P:YAT.Domain.Settings.DisplaySettings.IncludeIOControl"/>.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.MaxLineCountDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.MaxLineLengthDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ShowCopyOfActiveLineDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.DeviceLineBreakEnabledDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.DirectionLineBreakEnabledDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ChunkLineBreakEnabledDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.ContentSeparatorDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.InfoSeparatorDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.DisplaySettings.InfoEnclosureDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.DisplaySettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.DisplaySettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.DisplaySettings.#ctor(YAT.Domain.Settings.DisplaySettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.DisplaySettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.SeparateTxRxRadix">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.TxRadix">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.RxRadix">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.TxRadixIsShowable">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.RxRadixIsShowable">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ShowRadix">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ShowLineNumbers">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.LineNumberSelection">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ShowTimeStamp">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.TimeStampFormat">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.TimeStampUseUtc">
            <remarks>
            XML element is named "UTC" instead of .NET-style "Utc" for better readability.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ShowTimeSpan">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.TimeSpanFormat">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ShowTimeDelta">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.TimeDeltaFormat">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ShowDevice">
            <remarks>Named "Device" for simplicity even though using "I/O Device" for view.</remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ShowDirection">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ShowLength">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.LengthSelection">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ShowDuration">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.TimeDurationFormat">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.IncludeIOControl">
            <remarks>
            Prepended "IO" for distinction with ASCII "Control" characters.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.IncludeIOWarnings">
            <remarks>
            Prepended "IO" for orthogonality with <see cref="P:YAT.Domain.Settings.DisplaySettings.IncludeIOControl"/>.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.DirectionLineBreakEnabled">
            <remarks>
            Part of the text/binary independent settings to ease handling the dependency
            to <see cref="P:YAT.Domain.Settings.DisplaySettings.ShowDirection"/> in the advanced settings dialog.
            </remarks>
            <remarks>
            Located before <see cref="P:YAT.Domain.Settings.DisplaySettings.DeviceLineBreakEnabled"/> because the direction line
            break is something more important (not only for TCP/IP and UDP/IP servers).
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.DeviceLineBreakEnabled">
            <remarks>
            Named "Device" for simplicity even though using "I/O Device" for view.
            </remarks>
            <remarks>
            Part of the text/binary independent settings to ease handling the dependency
            to <see cref="P:YAT.Domain.Settings.DisplaySettings.ShowDevice"/> in the advanced settings dialog.
            </remarks>
            <remarks>
            Located after <see cref="P:YAT.Domain.Settings.DisplaySettings.DirectionLineBreakEnabled"/> because the device line
            break is something less important (only for TCP/IP and UDP/IP servers).
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.MaxLineCount">
            <exception cref="T:System.ArgumentOutOfRangeException"> if count is below 1.</exception>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.MaxLineLength">
            <remarks>
            Required to keep monitor update performance at a decent level. In case of very long
            lines, redrawing of a list box item may take way too long! It even looks as if there
            is a recursion within 'mscorlib.dll'.
            </remarks>
            <remarks>
            Named 'Length' rather than 'CharCount' or 'ByteCount' because it is either or,
            depending on the terminal type. Also, 'Length' seems the most appropriate term.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"> if length is below 1.</exception>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ShowCopyOfActiveLine">
            <remarks>
            Name only "Active" instead of "LastActive" for simplicity.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ContentSeparator">
            <remarks>
            This 'EnumEx' cannot be serialized, thus, the helper below is used for serialization.
            Still, this settings object shall provide an 'EnumEx' for full control of the setting.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ContentSeparator_ForSerialization">
            <remarks>
            Must be string because an 'EnumEx' cannot be serialized.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.ContentSeparatorCache">
            <remarks>Available for performance reasons.</remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.InfoSeparator">
            <remarks>
            This 'EnumEx' cannot be serialized, thus, the helper below is used for serialization.
            Still, this settings object shall provide an 'EnumEx' for full control of the setting.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.InfoSeparator_ForSerialization">
            <remarks>
            Must be string because an 'EnumEx' cannot be serialized.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.InfoSeparatorCache">
            <remarks>Available for performance reasons.</remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.InfoEnclosure">
            <remarks>
            This 'EnumEx' cannot be serialized, thus, the helper below is used for serialization.
            Still, this settings object shall provide an 'EnumEx' for full control of the setting.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.InfoEnclosure_ForSerialization">
            <remarks>
            Must be string because an 'EnumEx' cannot be serialized.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.InfoEnclosureLeftCache">
            <remarks>Available for performance reasons.</remarks>
        </member>
        <member name="P:YAT.Domain.Settings.DisplaySettings.InfoEnclosureRightCache">
            <remarks>Available for performance reasons.</remarks>
        </member>
        <member name="M:YAT.Domain.Settings.DisplaySettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.DisplaySettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.DisplaySettings.Equals(YAT.Domain.Settings.DisplaySettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.DisplaySettings.op_Equality(YAT.Domain.Settings.DisplaySettings,YAT.Domain.Settings.DisplaySettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.DisplaySettings.op_Inequality(YAT.Domain.Settings.DisplaySettings,YAT.Domain.Settings.DisplaySettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.SendSettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettings.LineRepeatInfinite">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettings.UseExplicitDefaultRadixDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettings.AllowConcurrencyDefault">
            <remarks>
            <c>false</c> because user could e.g. define a set of predefined multi-line or (small)
            file commands which are invoked quickly after each other. In such case, each command
            shall be kept as a single request/transaction. User shall explicitly have to activate
            concurrency if that is needed/intended.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettings.CopyPredefinedDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettings.DefaultDelayDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettings.DefaultLineDelayDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettings.DefaultLineIntervalDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettings.DefaultLineRepeatDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.SendSettings.SignalXOnBeforeEachTransmissionDefault">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.SignalXOnPeriodicallyDefault">
            <remarks>
            Must be implemented as property that creates a new object on each call to ensure that
            there aren't multiple clients referencing (and modifying) the same object.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettings.#ctor(YAT.Domain.Settings.SendSettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.UseExplicitDefaultRadix">
            <remarks>Rather a 'Model' setting, but here for historical reasons.</remarks>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.AllowConcurrency">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.CopyPredefined">
            <remarks>Rather a 'Model' setting, but here for historical reasons.</remarks>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.Text">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.File">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.DefaultDelay">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.DefaultLineDelay">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.DefaultLineInterval">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.DefaultLineRepeat">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.SignalXOnBeforeEachTransmission">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.SendSettings.SignalXOnPeriodically">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettings.Equals(YAT.Domain.Settings.SendSettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettings.op_Equality(YAT.Domain.Settings.SendSettings,YAT.Domain.Settings.SendSettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.SendSettings.op_Inequality(YAT.Domain.Settings.SendSettings,YAT.Domain.Settings.SendSettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Settings.TextTerminalSettings">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.EncodingDefault">
            <summary>
            Default is <see cref="F:MKY.Text.EncodingEx.Default"/> which is <see cref="F:MKY.Text.SupportedEncoding.UTF8"/>
            which corresponds to <see cref="P:System.Text.Encoding.UTF8"/>.
            </summary>
            <remarks>
            <see cref="P:System.Text.Encoding.Default"/> must not be used because that is limited to an ANSI code page.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.DecodingMismatchBehaviorDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.SeparateTxRxEolDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.EolDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.ShowEolDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.SeparateTxRxDisplayDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.GlueCharsOfLineTimeoutDefault">
            <remarks>
            At e.g. 9600 baud, the frame time is ~1 ms, thus initially tried 50 ms. But tests on
            serial loopback port at 9600 baud revealed chunks of a 26 byte long line at e.g.:
            <list type="bullet">
            <item><description>x.024 and x.067 seconds =>  ~50 ms</description></item>
            <item><description>x.055 and x.131 seconds =>  ~80 ms</description></item>
            <item><description>x.102 and x.143 seconds =>  ~40 ms</description></item>
            <item><description>x.131 and x.212 seconds =>  ~80 ms</description></item>
            <item><description>...</description></item>
            <item><description>x.835 and x.984 seconds => ~150 ms</description></item>
            <item><description>x.907 and x.996 seconds => ~100 ms</description></item>
            </list>
            Initially concluded to use 250 ms. However, that's too short even for automated testing
            on two interconnected TCP/IP AutoSockets. Therefore using 500 ms, same as other features
            <see cref="P:YAT.Domain.Settings.TextTerminalSettings.LineSendDelay"/> and <see cref="P:YAT.Domain.Settings.TextTerminalSettings.WaitForResponse"/> further below.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.GlueCharsOfLineDefault">
            <remarks>
            Default is <see cref="P:YAT.Domain.Settings.TimeoutSettingTuple.Enabled"/> = <c>true</c> for two reasons:
            <list type="bullet">
            <item><description>Most users don't like unnecessarily broken additional lines.</description></item>
            <item><description>Dealing with partial lines is still possible with the very short time-out default.</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.LineSendDelayTimeoutDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.LineSendDelayDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.WaitForResponseTimeoutDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.WaitForResponseDefault">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Settings.TextTerminalSettings.CharSubstitutionDefault">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextTerminalSettings.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextTerminalSettings.#ctor(MKY.Settings.SettingsType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextTerminalSettings.#ctor(YAT.Domain.Settings.TextTerminalSettings)">
            <remarks>
            Fields are assigned via properties even though changed flag will be cleared anyway.
            There potentially is additional code that needs to be run within the property method.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextTerminalSettings.SetMyDefaults">
            <remarks>
            Fields are assigned via properties to ensure correct setting of changed flag.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextTerminalSettings.SetNodeDefaults">
            <remarks>
            No other way has yet been found to properly set defaults of a list of settings. Before
            this solution, bug #3581368>#244 "EOL comment indicators always contain the defaults"
            existed. With this solution, the underlying node itself does no longer know any default,
            and default deserialization properly deserializes the settings into the underlying node.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.Encoding">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.DecodingMismatchBehavior">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.SeparateTxRxEol">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.TxEol">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.RxEol">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.ShowEol">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.SeparateTxRxDisplay">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.TxDisplay">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.RxDisplay">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.GlueCharsOfLine">
            <remarks>
            Instead of glueing characters of a line and waiting with displaying the next line in the
            opposite direction (or other I/O device), characters could also be appended to two lines
            simultaneously. Technically this would be possible by adding a ReplacePreviousLine() in
            next to <see cref="M:YAT.Domain.DisplayRepository.ReplaceCurrentLine(YAT.Domain.DisplayElementCollection)"/>.
            However:
            <list type="bullet">
            <item><description>Resulting behavior is very uncommon = incomprehensible.</description></item>
            <item><description>Implementation becomes a nightmare (filter, suppress,...).</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.LineSendDelay">
             <remarks>
             This option is one of two ways to delay while sending.
             It supports adding a fixed delay each N lines.
            
             Alternatively, the \!(LineDelay()) or \!(LineInterval()) keyword can be used.
             The first is equal to setting "each 1 line".
             The latter allows a more precise timing.
            
             The above text is copy-pasted to/from the tool tip text of the text settings dialog.
             </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.WaitForResponse">
            <remarks>
            Technically, a "wait for N characters or bytes before" option could also be implemented.
            Such option could also be provided by binary terminals. However, usefulness of such
            option is questionable, thus not (yet) implemented until somebody requests this.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.CharSubstitution">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Settings.TextTerminalSettings.TextExclusion">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextTerminalSettings.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextTerminalSettings.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextTerminalSettings.Equals(YAT.Domain.Settings.TextTerminalSettings)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Settings.TextTerminalSettings.op_Equality(YAT.Domain.Settings.TextTerminalSettings,YAT.Domain.Settings.TextTerminalSettings)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.Settings.TextTerminalSettings.op_Inequality(YAT.Domain.Settings.TextTerminalSettings,YAT.Domain.Settings.TextTerminalSettings)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.Endianness">
            <summary>
            Enumeration of the the supported byte endiannesses.
            </summary>
            <remarks>
            Implemented as an enumeration (instead of a simple 'IsBigEndian' flag) to potentially
            support exotic endiannesses (e.g. PDP-11 'MiddleEndian').
            </remarks>
        </member>
        <member name="F:YAT.Domain.Endianness.BigEndian">
            <summary>e.g. Network, Motorola.</summary>
        </member>
        <member name="F:YAT.Domain.Endianness.LittleEndian">
            <summary>e.g. Intel.</summary>
        </member>
        <member name="T:YAT.Domain.EndiannessEx">
            <summary>
            Extended enum EndiannessEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.EndiannessEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.Endianness.BigEndian"/>.</summary>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.EndiannessEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.#ctor(YAT.Domain.Endianness)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.EndiannessEx.IsSameAsMachine">
            <summary>
            Gets a value indicating whether the endianness of this instance is the same as the
            endianness of the machine, i.e. the computer architecture.
            </summary>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.TryParse(System.String,YAT.Domain.EndiannessEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.TryParse(System.String,YAT.Domain.Endianness@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.op_Implicit(YAT.Domain.EndiannessEx)~YAT.Domain.Endianness">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.op_Implicit(YAT.Domain.Endianness)~YAT.Domain.EndiannessEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.op_Implicit(YAT.Domain.EndiannessEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.op_Implicit(System.Int32)~YAT.Domain.EndiannessEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.op_Implicit(YAT.Domain.EndiannessEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EndiannessEx.op_Implicit(System.String)~YAT.Domain.EndiannessEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.IODirection">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.IODirection.None">
            <remarks>Also usable with meaning 'Unknown' (yet).</remarks>
        </member>
        <member name="F:YAT.Domain.IODirection.Tx">
            <remarks>YAT uses term "Tx" instead of "Output".</remarks>
            <remarks>YAT sorts "Tx" before "Rx".</remarks>
        </member>
        <member name="F:YAT.Domain.IODirection.Rx">
            <remarks>YAT uses term "Rx" instead of "Input".</remarks>
            <remarks>YAT sorts "Rx" after "Tx".</remarks>
        </member>
        <member name="F:YAT.Domain.IODirection.Bidir">
            <remarks>Usable for I/O operations not tied to a direction.</remarks>
        </member>
        <member name="T:YAT.Domain.IOErrorSeverity">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Eol">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.EolEx">
             <summary>
             Extended enum EolEx.
             </summary>
             <remarks>
             LF:   Unix, Linux, Mac OS from version X, AmigaOS, BSD
             CRLF: Windows, DOS, OS/2, CP/M
             CR:   Mac OS up to version 9, Apple II
            
             This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
             Use the underlying enum for serialization, or alternatively, a string representation.
             </remarks>
        </member>
        <member name="F:YAT.Domain.EolEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.Eol.CRLF"/>.</summary>
        </member>
        <member name="M:YAT.Domain.EolEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.EolEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.EolEx.#ctor(YAT.Domain.Eol)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EolEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.EolEx.ToSequenceString">
            <remarks>Named ..String() to emphasize that this is not the binary sequence.</remarks>
        </member>
        <member name="M:YAT.Domain.EolEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EolEx.Parse(System.String)">
            <remarks>
            Opposed to the convention of the .NET framework, whitespace is NOT
            trimmed from <paramref name="s"/> as all EOL sequences are whitespaces.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EolEx.TryParse(System.String,YAT.Domain.EolEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EolEx.TryParse(System.String,YAT.Domain.Eol@)">
            <remarks>
            Opposed to the convention of the .NET framework, whitespace is NOT
            trimmed from <paramref name="s"/> as all EOL sequences are whitespaces.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EolEx.op_Implicit(YAT.Domain.EolEx)~YAT.Domain.Eol">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EolEx.op_Implicit(YAT.Domain.Eol)~YAT.Domain.EolEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EolEx.op_Implicit(YAT.Domain.EolEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EolEx.op_Implicit(System.Int32)~YAT.Domain.EolEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EolEx.op_Implicit(YAT.Domain.EolEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EolEx.op_Implicit(System.String)~YAT.Domain.EolEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.KeywordArgState">
             <summary>
             This state handles one or more keyword arguments. The state terminates with the closing ')'
             or a separating ','/';'/'|'.
             </summary>
             <remarks>
             So far, this state can only deal with integer values. As soon as floating point, boolean,
             enum or string values are required, this state will have to be extended accordingly. Ideas
             for implementing support for string values: AllowEscape, ExpectFilePath.
            
             String args will be required when completing FR #13, e.g. \!(Repeat(ABC, 5)).
            
             Note that it was considered to implement this keyword argument handling using Regex, either
             a Regex per argument, or a Regex per keyword. However, the big advantage of the YAT-style
             parser is its capability to quickly identify the first invalid character, and thus provide
             a better error message to the user.
             </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordArgState.#ctor(YAT.Domain.Parser.Keyword,System.Int32[])">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordArgState.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:YAT.Domain.Parser.KeywordArgState.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordArgState.TryParse(YAT.Domain.Parser.Parser,System.Int32,YAT.Domain.Parser.FormatException@)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.ParserState">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.ParserState.TryParse(YAT.Domain.Parser.Parser,System.Int32,YAT.Domain.Parser.FormatException@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.ParserState.ChangeState(YAT.Domain.Parser.Parser,YAT.Domain.Parser.ParserState)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.ParserState.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:YAT.Domain.Parser.ParserState.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="T:YAT.Domain.Parser.DefaultState">
            <summary>
            This state is the default, it handles contiguous sequences. The state terminates when
            entering one of the other states.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.DefaultState.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.DefaultState.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:YAT.Domain.Parser.DefaultState.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="M:YAT.Domain.Parser.DefaultState.TryParse(YAT.Domain.Parser.Parser,System.Int32,YAT.Domain.Parser.FormatException@)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.NestedState">
            <summary>
            This state handles a nested context, i.e. is something similar to a stack. The state
            terminates when the nested context has terminated.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.NestedState.TryParse(YAT.Domain.Parser.Parser,System.Int32,YAT.Domain.Parser.FormatException@)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.EscapeState">
            <summary>
            This state handles an escaping '\' and then passes control to a nested parser.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.EscapeState.TryParse(YAT.Domain.Parser.Parser,System.Int32,YAT.Domain.Parser.FormatException@)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.OpeningState">
            <summary>
            This state handles an opening '(' and then passes control to a nested parser.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.OpeningState.TryParse(YAT.Domain.Parser.Parser,System.Int32,YAT.Domain.Parser.FormatException@)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.NumericValueState">
            <summary>
            This state handles a sequence of numeric values in one of the supported radices. The
            sequence may consist of any number of subsequent values. The state terminates as soon as
            a non-supported character is found.
            </summary>
            <remarks>
            +/- signs are not allowed, neither are decimal points nor separators such as the apostrophe.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.NumericValueState.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.NumericValueState.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.NumericValueState.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:YAT.Domain.Parser.NumericValueState.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="M:YAT.Domain.Parser.NumericValueState.TryParse(YAT.Domain.Parser.Parser,System.Int32,YAT.Domain.Parser.FormatException@)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.AsciiMnemonicState">
            <summary>
            This state handles a sequence of ASCII mnemonics. The sequence may consist of any number
            of subsequent characters that form valid ASCII mnemonics. The state terminates with the
            closing '>'.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.AsciiMnemonicState.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.AsciiMnemonicState.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:YAT.Domain.Parser.AsciiMnemonicState.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="M:YAT.Domain.Parser.AsciiMnemonicState.TryParse(YAT.Domain.Parser.Parser,System.Int32,YAT.Domain.Parser.FormatException@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.AsciiMnemonicState.TryParseContiguousAsciiMnemonic(YAT.Domain.Parser.Parser,System.String,System.Byte[]@,YAT.Domain.Parser.FormatException@)">
            <summary>
            Parses <paramref name="s"/> for ASCII mnemonics. <paramref name="s"/> will
            sequentially be parsed and converted mnemonics-by-mnemonics.
            </summary>
            <param name="parser">The parser to be used.</param>
            <param name="s">String to be parsed.</param>
            <param name="result">Array containing the resulting bytes.</param>
            <param name="formatException">Returned if invalid string format.</param>
            <returns>Byte array containing the values encoded in Encoding.Default.</returns>
        </member>
        <member name="M:YAT.Domain.Parser.AsciiMnemonicState.TryParseContiguousAsciiMnemonicItem(YAT.Domain.Parser.Parser,System.String,System.Byte[]@,YAT.Domain.Parser.FormatException@)">
            <summary>
            Parses <paramref name="s"/> for ASCII mnemonics. <paramref name="s"/> will
            sequentially be parsed and converted mnemonics-by-mnemonics.
            </summary>
        </member>
        <member name="T:YAT.Domain.Parser.FormatException">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.FormatException.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.FormatException.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.FormatException.#ctor(System.String,System.Exception)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.FormatException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.Keyword">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Keyword.ZZZ_FIT">
            <summary>
            A special keyword For Internal Testing (= FIT).
            </summary>
            <remarks>
            Prepended "ZZZ_" to even more obviously indicate internal usage.
            </remarks>
        </member>
        <member name="T:YAT.Domain.Parser.KeywordEx">
            <summary>
            Extended enum KeywordEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Parser.KeywordEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.Parser.Keyword.None"/>.</summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.Parser.KeywordEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.#ctor(YAT.Domain.Parser.Keyword)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.GetMaxArgsCount">
            <summary>
            Gets the maximum arguments count for this keyword.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.Validate(System.Int32,System.Int32)">
            <summary>
            Validates the given value for the given argument index of this keyword.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.GetValidationFragment(System.Int32)">
            <summary>
            Gets the validation fragment for the given argument index of this keyword.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.TryParse(System.String,YAT.Domain.Parser.KeywordEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.TryParse(System.String,YAT.Domain.Parser.Keyword@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.op_Implicit(YAT.Domain.Parser.KeywordEx)~YAT.Domain.Parser.Keyword">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.op_Implicit(YAT.Domain.Parser.Keyword)~YAT.Domain.Parser.KeywordEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.op_Implicit(YAT.Domain.Parser.KeywordEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.op_Implicit(System.Int32)~YAT.Domain.Parser.KeywordEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.op_Implicit(YAT.Domain.Parser.KeywordEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordEx.op_Implicit(System.String)~YAT.Domain.Parser.KeywordEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.Mode">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Mode.None">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Mode.NoEscapes">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Mode.RadixEscapes">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Mode.AsciiEscapes">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Mode.RadixAndAsciiEscapes">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Mode.AllEscapesExceptKeywords">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Mode.KeywordEscapes">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Mode.AllEscapes">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Mode.Default">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.Result">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.BytesResult">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Parser.BytesResult.Bytes">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.BytesResult.#ctor(System.Byte[])">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.KeywordResult">
            <remarks>
            So far, this type can only deal with integer values. As soon as floating point, boolean,
            enum or string values are required, this type will have to be extended accordingly.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Parser.KeywordResult.Keyword">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Parser.KeywordResult.Args">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordResult.#ctor(YAT.Domain.Parser.Keyword)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.KeywordResult.#ctor(YAT.Domain.Parser.Keyword,System.Int32[])">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.Parser">
             <remarks>
             This parser provides all functionality to parse any parseable text to send (commands, files).
             The parser is implemented using the state pattern. The states are implemented in a separate
             file 'States.cs'.
            
             The abstract base class <see cref="T:YAT.Domain.Parser.ParserState"/> defines the state's interface and provides
             some common methods. The concrete state classes implement the required states:
              - <see cref="T:YAT.Domain.Parser.DefaultState"/>       : Default parser, handles contiguous sequences.
              - <see cref="T:YAT.Domain.Parser.NestedState"/>        : Handles a nested context.
              - <see cref="T:YAT.Domain.Parser.EscapeState"/>        : Handles an escaping '\'.
              - <see cref="T:YAT.Domain.Parser.OpeningState"/>       : Handles an opening '('.
              - <see cref="T:YAT.Domain.Parser.AsciiMnemonicState"/> : Sequence of ASCII mnemonics.
              - <see cref="T:YAT.Domain.Parser.NumericValueState"/>  : Sequence of numeric values.
             </remarks>
        </member>
        <member name="F:YAT.Domain.Parser.Parser.FormatHelp">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Parser.KeywordHelp">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Parser.Parser.DefaultRadixDefault">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Parser.Parser.EncodingDefault">
            <summary>
            Default is <see cref="F:MKY.Text.EncodingEx.Default"/> which is <see cref="F:MKY.Text.SupportedEncoding.UTF8"/>
            which corresponds to <see cref="P:System.Text.Encoding.UTF8"/>.
            </summary>
            <remarks>
            <see cref="P:System.Text.Encoding.Default"/> must not be used because that is limited to an ANSI code page.
            </remarks>
            <remarks>
            Must be implemented as property (instead of a readonly) since <see cref="P:YAT.Domain.Parser.Parser.Encoding"/>
            is a mutable reference type. Defining a readonly would correctly result in FxCop
            message CA2104 "DoNotDeclareReadOnlyMutableReferenceTypes" (Microsoft.Security).
            </remarks>
        </member>
        <member name="F:YAT.Domain.Parser.Parser.EndiannessDefault">
            <summary>
            Default is <see cref="F:YAT.Domain.EndiannessEx.Default"/>.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.#ctor(YAT.Domain.Parser.Mode)">
            <remarks>
            <paramref name="mode"/> intentionally not defaulted, client must actively select the
            desired mode in order to prevent obscure behavior (default = <see cref="F:YAT.Domain.Parser.Mode.None"/> or
            rather <see cref="F:YAT.Domain.Parser.Mode.Default"/> which is <see cref="F:YAT.Domain.Parser.Mode.AllEscapes"/>?).
            </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.#ctor(System.Text.Encoding,YAT.Domain.Parser.Mode)">
            <remarks>
            <paramref name="mode"/> intentionally not defaulted, client must actively select the
            desired mode in order to prevent obscure behavior (default = <see cref="F:YAT.Domain.Parser.Mode.None"/> or
            rather <see cref="F:YAT.Domain.Parser.Mode.Default"/> which is <see cref="F:YAT.Domain.Parser.Mode.AllEscapes"/>?).
            </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.#ctor(YAT.Domain.Endianness,YAT.Domain.Parser.Mode)">
            <remarks>
            <paramref name="mode"/> intentionally not defaulted, client must actively select the
            desired mode in order to prevent obscure behavior (default = <see cref="F:YAT.Domain.Parser.Mode.None"/> or
            rather <see cref="F:YAT.Domain.Parser.Mode.Default"/> which is <see cref="F:YAT.Domain.Parser.Mode.AllEscapes"/>?).
            </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.#ctor(System.Text.Encoding,YAT.Domain.Endianness,YAT.Domain.Parser.Mode)">
            <remarks>
            <paramref name="mode"/> intentionally not defaulted, client must actively select the
            desired mode in order to prevent obscure behavior (default = <see cref="F:YAT.Domain.Parser.Mode.None"/> or
            rather <see cref="F:YAT.Domain.Parser.Mode.Default"/> which is <see cref="F:YAT.Domain.Parser.Mode.AllEscapes"/>?).
            </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.#ctor(YAT.Domain.Parser.Parser,YAT.Domain.Parser.ParserState)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:YAT.Domain.Parser.Parser.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.GetNestedParser(YAT.Domain.Parser.ParserState)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Parser.Parser.Encoding">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Parser.Parser.Endianness">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Parser.Parser.Radix">
            <remarks>Radix: public get, private set.</remarks>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.SetDefaultRadix(YAT.Domain.Radix)">
            <remarks>Radix: public get, private set.</remarks>
        </member>
        <member name="P:YAT.Domain.Parser.Parser.IsTopLevel">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.Parse(System.String,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParse(System.String,System.Byte[]@,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParse(System.String,System.Byte[]@,System.String@,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParse(System.String,System.Byte[]@,YAT.Domain.Parser.FormatException@,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParse(System.String,System.Byte[]@,System.String@,YAT.Domain.Parser.FormatException@,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParse(System.String,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParse(System.String,System.String@,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParse(System.String,System.String@,YAT.Domain.Parser.FormatException@,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParse(System.String,YAT.Domain.Parser.Result[]@,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParse(System.String,YAT.Domain.Parser.Result[]@,System.String@,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParse(System.String,YAT.Domain.Parser.Result[]@,System.String@,YAT.Domain.Parser.FormatException@,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.IsEscape(System.Char)">
            <summary>
            Determines whether the specified character is an escape character.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.IsWhiteSpace(System.Int32)">
            <remarks>
            Spelled "WhiteSpace" instead of "Whitespace" for consistency with the
            <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> method.
            </remarks>
            <remarks>
            Using <c>int</c> instead of <c>char</c> for ease of use after calling
            <see cref="M:System.IO.StringReader.Peek"/> and <see cref="M:System.IO.StringReader.Read"/>.
            </remarks>
            <remarks>
            Virtual instance member instead of static member to be prepared for potential overload.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.CommitPendingBytes">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.CommitResult(YAT.Domain.Parser.Result)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParseContiguousRadix(System.String,YAT.Domain.Radix,System.Byte[]@,YAT.Domain.Parser.FormatException@)">
            <summary>
            Parses <paramref name="s"/> for one or more items in the specified base <paramref name="radix"/>, separated by spaces.
            </summary>
            <param name="s">String to be parsed.</param>
            <param name="radix">Numeric radix.</param>
            <param name="result">Array containing the resulting bytes.</param>
            <param name="formatException">Returned if invalid string format.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.OverflowException">Thrown if a value cannot be converted into bytes.</exception>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParseContiguousRadixItem(System.String,YAT.Domain.Radix,System.Byte[]@,YAT.Domain.Parser.FormatException@)">
            <summary>
            Parses <paramref name="s"/> for a single item in the specified <paramref name="radix"/>.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryEncodeStringItem(System.String,System.Byte[]@,YAT.Domain.Parser.FormatException@)">
            <summary>
            Encodes <paramref name="s"/> containing a plain string into bytes.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.GetBytes(System.String)">
            <summary>
            Encodes the given string, taking encoding into account.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryEncodeCharItem(System.String,System.Byte[]@,YAT.Domain.Parser.FormatException@)">
            <summary>
            Encodes <paramref name="s"/> containing a single char item into bytes.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.GetBytes(System.Char)">
            <summary>
            Encodes the given character, taking encoding into account.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParseAndConvertContiguousNumericItem(System.String,System.Byte[]@,YAT.Domain.Parser.FormatException@)">
            <summary>
            Parses <paramref name="s"/> for a sequence of contiguous numeric digits in the current
            radix and converts them into bytes. The digits will sequentially be parsed and converted
            byte-by-byte.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParseAndConvertContiguousNumericItem(System.String,YAT.Domain.Radix,System.Byte[]@,YAT.Domain.Parser.FormatException@)">
            <summary>
            Parses <paramref name="s"/> for a sequence of contiguous numeric digits in the specified
            <paramref name="radix"/> and converts them into bytes. The digits will sequentially be
            parsed and converted byte-by-byte.
            </summary>
            <remarks>
            Implementation allows e.g. \h(01020A0F) to easily send data from e.g. a .hex file.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.TryParseKeyword(System.String,YAT.Domain.Parser.KeywordResult@,YAT.Domain.Parser.FormatException@)">
            <summary>
            Parses <paramref name="s"/> for a keyword.
            </summary>
            <param name="s">String to be parsed.</param>
            <param name="result">Array containing the results.</param>
            <param name="formatException">Returned if invalid string format.</param>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.InitializeTopLevel(System.String,YAT.Domain.Radix,System.Boolean)">
            <summary>
            Initialize or re-initialize the top-level of a parser.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.InitializeNestedLevelFromParent(YAT.Domain.Parser.Parser,YAT.Domain.Parser.ParserState)">
            <summary>
            Initialize a nested-level of a parser.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.Parser.Close">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Parser.SubstitutionParser">
            <summary>
            Extends Parser with character substitution.
            </summary>
        </member>
        <member name="M:YAT.Domain.Parser.SubstitutionParser.#ctor(YAT.Domain.CharSubstitution,System.Text.Encoding,YAT.Domain.Endianness,YAT.Domain.Parser.Mode)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.SubstitutionParser.#ctor(YAT.Domain.Parser.SubstitutionParser,YAT.Domain.Parser.ParserState)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.SubstitutionParser.GetNestedParser(YAT.Domain.Parser.ParserState)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Parser.SubstitutionParser.TryParseContiguousRadixItem(System.String,YAT.Domain.Radix,System.Byte[]@,YAT.Domain.Parser.FormatException@)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.SequenceQueue">
            <summary>
            Queue evaluates whether a sequence of bytes matches the given sequence.
            Can be used to e.g. detect EOL (end-of-line) sequences.
            </summary>
            <remarks>
            Implementation used to evaluate match on request only. However, when adding 'IsPartlyMatch'
            (predecessor of <see cref="P:YAT.Domain.SequenceQueue.IsPartlyMatchBeginning"/> and <see cref="P:YAT.Domain.SequenceQueue.IsPartlyMatchContinued"/>,
            evaluation was moved to <see cref="M:YAT.Domain.SequenceQueue.Enqueue(System.Byte)"/> and enqueue was optimized. This implementation
            is far better performing if properties are regularly read.
            </remarks>
        </member>
        <member name="F:YAT.Domain.SequenceQueue.sequence">
             <remarks>
             "Guidelines for Collections": "Do use byte arrays instead of collections of bytes."
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:YAT.Domain.SequenceQueue.#ctor(System.Byte[])">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.SequenceQueue.Sequence">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SequenceQueue.QueueAsArray">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.SequenceQueue.IsPartlyMatchBeginning">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.SequenceQueue.IsPartlyMatchContinued">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.SequenceQueue.IsPartlyMatch">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.SequenceQueue.IsCompleteMatch">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.SequenceQueue.IsAnyMatch">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SequenceQueue.Enqueue(System.Byte)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SequenceQueue.Reset">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SequenceQueue.Clone">
            <summary>
            Creates and returns a new object that is a deep-copy of this instance.
            </summary>
        </member>
        <member name="M:YAT.Domain.SequenceQueue.SequenceToString">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SequenceQueue.QueueToString">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SequenceQueue.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.SequenceQueue.ToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.SequenceQueue.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="T:YAT.Domain.IOType">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.IOTypeEx">
            <summary>
            Extended enum IOTypeEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.IOTypeEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.IOType.SerialPort"/>.</summary>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.IOTypeEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.#ctor(YAT.Domain.IOType)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOTypeEx.IsSerialPort">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOTypeEx.IsSocket">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOTypeEx.IsTcpSocket">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOTypeEx.IsUdpSocket">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOTypeEx.IsServerSocket">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOTypeEx.IsUsbSerialHid">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.TryParse(System.String,YAT.Domain.IOTypeEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.TryParse(System.String,YAT.Domain.IOType@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.op_Implicit(YAT.Domain.IOTypeEx)~YAT.Domain.IOType">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.op_Implicit(YAT.Domain.IOType)~YAT.Domain.IOTypeEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.op_Implicit(YAT.Domain.IOTypeEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.op_Implicit(System.Int32)~YAT.Domain.IOTypeEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.op_Implicit(YAT.Domain.IOTypeEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.op_Implicit(System.String)~YAT.Domain.IOTypeEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.op_Implicit(YAT.Domain.IOTypeEx)~MKY.IO.Serial.Socket.SocketType">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOTypeEx.op_Implicit(MKY.IO.Serial.Socket.SocketType)~YAT.Domain.IOTypeEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Direction">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Direction.None">
            <remarks>Same as <see cref="T:YAT.Domain.IODirection"/> to allow casting for optimized speed.</remarks>
            <remarks>Also usable with meaning 'Unknown' (yet).</remarks>
        </member>
        <member name="F:YAT.Domain.Direction.Tx">
            <remarks>Same as <see cref="T:YAT.Domain.IODirection"/> to allow casting for optimized speed.</remarks>
        </member>
        <member name="F:YAT.Domain.Direction.Rx">
            <remarks>Same as <see cref="T:YAT.Domain.IODirection"/> to allow casting for optimized speed.</remarks>
        </member>
        <member name="F:YAT.Domain.Direction.Bidir">
            <remarks>Same as <see cref="T:YAT.Domain.IODirection"/> to allow casting for optimized speed.</remarks>
            <remarks>Usable for I/O operations not tied to a direction.</remarks>
        </member>
        <member name="T:YAT.Domain.DirectionEx">
            <summary>
            Extended enum DirectionEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.DirectionEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.Direction.None"/>.</summary>
        </member>
        <member name="M:YAT.Domain.DirectionEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.DirectionEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.DirectionEx.#ctor(YAT.Domain.Direction)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DirectionEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.DirectionEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DirectionEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DirectionEx.TryParse(System.String,YAT.Domain.DirectionEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DirectionEx.TryParse(System.String,YAT.Domain.Direction@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DirectionEx.op_Implicit(YAT.Domain.DirectionEx)~YAT.Domain.Direction">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DirectionEx.op_Implicit(YAT.Domain.Direction)~YAT.Domain.DirectionEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DirectionEx.op_Implicit(YAT.Domain.DirectionEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DirectionEx.op_Implicit(System.Int32)~YAT.Domain.DirectionEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DirectionEx.op_Implicit(YAT.Domain.DirectionEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DirectionEx.op_Implicit(System.String)~YAT.Domain.DirectionEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.IOControlState">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.SerialPortControlPins">
            <summary>
            Serial port control pins.
            </summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.SerialPortControlPinCount">
            <summary>
            Serial port control pin count.
            </summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.InputIsXOn">
            <summary>
            Input XOn/XOff reflects the XOn/XOff state of this serial port itself,
            i.e. the computer where this application is running.
            </summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.OutputIsXOn">
            <summary>
            Output XOn/XOff reflects the XOn/XOff state of the communication counterpart,
            i.e. a device connected to the computer where this application is running.
            </summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.SentXOnCount">
            <summary>
            The number of sent XOn bytes, i.e. the count of input XOn/XOff signaling.
            </summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.SentXOffCount">
            <summary>
            The number of sent XOff bytes, i.e. the count of input XOn/XOff signaling.
            </summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.ReceivedXOnCount">
            <summary>
            The number of received XOn bytes, i.e. the count of output XOn/XOff signaling.
            </summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.ReceivedXOffCount">
            <summary>
            The number of received XOff bytes, i.e. the count of output XOn/XOff signaling.
            </summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.InputBreak">
            <summary>
            The input break state.
            </summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.OutputBreak">
            <summary>
            The output break state.
            </summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.InputBreakCount">
            <summary>
            Returns the number of input breaks.
            </summary>
        </member>
        <member name="P:YAT.Domain.IOControlState.OutputBreakCount">
            <summary>
            Returns the number of output breaks.
            </summary>
        </member>
        <member name="M:YAT.Domain.IOControlState.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Use properties instead of fields. This ensures that 'intelligent' properties,
            i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.IOControlState.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <remarks>
            Use properties instead of fields to calculate hash code. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.IOControlState.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.IOControlState.Equals(YAT.Domain.IOControlState)">
            <summary>
            Determines whether this instance and the specified object have value equality.
            </summary>
            <remarks>
            Use properties instead of fields to determine equality. This ensures that 'intelligent'
            properties, i.e. properties with some logic, are also properly handled.
            </remarks>
        </member>
        <member name="M:YAT.Domain.IOControlState.op_Equality(YAT.Domain.IOControlState,YAT.Domain.IOControlState)">
            <summary>
            Determines whether the two specified objects have value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.IOControlState.op_Inequality(YAT.Domain.IOControlState,YAT.Domain.IOControlState)">
            <summary>
            Determines whether the two specified objects have value inequality.
            </summary>
        </member>
        <member name="T:YAT.Domain.TerminalFactory">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TerminalFactory.CreateTerminal(YAT.Domain.Settings.TerminalSettings)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TerminalFactory.RecreateTerminal(YAT.Domain.Settings.TerminalSettings,YAT.Domain.Terminal)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElementCollection">
            <summary>
            Implements a collection of display elements representing a part of a line.
            </summary>
            <remarks>
            This class inherits from <see cref="T:List`"/>. However, it only overrides functions
            required for YAT use cases. It is only allowed to add to the list, removing items results
            in an undefined behavior.
            </remarks>
        </member>
        <member name="F:YAT.Domain.DisplayElementCollection.TypicalNumberOfElementsPerLine">
             <remarks>
             Can be used to preset the initial capacity of display element collections. A value of
             18 would reflect the maximum elements in case of string radix and EOL shown:
             start, stamp, sep, span, sep, delta, sep, port, sep, direction, sep, content, eol, sep, length, sep, duration, linebreak
            
             However, this is not a typical use case, thus using a reduced value of 16 which is the
             most typical 2^n value.
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.#ctor(YAT.Domain.DisplayElement)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.#ctor(System.Collections.Generic.IEnumerable{YAT.Domain.DisplayElement})">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElementCollection.TimeStamp">
            <summary>
            The time stamp of the elements in the collection.
            </summary>
            <remarks>
            The value corresponds to <see cref="P:YAT.Domain.DisplayElement.TimeStamp"/> of the first element in
            the collection which has a value other than <see cref="F:YAT.Domain.DisplayElement.TimeStampDefault"/>;
            or <see cref="F:YAT.Domain.DisplayElement.TimeStampDefault"/>/> in case the collection is empty or no
            element has a value other than <see cref="F:YAT.Domain.DisplayElement.TimeStampDefault"/>.
            </remarks>
        </member>
        <member name="P:YAT.Domain.DisplayElementCollection.Direction">
            <summary>
            The direction of the elements in the collection.
            </summary>
            <remarks>
            The value typically corresponds to <see cref="P:YAT.Domain.DisplayElement.Direction"/> of all
            elements in the collection, but may also be <see cref="F:YAT.Domain.Direction.Bidir"/> in case
            direction line break is disabled.
            </remarks>
        </member>
        <member name="P:YAT.Domain.DisplayElementCollection.Text">
            <summary>
            Appends and returns the text of all display elements.
            </summary>
        </member>
        <member name="P:YAT.Domain.DisplayElementCollection.ContentText">
            <summary>
            Appends and returns the text of the content display elements.
            </summary>
        </member>
        <member name="P:YAT.Domain.DisplayElementCollection.CharCount">
            <summary>
            The number of characters of the elements contained in the collection.
            </summary>
            <remarks>
            ASCII mnemonics (e.g. &lt;CR&gt;) are considered a single shown character.
            </remarks>
        </member>
        <member name="P:YAT.Domain.DisplayElementCollection.DataContentCharCount">
            <summary>
            The number of characters of the data content elements (i.e. without control
            data like <code>CRLF</code>) contained in the collection.
            </summary>
        </member>
        <member name="P:YAT.Domain.DisplayElementCollection.ControlContentCharCount">
            <summary>
            The number of characters of the control content elements (e.g. control
            data like <code>CRLF</code>) contained in the collection.
            </summary>
        </member>
        <member name="P:YAT.Domain.DisplayElementCollection.ByteCount">
            <summary>
            The number of raw bytes of the elements contained in the collection.
            </summary>
            <remarks>
            Note that value reflects the byte count of the elements contained in the collection,
            i.e. the byte count of the elements shown. The value thus not necessarily reflects the
            total byte count of a sent or received sequence, a hidden EOL is e.g. not reflected.
            </remarks>
        </member>
        <member name="P:YAT.Domain.DisplayElementCollection.Highlight">
            <summary>
            Indicates whether any <see cref="T:YAT.Domain.DisplayElement"/> of this <see cref="T:YAT.Domain.DisplayElementCollection"/> is highlighted.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.Add(YAT.Domain.DisplayElement)">
            <remarks>
            Required to properly perform content counting.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.AddRange(System.Collections.Generic.IEnumerable{YAT.Domain.DisplayElement})">
            <remarks>
            Required because <see cref="T:List`1.AddRange"/> doesn't call <see cref="M:YAT.Domain.DisplayElementCollection.Add(YAT.Domain.DisplayElement)"/>
            method above because it is 'new'. Call to <see cref="M:YAT.Domain.DisplayElementCollection.Add(YAT.Domain.DisplayElement)"/> method above is
            required to properly perform content counting.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.Insert(System.Int32,YAT.Domain.DisplayElement)">
            <remarks>
            Required to properly perform content counting.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{YAT.Domain.DisplayElement})">
            <remarks>
            Required because <see cref="T:List`1.InsertRange"/> doesn't call <see cref="M:YAT.Domain.DisplayElementCollection.Insert(System.Int32,YAT.Domain.DisplayElement)"/>
            method above because it is 'new'. Call to <see cref="M:YAT.Domain.DisplayElementCollection.Insert(System.Int32,YAT.Domain.DisplayElement)"/> method above is
            required to properly perform content counting.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.Remove(YAT.Domain.DisplayElement)">
            <remarks>
            Required because <see cref="T:List`1.Remove"/> doesn't call <see cref="M:YAT.Domain.DisplayElementCollection.RemoveAt(System.Int32)"/>
            method below because it is 'new'. Call to <see cref="M:YAT.Domain.DisplayElementCollection.RemoveAt(System.Int32)"/> method below is
            required to properly perform content counting.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the <see cref="T:YAT.Domain.DisplayElementCollection"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <list type="table">
            <item><description><paramref name="index"/> is less than 0.</description></item>
            <item><description>-or-</description></item>
            <item><description><paramref name="index"/> is equal to or greater than <see cref="T:List`1.Count"/>.</description></item>
            </list>
            </exception>
            <remarks>
            Required to properly perform content counting.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.RemoveLast">
            <summary>
            Removes the last element of the <see cref="T:YAT.Domain.DisplayElementCollection"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The collection is empty.
            </exception>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.RemoveLastUntil(System.Type)">
            <summary>
            Removes all elements at the end until (and including!) an element of the given type is found.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.RemoveLastDataContentChar">
            <summary>
            Removes the last "true" character from the <see cref="T:YAT.Domain.DisplayElementCollection"/>.
            </summary>
            <remarks><para>
            Needed to handle backspace, thus applies to data content only.
            </para><para>
            Trailing content separator is not removed here, it must be removed before calling this
            method. This is because this method in case of e.g. a space cannot tell whether the
            space is "true" content or a separator appended. Because for performance reasons,
            "DisplayElement.AcceptsAppendOf()" allows whitespace content separators to be appended
            to the preceeding element.
            </para></remarks>
            <exception cref="T:System.InvalidOperationException">
            The collection is empty - or - contains no content character.
            </exception>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.RemoveTrailingContentSeparator(System.String)">
            <summary>
            Remove a potential trailing content separator from the <see cref="T:YAT.Domain.DisplayElementCollection"/>.
            </summary>
            <remarks>
            Needed to handle backspace, thus applies to data content only.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.RemoveRange(System.Int32,System.Int32)">
            <remarks>
            Required because <see cref="T:List`1.RemoveRange"/> doesn't call <see cref="M:YAT.Domain.DisplayElementCollection.RemoveAt(System.Int32)"/>
            method above because it is 'new'. Call to <see cref="M:YAT.Domain.DisplayElementCollection.RemoveAt(System.Int32)"/> method above is
            required to properly perform content counting.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.RemoveAll(System.Predicate{YAT.Domain.DisplayElement})">
            <remarks>
            Required because <see cref="T:List`1.RemoveAll"/> doesn't call <see cref="M:YAT.Domain.DisplayElementCollection.RemoveAt(System.Int32)"/>
            method above because it is 'new'. Call to <see cref="M:YAT.Domain.DisplayElementCollection.RemoveAt(System.Int32)"/> method above is
            required to properly perform content counting.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.Clear">
            <remarks>
            Required to properly perform content counting.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.ReplaceTimeStamp(System.DateTime,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Replaces all occurrences of <see cref="T:YAT.Domain.DisplayElement.TimeStampInfo"/> with the given arguments.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.ReplaceTimeSpan(System.TimeSpan,System.String,System.String,System.String)">
            <summary>
            Replaces all occurrences of <see cref="T:YAT.Domain.DisplayElement.TimeSpanInfo"/> with the given arguments.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.ReplaceTimeDelta(System.TimeSpan,System.String,System.String,System.String)">
            <summary>
            Replaces all occurrences of <see cref="T:YAT.Domain.DisplayElement.TimeDeltaInfo"/> with the given arguments.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.ReplaceDirection(YAT.Domain.Direction,System.String,System.String)">
            <summary>
            Replaces all occurrences of <see cref="T:YAT.Domain.DisplayElement.DirectionInfo"/> with the given arguments.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.Clone">
            <summary>
            Creates and returns a new object that is a deep-copy of this instance.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.CloneTo(YAT.Domain.DisplayElementCollection)">
            <summary>
            Clones this collection to the given collection.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.CloneTo(System.Int32,YAT.Domain.DisplayElementCollection,System.Int32)">
            <summary>
            Clones a range of this collection to the given collection.
            </summary>
            <remarks>
            Signature following <see cref="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)"/>.
            </remarks>
            <param name="index">The zero-based index in the source collection at which cloning begins.</param>
            <param name="collection">The collection that is the destination of the elements cloned to.</param>
            <param name="count">The number of items to copy.</param>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.ElementsToOrigin">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.ElementsToString">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.ToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.DisplayElementCollection.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElementCollection.ElementsToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.DisplayElementCollection.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="T:YAT.Domain.DisplayLine">
            <summary>
            Implements a display line containing a collection of display elements.
            </summary>
            <remarks>
            This class redirects to <see cref="T:YAT.Domain.DisplayElementCollection"/>. The purpose of this
            collection is to add functionality that explicitly applies to a line.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayLine.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayLine.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayLine.#ctor(YAT.Domain.DisplayElement)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayLine.#ctor(System.Collections.Generic.IEnumerable{YAT.Domain.DisplayElement})">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayLine.IsComplete">
            <summary>
            Indicates whether the line is complete, i.e. the collection of elements contains a
            <see cref="T:YAT.Domain.DisplayElement.LineBreak"/> at the end.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayLine.Clone">
            <summary>
            Creates and returns a new object that is a deep-copy of this instance.
            </summary>
        </member>
        <member name="T:YAT.Domain.DisplayLineCollection">
            <summary>
            Implements a collection of display lines.
            </summary>
            <remarks>
            This class redirects to <see cref="T:List`"/>. The sole purpose of this
            collection is orthogonality with <see cref="T:YAT.Domain.DisplayElementCollection"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayLineCollection.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayLineCollection.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayLineCollection.#ctor(System.Collections.Generic.IEnumerable{YAT.Domain.DisplayLine})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayLineCollection.Clone">
            <summary>
            Creates and returns a new object that is a deep-copy of this instance.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayLineCollection.CloneTo(YAT.Domain.DisplayLineCollection)">
            <summary>
            Clones this collection to the given collection.
            </summary>
        </member>
        <member name="T:YAT.Domain.Enclosure">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.EnclosureEx">
            <summary>
            Extended enum InfoEnclosureEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.EnclosureEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.Enclosure.None"/>.</summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.EnclosureEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.#ctor(YAT.Domain.Enclosure)">
            <remarks>
            Do not use with <see cref="F:YAT.Domain.Enclosure.Explicit"/> because that selection requires
            an enclosure string. Use <see cref="M:YAT.Domain.EnclosureEx.#ctor(System.String)"/> instead.
            </remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="enclosure"/> is <see cref="F:YAT.Domain.Enclosure.Explicit"/>. Use <see cref="M:YAT.Domain.EnclosureEx.#ctor(System.String)"/> instead.
            </exception>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.EnclosureEx.IsExplicit">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.ToEnclosure">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.ToEnclosureLeft">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.ToEnclosureRight">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.ToDescription">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.Trim(System.String)">
            <summary>
            Removes the enclosure strings from the given <see cref="T:System.String"/> object.
            </summary>
            <param name="str">The string to trim.</param>
            <returns>
            The string that remains after the enclosure has been removed from the given
            <see cref="T:System.String"/> object.
            </returns>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.Equals(YAT.Domain.EnclosureEx)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.op_Equality(YAT.Domain.EnclosureEx,YAT.Domain.EnclosureEx)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.op_Inequality(YAT.Domain.EnclosureEx,YAT.Domain.EnclosureEx)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.TryParse(System.String,YAT.Domain.EnclosureEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.TryParse(System.String,YAT.Domain.Enclosure@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.op_Implicit(YAT.Domain.EnclosureEx)~YAT.Domain.Enclosure">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.op_Explicit(YAT.Domain.Enclosure)~YAT.Domain.EnclosureEx">
            <remarks>
            Explicit because cast doesn't work for <see cref="F:YAT.Domain.Enclosure.Explicit"/>.
            </remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="enclosure"/> is <see cref="F:YAT.Domain.Enclosure.Explicit"/>.
            </exception>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.op_Implicit(YAT.Domain.EnclosureEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.EnclosureEx.op_Implicit(System.String)~YAT.Domain.EnclosureEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.ProcessState">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.ProcessState.Overall">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.ProcessState.Line">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.ProcessState.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.ProcessState.Reset">
            <summary>
            Resets the state, i.e. restarts processing with an empty repository.
            </summary>
        </member>
        <member name="M:YAT.Domain.ProcessState.NotifyLineBegin(System.DateTime,System.String,YAT.Domain.IODirection)">
            <summary>
            Notify the begin of a line, i.e. start processing of a line.
            </summary>
        </member>
        <member name="M:YAT.Domain.ProcessState.NotifyLineEnd">
            <summary>
            Notify the end of a line, i.e. continues processing with the next line.
            </summary>
        </member>
        <member name="T:YAT.Domain.OverallState">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.OverallState.DeviceLineBreak">
            <remarks>Dedicated sub-item to make scope obvious.</remarks>
        </member>
        <member name="P:YAT.Domain.OverallState.DirectionLineBreak">
            <remarks>Dedicated sub-item to make scope obvious.</remarks>
            <remarks>Only applies to <see cref="F:YAT.Domain.RepositoryType.Bidir"/>, still here for simplicity.</remarks>
        </member>
        <member name="P:YAT.Domain.OverallState.PreviousChunkTimeStamp">
            <remarks><see cref="M:YAT.Domain.OverallState.GetPreviousChunkTimeStamp"/> shall be used to retrieve property.</remarks>
        </member>
        <member name="P:YAT.Domain.OverallState.PreviousTxChunkTimeStamp">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.OverallState.PreviousRxChunkTimeStamp">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.OverallState.IsFirstLine">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.OverallState.PreviousLineTimeStamp">
            <remarks>'TimeStamp' implicitly means 'OfBeginningOfLine' of the previous line.</remarks>
        </member>
        <member name="P:YAT.Domain.OverallState.PostponedTxChunks">
            <remarks>Only applies to <see cref="F:YAT.Domain.RepositoryType.Bidir"/>, still here for simplicity.</remarks>
        </member>
        <member name="P:YAT.Domain.OverallState.PostponedRxChunks">
            <remarks>Only applies to <see cref="F:YAT.Domain.RepositoryType.Bidir"/>, still here for simplicity.</remarks>
        </member>
        <member name="M:YAT.Domain.OverallState.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.OverallState.InitializeValues">
            <summary>
            Initializes the state.
            </summary>
        </member>
        <member name="M:YAT.Domain.OverallState.Reset">
            <summary>
            Resets the state, i.e. restarts processing with an empty repository.
            </summary>
        </member>
        <member name="M:YAT.Domain.OverallState.NotifyChunk(YAT.Domain.RawChunk)">
            <summary>
            Notify the begin of a line, i.e. start processing of a line.
            </summary>
        </member>
        <member name="M:YAT.Domain.OverallState.GetPreviousChunkTimeStamp">
            <remarks>Method instead of property for orthogonality with <see cref="M:YAT.Domain.OverallState.GetPreviousChunkTimeStamp(YAT.Domain.IODirection)"/> below.</remarks>
        </member>
        <member name="M:YAT.Domain.OverallState.GetPreviousChunkTimeStamp(YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.OverallState.NotifyLineBegin(System.DateTime)">
            <summary>
            Notify the begin of a line, i.e. start processing of a line.
            </summary>
        </member>
        <member name="M:YAT.Domain.OverallState.NotifyLineEnd(System.DateTime)">
            <summary>
            Notify the end of a line, i.e. continues processing with the next line.
            </summary>
        </member>
        <member name="M:YAT.Domain.OverallState.AddPostponedChunk(YAT.Domain.RawChunk)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.OverallState.GetPostponedChunkCount">
            <remarks>Method instead of property for orthogonality with <see cref="M:YAT.Domain.OverallState.GetPostponedChunkCount(YAT.Domain.IODirection)"/> below.</remarks>
        </member>
        <member name="M:YAT.Domain.OverallState.GetPostponedChunkCount(YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.OverallState.GetPostponedByteCount">
            <remarks>Method instead of property for orthogonality with <see cref="M:YAT.Domain.OverallState.GetPostponedChunkCount"/> above.</remarks>
        </member>
        <member name="M:YAT.Domain.OverallState.GetFirstPostponedChunk">
            <remarks>Method instead of property for orthogonality with other "Postponed" methods above.</remarks>
        </member>
        <member name="M:YAT.Domain.OverallState.GetFirstPostponedChunkTimeStamp(YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.OverallState.RemovePostponedChunks(YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DeviceState">
            <remarks>Named "Device" for simplicity even though using "I/O Device" for view.</remarks>
        </member>
        <member name="P:YAT.Domain.DeviceState.IsFirstChunk">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DeviceState.Device">
            <remarks>Named "Device" for simplicity even though using "I/O Device" for view.</remarks>
        </member>
        <member name="M:YAT.Domain.DeviceState.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DeviceState.InitializeValues">
            <summary>
            Initializes the state.
            </summary>
        </member>
        <member name="M:YAT.Domain.DeviceState.Reset">
            <summary>
            Resets the state, i.e. restarts processing with an empty repository.
            </summary>
        </member>
        <member name="T:YAT.Domain.DirectionState">
            <remarks>Named "Device" for simplicity even though using "I/O Device" for view.</remarks>
        </member>
        <member name="P:YAT.Domain.DirectionState.IsFirstChunk">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DirectionState.Direction">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DirectionState.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DirectionState.InitializeValues">
            <summary>
            Initializes the state.
            </summary>
        </member>
        <member name="M:YAT.Domain.DirectionState.Reset">
            <summary>
            Resets the state, i.e. restarts processing with an empty repository.
            </summary>
        </member>
        <member name="T:YAT.Domain.LineState">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.LineState.Position">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.LineState.TimeStamp">
            <remarks>'TimeStamp' implicitly means 'OfBeginningOfLine'.</remarks>
        </member>
        <member name="P:YAT.Domain.LineState.Device">
            <remarks>Named "Device" for simplicity even though using "I/O Device" for view.</remarks>
        </member>
        <member name="P:YAT.Domain.LineState.Direction">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.LineState.Elements">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.LineState.Highlight">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.LineState.Exceeded">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.LineState.#ctor">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.LineState.IsYetEmpty">
            <summary>
            Indicates that line is yet empty.
            </summary>
        </member>
        <member name="M:YAT.Domain.LineState.InitializeValues">
            <summary>
            Initializes the state.
            </summary>
        </member>
        <member name="M:YAT.Domain.LineState.Reset">
            <summary>
            Resets the state, i.e. restarts processing with an empty line.
            </summary>
        </member>
        <member name="M:YAT.Domain.LineState.NotifyLineBegin(System.DateTime,System.String,YAT.Domain.IODirection)">
            <summary>
            Notify the begin of a line, i.e. start processing of a line.
            </summary>
        </member>
        <member name="M:YAT.Domain.LineState.NotifyLineEnd">
            <summary>
            Notify the end of a line, i.e. continues processing with the next line.
            </summary>
        </member>
        <member name="T:YAT.Domain.Terminal">
            <remarks>
            This partial class implements the process part of <see cref="T:YAT.Domain.Terminal"/>.
            </remarks>
            <remarks>
            This partial class implements the repositories part of <see cref="T:YAT.Domain.Terminal"/>.
            </remarks>
             <remarks>
             This partial class implements the send part of <see cref="T:YAT.Domain.Terminal"/>.
             </remarks>
             <remarks>
            
             Design Criteria
             ---------------
            
             Decoupling from calling thread (typically the main thread) is required for:
              > All below calling sequences (in order to not potentially block the main thread).
            
             Sequencing is required for the following calling sequences, because all...
              >                            [ByteArray > Item  > Raw] ...chunks of a byte array...
              >                [Line/LinePart/EOL/... > Items > Raw] ...chunks of a line/linepart/EOL...
              >        [Lines > Line                  > Items > Raw] ...lines of a multi-line command...
              > [File > Lines > Line                  > Items > Raw] ...lines of a file...
                                                                     ...must be sequential.
             At the same time, concurrency may make sense when the following keywords are active, because...
              > <code>\!(Delay(...))</code>
              > <code>\!(LineDelay(...))</code>
              > <code>\!(LineInterval(...))</code>                   ...any kind of delaying must not block other commands...
              > <code>\!(LineRepeat(...))</code>                     ...same as any kind of repeating...
             ...as well as sending a command while a file is being sent.
            
             Furthermore, commands shall be "kept together", no matter whether single- or multi-line text or file.
            
             Potential Appproaches
             ---------------------
            
             0. Implementation as up to YAT 2.1.0:
                 >                                                             [ByteArray > sendDataQueue > SendDataThread > Item  > Raw]
                 >                                                 [Line/LinePart/EOL/... > sendDataQueue > SendDataThread > Items > Raw]
                 >                                         [Lines > Line                  > sendDataQueue > SendDataThread > Items > Raw]
                 > [File > sendFileQueue > SendFileThread > Lines > Line                  > sendDataQueue > SendDataThread > Items > Raw]
                   +/- Purely sequential, but not capable of concurrent sending.
                   +/- Implementation relies on non-concurrent sending, no prevention of line(s) being requested while file is ongoing.
             1. Invocation only when needed:
                 > Same as above, but <code>\!(LineRepeat(...))</code> results in Invoke().
                    +  Good enough in most cases.
                    +  Easy upgrade path from implementation as up to YAT 2.1.0.
                    -  Inconsistent.
                   --- An embedded e.g. <code>\!(LineRepeat(5))</code> will no longer be sequential with subsequent lines!
             2. Immediate invocation per request:
                 >                                                  [ByteArray > Invoke() > Item  > Raw]
                 >                                      [Line/LinePart/EOL/... > Invoke() > Items > Raw]
                 >                   [Lines > Invoke() > Line                             > Items > Raw]
                 > [File > Invoke() > Lines            > Line                             > Items > Raw]
                   --- Invoke() doesn't guarantee sequence! Quickly requesting two different commands,
                       e.g. by quickly clicking two buttons, may result in wrong command order!
                   --- Requirement of commands being "kept together" is no longer met!
             3. Immediate invocation per request with addition sequence number handling and locks:
                 >                                                                                                  [ByteArray > Invoke(seqNum) > WaitFor(seqNum) > Item  > Confirm(seqNum) > Raw]
                 >                                                                                      [Line/LinePart/EOL/... > Invoke(seqNum) > WaitFor(seqNum) > Items > Confirm(seqNum) > Raw]
                 >                                           [Lines > Invoke(seqNum) > WaitFor(seqNum) > Line                  > Invoke(seqNum) > WaitFor(seqNum) > Items > Confirm(seqNum) > Raw]
                 > [File > Invoke(seqNum) > WaitFor(seqNum) > Lines                                    > Line                  > Invoke(seqNum) > WaitFor(seqNum) > Items > Confirm(seqNum) > Raw]
                    +  No longer need for two subsequent queues in case of file sending.
                    +  Purely sequential implementation for each request, should also be relatively easy to debug.
                   +++ All requirements met, configurable behavior implementable.
                    -  Requires quite some refactoring...
            
             Conclusion
             ----------
            
             > The sum of all requirements conflict with each other, especially the request to allow concurrent sending.
             > An additional [Settings... > Advanced... > Send > Allow concurrent sending] is required.
             > Only approach 3. fulfills the requirements.
            
             </remarks>
            <summary>
            Terminal with byte/string functionality and settings.
            </summary>
            <remarks>
            Terminal and its specializations <see cref="T:YAT.Domain.TextTerminal"/> and <see cref="T:YAT.Domain.BinaryTerminal"/>
            implement the method pattern. Terminal provides general processing and formatting functions,
            its specializations add additional functionality.
            </remarks>
            <remarks>
            This class is implemented using partial classes separating sending/repositories/processing
            functionality. Using partial classes rather than aggregated sender, repositories, processor,...
            so far for these reasons:
            <list type="bullet">
            <item><description>Simpler for implementing text/binary specialization</description></item>
            <item><description>Simpler for implementing synchronization among Tx and Rx.</description></item>
            <item><description>Less simple-stupid-forwarder, e.g. directly raising events.</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj">
            <summary>
            Synchronize processing (raw chunk | timed line break).
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ByteToElement(System.Byte,System.DateTime,YAT.Domain.IODirection,System.Collections.Generic.List{System.Byte})">
            <remarks>
            Terminals supporting other than <see cref="P:System.Text.Encoding.IsSingleByte"/> require a state to accumulate multi-byte sequences.
            This is provided by <paramref name="pendingMultiBytesToDecode"/>. Knowing that it seems a bit weird to find something
            called "multi-byte" in the signature of a method called "byte", this is the most appropriate approach found so far.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ByteToElement(System.Byte,System.DateTime,YAT.Domain.IODirection,YAT.Domain.Radix,System.Collections.Generic.List{System.Byte})">
            <remarks>
            Terminals supporting other than <see cref="P:System.Text.Encoding.IsSingleByte"/> require a state to accumulate multi-byte sequences.
            This is provided by <paramref name="pendingMultiBytesToDecode"/>. Knowing that it seems a bit weird to find something
            called "multi-byte" in the signature of a method called "byte", this is the most appropriate approach found so far.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ByteToText(System.Byte,System.DateTime,YAT.Domain.Radix,System.Boolean@,System.Boolean@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.IsByteToHide(System.Byte)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ByteToCharacterString(System.Byte)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ByteToAsciiString(System.Byte)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ByteToNumericRadixString(System.Byte,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.UnicodeValueToNumericString(System.UInt16)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ByteToControlCharReplacementString(System.Byte,YAT.Domain.ControlCharRadix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.CreateDataElement(System.Byte,System.DateTime,YAT.Domain.IODirection,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.CreateDataElement(System.Byte[],System.DateTime,YAT.Domain.IODirection,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.CreateControlElement(System.Byte,System.DateTime,YAT.Domain.IODirection,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RadixIsStringOrChar(YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RadixIsStringOrChar(YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RadixUsesContentSeparator(YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RadixUsesContentSeparator(YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ContentSeparatorIsUsedAndNotEmpty(YAT.Domain.IODirection)">
            <summary>
            Determines whether a separator is necessary.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.AddContentSeparatorAsNeeded(YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection,YAT.Domain.DisplayElement)">
            <summary>
            Add a separator to the given collection, depending on the given state.
            </summary>
            <remarks>
            Non-line-state dependent implementation for e.g. <see cref="M:YAT.Domain.Terminal.Format(System.Byte[],YAT.Domain.IODirection,YAT.Domain.Radix)"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.AddContentSeparatorAsNeeded(YAT.Domain.LineState,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection,YAT.Domain.DisplayElement)">
            <summary>
            Add a separator to the given collection, depending on the given state.
            </summary>
            <remarks>
            This default implementation is based on <see cref="P:YAT.Domain.DisplayElementCollection.ByteCount"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.RemoveContentSeparatorAsNeeded(YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.InfoSeparatorIsNotEmpty">
            <summary>
            Determines whether a separator is necessary.
            </summary>
            <remarks>
            Method instead of property for orthogonality with <see cref="M:YAT.Domain.Terminal.ContentSeparatorIsUsedAndNotEmpty(YAT.Domain.IODirection)"/> above.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.AddInfoSeparatorAsNeeded(YAT.Domain.DisplayElementCollection)">
            <summary>
            Add a separator to the given collection, depending on the given state.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.PrepareLineBeginInfo(System.DateTime,System.TimeSpan,System.TimeSpan,System.String,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.PrepareLineEndInfo(System.Int32,System.TimeSpan,YAT.Domain.DisplayElementCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.InitializeProcess">
            <remarks>
            <c>private</c> rather than <c>protected virtual</c> because derived method(s) depend(s)
            on code sequence in constructor(s).
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DisposeProcess">
            <summary>
            Disposes the processing state.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ResetProcess(YAT.Domain.RepositoryType)">
            <summary>
            Resets the processing state for the given <paramref name="repositoryType"/>.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.GetProcessState(YAT.Domain.RepositoryType)">
            <remarks>
            This method shall not be overridden as it accesses the private members
            <see cref="F:YAT.Domain.Terminal.txProcessState"/>, <see cref="F:YAT.Domain.Terminal.bidirProcessState"/> and <see cref="F:YAT.Domain.Terminal.rxProcessState"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.GetOverallState(YAT.Domain.RepositoryType)">
            <remarks>
            This method shall not be overridden, same as <see cref="M:YAT.Domain.Terminal.GetProcessState(YAT.Domain.RepositoryType)"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.GetLineState(YAT.Domain.RepositoryType)">
            <remarks>
            This method shall not be overridden, same as <see cref="M:YAT.Domain.Terminal.GetProcessState(YAT.Domain.RepositoryType)"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.GetUnidirLineState(YAT.Domain.IODirection)">
            <remarks>
            This method shall not be overridden as it accesses the private members
            <see cref="F:YAT.Domain.Terminal.txProcessState"/> and <see cref="F:YAT.Domain.Terminal.rxProcessState"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.GetOtherDirection(YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.CreateCollectionIfIsNull(YAT.Domain.DisplayElementCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.CreateCollectionIfIsNull(YAT.Domain.DisplayLineCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessChunk(YAT.Domain.RawChunk)">
             <summary>
             This processing method is called by the <see cref="E:YAT.Domain.RawTerminal.ChunkSent"/> and
             <see cref="E:YAT.Domain.RawTerminal.ChunkReceived"/> event handlers. It sequentially updates the
             two affected repositories.
             </summary>
             <remarks>
             Before introduction of <see cref="P:YAT.Domain.Settings.TextTerminalSettings.GlueCharsOfLine"/>, processing
             happened simultaneously byte-by-byte for both affected repositories, rather than whole
             chunk for first and then second affected repository. However, glueing requires that the
             part of a chunk after a line break may by postponed, and glueing only applies to bidir.
             Thus, with YAT 2.4.0, processing changed to the current strategy.
             </remarks>
             <remarks>
             This method must synchronize against <see cref="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj"/>!
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessChunk(YAT.Domain.RepositoryType,YAT.Domain.RawChunk)">
             <summary>
             This processing method is called by the <see cref="M:YAT.Domain.Terminal.ProcessChunk(YAT.Domain.RawChunk)"/> method
             as well as the <see cref="M:YAT.Domain.Terminal.RefreshRepository(YAT.Domain.RepositoryType)"/> and <see cref="M:YAT.Domain.Terminal.RefreshRepositories"/>
             methods on reloading. It only affects one of the repositories.
             </summary>
             <remarks>
             This method must synchronize against <see cref="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj"/>!
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessChunksOfSameDirection(YAT.Domain.RepositoryType,YAT.Domain.RawChunk[],YAT.Domain.IODirection,YAT.Domain.PostponeResult@)">
             <remarks>
             The caller of this method must synchronize against <see cref="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj"/>!
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.PostponeRemainingChunks(YAT.Domain.RepositoryType,YAT.Domain.RawChunk[],System.Int32,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessPostponedChunks(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.SuspendChunkTimeouts(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ResumeChunkTimeouts(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessChunkPre(YAT.Domain.RepositoryType,YAT.Domain.RawChunk)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessChunkPost(YAT.Domain.RepositoryType,YAT.Domain.RawChunk)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessChunk(YAT.Domain.RepositoryType,YAT.Domain.RawChunk,YAT.Domain.PostponeResult@)">
             <remarks>
             The caller of this method must synchronize against <see cref="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj"/>!
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.PostponeRemainingBytes(YAT.Domain.RepositoryType,YAT.Domain.RawChunk,System.Int32,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.PostponeChunk(YAT.Domain.RepositoryType,YAT.Domain.RawChunk)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RepositoryIsAffected(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalTimedLineBreakOnReloadIfNeeded(YAT.Domain.RepositoryType,YAT.Domain.RawChunk)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalTimedLineBreakOnReloadIfNeeded(YAT.Domain.RepositoryType,System.DateTime,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalDeviceOrDirectionLineBreakIfNeeded(YAT.Domain.RepositoryType,YAT.Domain.RawChunk)">
            <summary>Check whether device or direction has changed.</summary>
            <remarks>A chunk is always tied to device and direction.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalChunkAttributes(YAT.Domain.RepositoryType,YAT.Domain.RawChunk)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalChunkLineBreakIfNeeded(YAT.Domain.RepositoryType,YAT.Domain.RawChunk)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalDeviceLineBreak(YAT.Domain.RepositoryType,System.DateTime,System.String,YAT.Domain.IODirection)">
            <remarks>Named "Device" for simplicity even though using "I/O Device" for view.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalDirectionLineBreak(YAT.Domain.RepositoryType,System.DateTime,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalDirection(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalChunkContent(YAT.Domain.RepositoryType,YAT.Domain.RawChunk,System.Int32@)">
            <remarks>
            Before introduction of <see cref="P:YAT.Domain.Settings.TextTerminalSettings.GlueCharsOfLine"/>, processing
            happened simultaneously byte-by-byte for both affected repositories, rather than whole
            chunk for first and then second affected repository. However, glueing requires that the
            part of a chunk after a line break may by postponed, and glueing only applies to bidir.
            Thus, with YAT 2.4.0, processing changed to the current strategy.
            </remarks>
            <remarks>
            Signaling is only done once per chunk (unless flushing is involved), in order to improve
            performance (by reducing the number of events and repository updates).
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessByteOfChunk(YAT.Domain.RepositoryType,System.Byte,System.DateTime,System.String,YAT.Domain.IODirection,System.Boolean,System.Boolean,YAT.Domain.DisplayElementCollection@,YAT.Domain.DisplayLineCollection@,System.Boolean@)">
            <remarks>
            Must be abstract/virtual because settings and behavior differ among text and binary.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalChunkLineBreak(YAT.Domain.RepositoryType,System.DateTime,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalTimedLineBreak(YAT.Domain.RepositoryType,System.DateTime,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessAndSignalTimedLineBreakOnReload(YAT.Domain.RepositoryType,System.DateTime,YAT.Domain.IODirection,System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessDirection(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <remarks>Nothing to signal (yet).</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessDeviceLineBreak(YAT.Domain.RepositoryType,System.DateTime,System.String,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection@,YAT.Domain.DisplayLineCollection@)">
            <remarks>Named "Device" for simplicity even though using "I/O Device" for view.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DeviceHasChanged(System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessDirectionLineBreak(YAT.Domain.RepositoryType,System.DateTime,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection@,YAT.Domain.DisplayLineCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.DirectionHasChanged(YAT.Domain.IODirection,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessChunkLineBreak(YAT.Domain.RepositoryType,System.DateTime,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection@,YAT.Domain.DisplayLineCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessTimedLineBreak(YAT.Domain.RepositoryType,System.DateTime,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection@,YAT.Domain.DisplayLineCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessTimedLineBreakOnReload(YAT.Domain.RepositoryType,System.DateTime,YAT.Domain.IODirection,System.Int32,YAT.Domain.DisplayElementCollection@,YAT.Domain.DisplayLineCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.Add(YAT.Domain.RepositoryType,YAT.Domain.DisplayElementCollection,YAT.Domain.DisplayLineCollection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.PropagateHighlight(YAT.Domain.RepositoryType,YAT.Domain.DisplayLineCollection)">
            <summary>
            E.g. a model's automatic action or response may activate the 'Highlight' state
            on the elements. This state must be propagated to the corresponding line(s).
            </summary>
            <remarks>
            This implementation is not ideal, as a feedback from the model via this domain
            is included, but considered good enough.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoLineBegin(YAT.Domain.RepositoryType,YAT.Domain.ProcessState,System.DateTime,System.String,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection@)">
            <remarks>
            <paramref name="repositoryType"/> and <paramref name="elementsToAdd"/> are required
            for specialization by <see cref="T:YAT.Domain.BinaryTerminal"/> and <see cref="T:YAT.Domain.TextTerminal"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoLineEnd(YAT.Domain.RepositoryType,YAT.Domain.ProcessState,System.DateTime,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection@,YAT.Domain.DisplayLineCollection@)">
            <remarks>
            <paramref name="repositoryType"/>, <paramref name="ts"/>,
            <paramref name="elementsToAdd"/> and <paramref name="linesToAdd"/> are required
            for specialization by <see cref="T:YAT.Domain.BinaryTerminal"/> and <see cref="T:YAT.Domain.TextTerminal"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.Flush(YAT.Domain.RepositoryType,YAT.Domain.DisplayElementCollection,YAT.Domain.DisplayLineCollection)">
            <remarks>Named 'Flush' to emphasize pending elements and lines are signaled and cleared.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.FlushReplaceAlreadyBeganLine(YAT.Domain.RepositoryType,YAT.Domain.LineState)">
            <remarks>Named 'Flush' to emphasize pending elements and lines are signaled and cleared.</remarks>
            <remarks>Named 'Began' for consistency with <see cref="F:YAT.Domain.LinePosition.Begin"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.FlushClearAlreadyBeganLine(YAT.Domain.RepositoryType,YAT.Domain.ProcessState,YAT.Domain.DisplayElementCollection,YAT.Domain.DisplayLineCollection)">
            <remarks>Named 'Flush' to emphasize pending elements and lines are signaled and cleared.</remarks>
            <remarks>Named 'Began' for consistency with <see cref="F:YAT.Domain.LinePosition.Begin"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.SuspendTimedLineBreakIfNeeded(YAT.Domain.IODirection)">
            <remarks>
            Chunk and timed processing is synchronized against <see cref="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj"/>.
            Thus, time line breaks can be suspended during chunk processing.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ResumeTimedLineBreakIfNeeded(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <remarks>
            Chunk and timed processing is synchronized against <see cref="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj"/>.
            Thus, time line breaks can be suspended during chunk processing.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.txTimedLineBreak_Elapsed(System.Object,MKY.EventArgs{System.DateTime})">
             <remarks>
             This event handler must synchronize against <see cref="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj"/>!
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.rxTimedLineBreak_Elapsed(System.Object,MKY.EventArgs{System.DateTime})">
             <remarks>
             This event handler must synchronize against <see cref="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj"/>!
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugChunks(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugLineBreak(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugLineBreak(YAT.Domain.RepositoryType,System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ClearRepository(YAT.Domain.RepositoryType)">
            <remarks>See remarks in <see cref="M:YAT.Domain.Terminal.RefreshRepositories"/> below.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ClearRepositories">
            <remarks>See remarks in <see cref="M:YAT.Domain.Terminal.RefreshRepositories"/> below.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.RefreshRepository(YAT.Domain.RepositoryType)">
            <remarks>See remarks in <see cref="M:YAT.Domain.Terminal.RefreshRepositories"/> below.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.RefreshRepositories">
            <remarks>
            Alternatively, clear/refresh/empty operations could be implemented asynchronously.
            Advantages:
             > Already synchronized onto main thread.
             > No deadlock possible below.
             > No deadlock possible with async process such as e.g. timed line breaks or glue time-out.
               (Currently mitigated by doing separate handling 'OnReload'.)
            Disadvantages:
             > User does not get immediate feedback that a time consuming operation is taking place.
             > User actually cannot trigger any other operation.
             > Other synchronization issues?
            Therefore, decided to keep the implementation synchronous until new issues pop up.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.EmptyRepositories">
            <remarks>See remarks in <see cref="M:YAT.Domain.Terminal.RefreshRepositories"/> above.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.GetRepositoryByteCount(YAT.Domain.RepositoryType)">
            <remarks>
            Note that value reflects the byte count of the elements contained in the repository,
            i.e. the byte count of the elements shown. The value thus not necessarily reflects the
            total byte count of a sent or received sequence, a hidden EOL is e.g. not reflected.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.GetRepositoryLineCount(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RepositoryToDisplayElements(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RepositoryToDisplayLines(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.LastDisplayLineAuxiliary(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ClearLastDisplayLineAuxiliary(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RepositoryToString(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RepositoryToExtendedDiagnosticsString(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RepositoryToExtendedDiagnosticsString(YAT.Domain.RepositoryType,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RepositoryToRawChunks(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.CreateRepositories(YAT.Domain.Settings.TerminalSettings)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.CreateRepositories(YAT.Domain.Terminal)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.AddDisplayElement(YAT.Domain.IODirection,YAT.Domain.DisplayElement)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.AddDisplayElement(YAT.Domain.RepositoryType,YAT.Domain.DisplayElement)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.AddDisplayElements(YAT.Domain.RepositoryType,YAT.Domain.DisplayElementCollection)">
            <remarks>
            Using <see cref="T:YAT.Domain.DisplayElementCollection"/> instead of <see cref="T:System.Collections.Generic.IEnumerable`1"/> of
            <see cref="T:YAT.Domain.DisplayElement.InlineElement"/> for <paramref name="elements"/> in order to
            ease cloning.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.InlineDisplayElement(YAT.Domain.IODirection,YAT.Domain.DisplayElement.InlineElement)">
            <summary>
            Inlines the given element into the data/control content of the related repositories.
            </summary>
            <remarks>
            Opposed to the 'AddDisplayElement...' methods, the 'InlineDisplayElement...' methods
            automatically insert a space if necessary.
            </remarks>
            <remarks>
            Explicit <paramref name="direction"/> because <see cref="P:YAT.Domain.DisplayElement.Direction"/>
            may be <see cref="F:YAT.Domain.Direction.None"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.InlineDisplayElements(YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection)">
            <summary>
            Inlines the given element into the data/control content of the related repositories.
            </summary>
            <remarks>
            Opposed to the 'AddDisplayElement...' methods, the 'InlineDisplayElement...' methods
            automatically insert a space if necessary.
            </remarks>
            <remarks>
            Explicit <paramref name="direction"/> because <see cref="P:YAT.Domain.DisplayElement.Direction"/>
            may be <see cref="F:YAT.Domain.Direction.None"/>.
            </remarks>
            <remarks>
            Using <see cref="T:YAT.Domain.DisplayElementCollection"/> instead of <see cref="T:System.Collections.Generic.IEnumerable`1"/> of
            <see cref="T:YAT.Domain.DisplayElement.InlineElement"/> for <paramref name="elements"/> in order to
            ease cloning.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.InlineDisplayElement(YAT.Domain.RepositoryType,YAT.Domain.IODirection,YAT.Domain.DisplayElement.InlineElement)">
            <remarks>
            Helper method to ease handling direction/repositories.
            </remarks>
            <remarks>
            Opposed to the 'AddDisplayElement...' methods, the 'InlineDisplayElement...' methods
            automatically insert a space if necessary.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.InlineDisplayElements(YAT.Domain.RepositoryType,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection)">
            <remarks>
            Helper method to ease handling direction/repositories.
            </remarks>
            <remarks>
            Opposed to the 'AddDisplayElement...' methods, the 'InlineDisplayElement...' methods
            automatically insert a space if necessary.
            </remarks>
            <remarks>
            Using <see cref="T:YAT.Domain.DisplayElementCollection"/> instead of <see cref="T:System.Collections.Generic.IEnumerable`1"/> of
            <see cref="T:YAT.Domain.DisplayElement.InlineElement"/> for <paramref name="elements"/> in order to
            ease cloning.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ReplaceCurrentDisplayLine(YAT.Domain.RepositoryType,YAT.Domain.DisplayElementCollection)">
            <remarks>
            Using <see cref="T:YAT.Domain.DisplayElementCollection"/> instead of <see cref="T:System.Collections.Generic.IEnumerable`1"/> of
            <see cref="T:YAT.Domain.DisplayElement.InlineElement"/> for <paramref name="currentLineElements"/>
            in order to ease cloning.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ClearCurrentDisplayLine(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.AddDisplayLine(YAT.Domain.RepositoryType,YAT.Domain.DisplayLine)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.AddDisplayLines(YAT.Domain.RepositoryType,YAT.Domain.DisplayLineCollection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ClearMyRepository(YAT.Domain.RepositoryType)">
            <remarks>Named 'My' for distinction with <see cref="M:YAT.Domain.Terminal.ClearRepository(YAT.Domain.RepositoryType)"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.FinishReload(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.DoFinishReload(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.ApproximateTypicalNumberOfBytesPerMillisecond">
             <summary>
             The cached <see cref="P:YAT.Domain.Settings.IOSettings.ApproximateTypicalNumberOfBytesPerMillisecond"/> value.
             </summary>
             <remarks>
             Value is approximate! It may be off by a factor of 2..5, depending on environment and I/O related settings!
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="F:YAT.Domain.Terminal.previousRequestedSequenceNumber">
             <summary>
             The sequence number of the next send request.
             </summary>
             <remarks>
             The number is needed to properly sequence send requests. See design consideration above.
             </remarks>
             <remarks>
             "A\!(LineRepeat)" throughput is approx. 5'000 lines per second (YAT 2.1.0). This will
             also be the uppermost limit when sending different commands from a script. Using an
             enormous safety margin of 100'000 lines per second this results in a worst case of
             3'153'600'000'000 lines per year (31'536'000 seconds per year). Thus, <see cref="T:System.Int32"/>
             is not good enough, but <see cref="T:System.Int64"/> is more than good enough, its 9E+18 results
             in approx. 300E+9 years!
            
             Note that <see cref="M:System.Threading.Interlocked.Increment(System.Int64@)"/> is used for incrementing. That
             method will "handle an overflow condition by wrapping" and "no exception is thrown".
             Such loop around would not work in the (unlikely) case where a repeating command e.g.
             has sequence number 1 and single-line commands loop around. But since this will not
             happen in magnitude of years this case is neglected for ease of implementation.
            
             Also note that <see cref="T:System.UInt64"/> is not used since <see cref="T:System.Threading.Interlocked"/> only
             supports <see cref="T:System.Int64"/>.
             </remarks>
        </member>
        <member name="P:YAT.Domain.Terminal.SendThreadsArePermitted">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.IsReadyToSend">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.IsReadyToSendForSomeTime">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.IsSending">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.IsSendingForSomeTime">
            <remarks>
            Opposed to <see cref="P:YAT.Domain.Terminal.IsSending"/>, this property only becomes <c>true</c> when
            sending has been ongoing for more than <see cref="F:YAT.Domain.Utilities.ForSomeTimeEventHelper.Threshold"/>,
            or is about to be ongoing for more than <see cref="F:YAT.Domain.Utilities.ForSomeTimeEventHelper.Threshold"/>.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Terminal.BreakState">
            <summary>
            Returns the current break state.
            </summary>
        </member>
        <member name="P:YAT.Domain.Terminal.DoBreak">
            <remarks>
            Break if requested or terminal has stopped or closed.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.SendRaw(System.Byte[])">
            <remarks>Method name and signature intentionally results in "send raw data".</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendRaw(System.Byte[],System.Int64)">
            <remarks>This method will be called asynchronously.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.SendText(System.String,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendText(YAT.Domain.TextSendItem,System.Int64)">
            <remarks>This method will be called asynchronously.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.SendTextLine(System.String,YAT.Domain.Radix)">
            <remarks>
            Parameter <paramref name="text"/> is not named "line" because e.g. the text EOL sequence will be appended later by the underlying terminal.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendTextLine(YAT.Domain.TextSendItem,System.Int64)">
            <remarks>This method will be called asynchronously.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.SendTextLines(System.String[],YAT.Domain.Radix)">
            <remarks>
            Required to allow sending multi-line commands "kept together".
            </remarks>
            <remarks>
            Parameter <paramref name="texts"/> is not named "lines" because e.g. the text EOL sequence will be appended later by the underlying terminal.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendTextLines(System.Collections.Generic.List{YAT.Domain.TextSendItem},System.Int64)">
            <remarks>This method will be called asynchronously.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.SendFile(System.String,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendFile(YAT.Domain.FileSendItem,System.Int64)">
            <remarks>This method will be called asynchronously.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.InitializeSend">
            <remarks>
            <c>private</c> rather than <c>protected virtual</c> because derived method(s) depend(s)
            on code sequence in constructor(s).
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DisposeSend">
            <summary>
            Disposes the processing state.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.PermitSendThreads">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.BreakSendThreads">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RequestPre">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.TryEnterRequestGate(YAT.Domain.Utilities.ForSomeTimeEventHelper,System.Int64)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.LeaveRequestGate">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RequestPost(System.Boolean)">
            <remarks>
            The next permitted sequence number must be incremented even when the request gate could
            not be entered, because the sequence number already got assigned. Without incrementing,
            all subsequent requests would get blocked. This cannot be the idea of the mechanism.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.TryEnterPacketGate(YAT.Domain.Utilities.ForSomeTimeEventHelper)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.LeavePacketGate">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendPre">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendPost">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendRawData(YAT.Domain.Utilities.ForSomeTimeEventHelper,System.Byte[])">
            <remarks>
            Named 'RawData' following 'TextItem' terminology ("raw" vs. "text").
            <list type="bullet">
            <item><description>'Raw' instead of 'Text'.</description></item>
            <item><description>'Data' instead of 'Item' as there is no 'RawItem'.</description></item>
            </list>
            </remarks>
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendTextItem(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.TextSendItem)">
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendText(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.Parser.Result[],System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessInLineKeywords(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.Parser.KeywordResult,System.Collections.Generic.Queue{System.Byte},System.Boolean@,System.Boolean@)">
            <remarks>Shall not be called if keywords are disabled.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessLineEnd(YAT.Domain.Utilities.ForSomeTimeEventHelper,System.Boolean,System.Collections.Generic.Queue{System.Byte},System.Boolean@)">
            <remarks>For binary terminals, this is rather a 'ProcessPacketEnd'.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ProcessLineDelayOrInterval(YAT.Domain.Utilities.ForSomeTimeEventHelper,System.Boolean,System.Int32,System.Boolean,System.Int32,System.DateTime,System.DateTime)">
            <remarks>For binary terminals, this is rather a 'ProcessPacketDelayOrInterval'.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.CreateParserErrorMessage(System.String,System.String)">
            <summary>
            Creates a parser error message which can be displayed in the terminal.
            </summary>
            <param name="textToParse">The string to be parsed.</param>
            <param name="successfullyParsed">The substring that could successfully be parsed.</param>
            <returns>The error message to display.</returns>
        </member>
        <member name="M:YAT.Domain.Terminal.AppendTimeStampToPendingPacketWithoutForwardingToRawTerminalYet(YAT.Domain.Parser.Result[],System.Collections.Generic.Queue{System.Byte})">
            <remarks>Explicitly named "TimeStamp" to make purpose more obvious. Could also be renamed to "ByteResults".</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.AppendToPendingPacketWithoutForwardingToRawTerminalYet(System.Byte[],System.Collections.Generic.Queue{System.Byte})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.BreakPendingPacket(System.Collections.Generic.Queue{System.Byte})">
            <remarks>
            Not the best approach to require to call this method at so many locations...
            </remarks>
            <remarks>
            Named 'Packet' rather than 'Chunk' to emphasize difference to <see cref="E:YAT.Domain.Terminal.RawChunkSent"/>
            which corresponds to the chunks effectively sent by the underlying I/O instance.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ForwardPendingPacketToRawTerminal(System.Collections.Generic.Queue{System.Byte})">
            <remarks>
            Not the best approach to require to call this method at so many locations...
            </remarks>
            <remarks>
            Named 'Packet' rather than 'Chunk' to emphasize difference to <see cref="E:YAT.Domain.Terminal.RawChunkSent"/>
            which corresponds to the chunks effectively sent by the underlying I/O instance.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ForwardPacketToRawTerminal(System.Byte[])">
            <remarks>
            Named 'Packet' rather than 'Chunk' to emphasize difference to <see cref="E:YAT.Domain.Terminal.RawChunkSent"/>
            which corresponds to the chunks effectively sent by the underlying I/O instance.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.TryChangeSettingsOnTheFly(MKY.IO.Serial.SerialPort.SerialPortSettings,System.Exception@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendFileItem(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.FileSendItem)">
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendTextFileItem(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.FileSendItem)">
            <remarks>
            Text terminals are <see cref="T:System.Text.Encoding"/> aware, binary terminals are not.
            </remarks>
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendTextFileItem(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.FileSendItem,System.Text.Encoding)">
            <remarks>
            Text terminals are <see cref="T:System.Text.Encoding"/> aware, binary terminals are not.
            </remarks>
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendXmlFileItem(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.FileSendItem)">
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendFileLine(YAT.Domain.Utilities.ForSomeTimeEventHelper,System.String,YAT.Domain.Radix)">
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DoSendFileChunk(YAT.Domain.Utilities.ForSomeTimeEventHelper,System.Byte[])">
            <remarks>
            <see cref="P:YAT.Domain.FileSendItem.DefaultRadix"/> is not used for sending raw files.
            This fact is considered in 'View.Controls.SendFile.SetRecentAndCommandControls()'.
            Changes in behavior here will have to be adapted in that control method as well.
            </remarks>
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ActivateBreak">
            <summary>
            Breaks all currently ongoing operations in the terminal.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ResumeBreak">
            <summary>
            Resumes all currently suspended operations in the terminal.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.IncrementIsSendingChanged">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.DecrementIsSendingChanged">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnIsSendingChanged(System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnIsSendingChanged(MKY.EventArgs{System.Boolean})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.IncrementIsSendingForSomeTimeChanged">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.DecrementIsSendingForSomeTimeChanged">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnIsSendingForSomeTimeChanged(System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnIsSendingForSomeTimeChanged(MKY.EventArgs{System.Boolean})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugSend(System.String,System.Object[])">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugSend(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugIsSending(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugBreak(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugBreakLead(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugBreakTail(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Terminal.SerialPortHelp">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Terminal.ClearRefreshEmptyTimeout">
            <summary>
            The time-out for clearing/refreshing/emptying, related to <see cref="P:YAT.Domain.Terminal.ClearRefreshEmptySyncObj"/>.
            </summary>
        </member>
        <member name="F:YAT.Domain.Terminal.staticInstanceCounter">
            <remarks>Must be a field for <see cref="M:System.Threading.Interlocked.Increment(System.Int32@)"/>.</remarks>
        </member>
        <member name="P:YAT.Domain.Terminal.StaticRandom">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Terminal.eventHelper">
             <summary>
             A dedicated event helper to allow discarding exceptions when object got disposed.
             </summary>
             <remarks> \remind (2019-08-22 / MKY)
            
             Explicitly setting <see cref="F:MKY.EventHelper.ExceptionHandlingMode.DiscardDisposedTarget"/>
             to handle/workaround the issue described in <see cref="T:YAT.Domain.RawTerminal"/>.
            
             Temporarily disabling this handling/workaround can be useful for debugging, i.e. to
             continue program execution even in case of exceptions and let the debugger handle it.
             </remarks>
        </member>
        <member name="P:YAT.Domain.Terminal.ClearRefreshEmptySyncObj">
            <summary>
            Synchronization object for clearing and refreshing.
            </summary>
        </member>
        <member name="E:YAT.Domain.Terminal.IOChanged">
            <summary></summary>
        </member>
        <member name="E:YAT.Domain.Terminal.IOControlChanged">
            <summary></summary>
        </member>
        <member name="E:YAT.Domain.Terminal.IOError">
            <summary></summary>
        </member>
        <member name="E:YAT.Domain.Terminal.IsSendingChanged">
            <summary></summary>
        </member>
        <member name="E:YAT.Domain.Terminal.IsSendingForSomeTimeChanged">
            <summary></summary>
        </member>
        <member name="E:YAT.Domain.Terminal.RawChunkSent">
            <remarks>Intentionally named "Raw" to emphasize difference to "Display".</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.RawChunkReceived">
            <remarks>Intentionally named "Raw" to emphasize difference to "Display".</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.DisplayElementsTxAdded">
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.DisplayElementsBidirAdded">
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.DisplayElementsRxAdded">
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.CurrentDisplayLineTxReplaced">
             <remarks>
             Using "current line replaced" rather than "element(s) removed" semantic because removing
             elements would likely be more error prone since...
             ...exact sequence of adding and removing elements has to exactly match.
             ...an already added element would likely have to be unfolded to remove parts of it!
            
             Saying hello to StyleCop ;-.
             </remarks>
             <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.CurrentDisplayLineBidirReplaced">
             <remarks>
             Using "current line replaced" rather than "element(s) removed" semantic because removing
             elements would likely be more error prone since...
             ...exact sequence of adding and removing elements has to exactly match.
             ...an already added element would likely have to be unfolded to remove parts of it!
            
             Saying hello to StyleCop ;-.
             </remarks>
             <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.CurrentDisplayLineRxReplaced">
             <remarks>
             Using "current line replaced" rather than "element(s) removed" semantic because removing
             elements would likely be more error prone since...
             ...exact sequence of adding and removing elements has to exactly match.
             ...an already added element would likely have to be unfolded to remove parts of it!
            
             Saying hello to StyleCop ;-.
             </remarks>
             <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.CurrentDisplayLineTxCleared">
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
            <remarks><see cref="E:YAT.Domain.Terminal.CurrentDisplayLineTxReplaced"/> above.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.CurrentDisplayLineBidirCleared">
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
            <remarks><see cref="E:YAT.Domain.Terminal.CurrentDisplayLineBidirReplaced"/> above.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.CurrentDisplayLineRxCleared">
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
            <remarks><see cref="E:YAT.Domain.Terminal.CurrentDisplayLineRxReplaced"/> above.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.DisplayLinesTxAdded">
            <remarks>Intentionally no additional 'Line' event: Covered by 'Lines', ease of use.</remarks>
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.DisplayLinesBidirAdded">
            <remarks>Intentionally no additional 'Line' event: Covered by 'Lines', ease of use.</remarks>
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.DisplayLinesRxAdded">
            <remarks>Intentionally no additional 'Line' event: Covered by 'Lines', ease of use.</remarks>
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.RepositoryTxCleared">
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.RepositoryBidirCleared">
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.RepositoryRxCleared">
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.RepositoryTxReloaded">
            <remarks>Separated from <see cref="E:YAT.Domain.Terminal.DisplayLinesTxAdded"/> for not processing count/rate/log... on reload again.</remarks>
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.RepositoryBidirReloaded">
            <remarks>Separated from <see cref="E:YAT.Domain.Terminal.DisplayLinesBidirAdded"/> for not processing count/rate/log... on reload again.</remarks>
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="E:YAT.Domain.Terminal.RepositoryRxReloaded">
            <remarks>Separated from <see cref="E:YAT.Domain.Terminal.DisplayLinesRxAdded"/> for not processing count/rate/log... on reload again.</remarks>
            <remarks>Intentionally using separate Tx/Bidir/Rx events: More obvious, ease of use.</remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.#ctor(YAT.Domain.Settings.TerminalSettings)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.#ctor(YAT.Domain.Settings.TerminalSettings,YAT.Domain.Terminal)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:YAT.Domain.Terminal.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="P:YAT.Domain.Terminal.TerminalSettings">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.TimeSpanBase">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.IsStopped">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.IsStarted">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.IsConnected">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.IsOpen">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.IsTransmissive">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.LastReceivedChunkTimeStamp">
            <remarks>
            Opposed to <see cref="P:YAT.Domain.Terminal.IsSending"/>, where the amount of data expected for sending is
            known by the caller, there is no information on the availability and amout of data
            for receiving, nor any way to determine whether data may be coming in soon. Thus, an
            "IsReceiving" property makes little sense. Instead, this time stamp may be used to
            determine for how long the I/O instance has not been receiving data anymore, and can
            combine this time stamp with a time-out.
            <para>
            <see cref="F:System.DateTime.MinValue"/> is returned if no <see cref="P:YAT.Domain.Terminal.UnderlyingIOInstance"/>
            is available.
            </para></remarks>
        </member>
        <member name="P:YAT.Domain.Terminal.IsReloading">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.UnderlyingIOProvider">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.UnderlyingIOInstance">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.Start">
            <summary>
            Start the terminal. To stop it again, call <see cref="M:YAT.Domain.Terminal.Stop"/>.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.Stop">
            <summary>
            Stop the terminal. To start it again, call <see cref="M:YAT.Domain.Terminal.Start"/>.
            Or call <see cref="M:YAT.Domain.Terminal.Close"/> to definitely close the terminal.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.Close">
            <summary>
            Definitely close the terminal. After closing, the terminal cannot be started anymore
            and must be terminated.
            </summary>
            <remarks>
            This method is required to stop the send thread prior to calling <see cref="M:YAT.Domain.Terminal.Dispose(System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.TryParse(System.String,YAT.Domain.Radix,YAT.Domain.Parser.Mode,YAT.Domain.Parser.Result[]@,System.String@)">
            <summary>
            Tries to parse <paramref name="s"/>, taking the current settings into account.
            </summary>
            <remarks>
            <c>abstract</c> because of encoding setting.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.TryParse(System.String,YAT.Domain.Radix,System.Byte[]@)">
            <summary>
            Tries to parse <paramref name="s"/>, taking the current settings into account.
            </summary>
            <remarks>
            <c>abstract</c> because of encoding setting.
            </remarks>
        </member>
        <member name="P:YAT.Domain.Terminal.SerialPortControlPins">
            <summary>
            Serial port control pins.
            </summary>
        </member>
        <member name="P:YAT.Domain.Terminal.SerialPortControlPinCount">
            <summary>
            Serial port control pin counts.
            </summary>
        </member>
        <member name="P:YAT.Domain.Terminal.SentXOnCount">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.SentXOffCount">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.ReceivedXOnCount">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.ReceivedXOffCount">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ResetFlowControlCount">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.InputBreakCount">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Terminal.OutputBreakCount">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ResetBreakCount">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.RequestToggleRts(MKY.IO.Serial.SerialPort.SerialControlPinState@)">
            <summary>
            Toggles RTS control pin if current flow control settings allow this.
            </summary>
            <param name="pinState">
            <c>true</c> if the control pin has become enabled.; otherwise, <c>false</c>
            </param>
            <returns>
            <c>true</c> if the request has been executed; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:YAT.Domain.Terminal.RequestToggleDtr(MKY.IO.Serial.SerialPort.SerialControlPinState@)">
            <summary>
            Toggles DTR control pin if current flow control settings allow this.
            </summary>
            <param name="pinState">
            <c>true</c> if the control pin has become enabled.; otherwise, <c>false</c>
            </param>
            <returns>
            <c>true</c> if the request has been executed; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:YAT.Domain.Terminal.RequestToggleInputXOnXOff">
            <summary>
            Toggles the input XOn/XOff state if current flow control settings allow this.
            </summary>
            <returns>
            <c>true</c> if the request has been executed; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:YAT.Domain.Terminal.RequestSignalInputXOn">
            <summary>
            Signals XOn if current flow control settings allow this.
            </summary>
            <returns>
            <c>true</c> if the request has been executed; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:YAT.Domain.Terminal.RequestToggleOutputBreak">
            <summary>
            Toggles the output break state if current port settings allow this.
            </summary>
            <returns>
            <c>true</c> if the request has been executed; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:YAT.Domain.Terminal.IOControlChangeTexts">
            <summary>
            Returns a collection of <see cref="T:YAT.Domain.DisplayElement"/> objects reflecting the changed I/O control status.
            </summary>
            <remarks>
            Private to ensure proper update of <see cref="F:YAT.Domain.Terminal.ioControlStateCache"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.InlineWarningMessage(System.DateTime,YAT.Domain.Direction,System.String)">
            <summary>
            Inlines an warning message.
            </summary>
            <remarks>
            Intended to be used from "outside" of this <see cref="T:YAT.Domain.Terminal"/>.
            Otherwise, InlineDisplayElement*() shall be used.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.InlineErrorMessage(System.DateTime,YAT.Domain.Direction,System.String)">
            <summary>
            Inlines an error message.
            </summary>
            <remarks>
            Intended to be used from "outside" of this <see cref="T:YAT.Domain.Terminal"/>.
            Otherwise, InlineDisplayElement*() shall be used.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.EnqueueEasterEggMessage">
            <summary>
            Enqueues the easter egg message.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.Format(System.DateTime)">
            <summary>
            Formats the specified time stamp.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.Format(System.Byte[])">
            <summary>
            Formats the specified data sequence.
            </summary>
            <remarks>
            \remind (2017-12-11 / MKY)
            Currently limited to data of a single line. Refactoring would be required to format multiple lines
            (<see cref="M:YAT.Domain.Terminal.ProcessChunk(YAT.Domain.RawChunk)"/> instead of <see cref="M:YAT.Domain.Terminal.ByteToElement(System.Byte,System.DateTime,YAT.Domain.IODirection,YAT.Domain.Radix,System.Collections.Generic.List{System.Byte})"/>).
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            <see cref="P:YAT.Domain.Settings.DisplaySettings.TxRadix"/> and
            <see cref="P:YAT.Domain.Settings.DisplaySettings.RxRadix"/> have different values.
            </exception>
        </member>
        <member name="M:YAT.Domain.Terminal.Format(System.Byte[],YAT.Domain.IODirection)">
            <summary>
            Formats the specified data sequence.
            </summary>
            <remarks>
            \remind (2017-12-11 / MKY)
            Currently limited to data of a single line. Refactoring would be required to format multiple lines
            (<see cref="M:YAT.Domain.Terminal.ProcessChunk(YAT.Domain.RawChunk)"/> instead of <see cref="M:YAT.Domain.Terminal.ByteToElement(System.Byte,System.DateTime,YAT.Domain.IODirection,YAT.Domain.Radix,System.Collections.Generic.List{System.Byte})"/>).
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.Format(System.Byte[],YAT.Domain.Radix)">
            <summary>
            Formats the specified data sequence.
            </summary>
            <remarks>
            \remind (2017-12-11 / MKY)
            Currently limited to data of a single line. Refactoring would be required to format multiple lines
            (<see cref="M:YAT.Domain.Terminal.ProcessChunk(YAT.Domain.RawChunk)"/> instead of <see cref="M:YAT.Domain.Terminal.ByteToElement(System.Byte,System.DateTime,YAT.Domain.IODirection,YAT.Domain.Radix,System.Collections.Generic.List{System.Byte})"/>).
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.Format(System.Byte[],YAT.Domain.IODirection,YAT.Domain.Radix)">
            <summary>
            Formats the specified data sequence.
            </summary>
            <remarks>
            \remind (2017-12-11 / MKY)
            Currently limited to data of a single line. Refactoring would be required to format multiple lines
            (<see cref="M:YAT.Domain.Terminal.ProcessChunk(YAT.Domain.RawChunk)"/> instead of <see cref="M:YAT.Domain.Terminal.ByteToElement(System.Byte,System.DateTime,YAT.Domain.IODirection,YAT.Domain.Radix,System.Collections.Generic.List{System.Byte})"/>).
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.RemoveFraming(System.Byte[])">
            <summary>
            Removes the framing from the given data.
            </summary>
            <remarks>
            For text terminals, framing is typically defined by EOL.
            For binary terminals, framing is optionally defined by sequence before/after.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The Tx and Rx sequence(s) have different values.
            </exception>
        </member>
        <member name="M:YAT.Domain.Terminal.RemoveFraming(System.Byte[],YAT.Domain.IODirection)">
            <summary>
            Removes the framing from the given data.
            </summary>
            <remarks>
            For text terminals, framing is typically defined by EOL.
            For binary terminals, framing is optionally defined by sequence before/after.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ConvertToSendableText(System.Char)">
            <summary>
            Converts the given value to a sendable text.
            </summary>
            <remarks>
            If the value is a printable character, the string contains that character.
            If the value is a control character, the ASCII mnemonic or Unicode representation is returned.
            </remarks>
            <remarks>
            This method is a copy of the code in MKY.CharEx.ConvertToPrintableString().
            Intentionally copied since the angle bracket and Unicode representations
            are explicitly required by YAT.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ConvertToSendableText(System.String)">
            <summary>
            Converts the given value to a sendable text.
            </summary>
            <remarks>
            Printable characters are kept, control characters are converted into the ASCII mnemonic
            or Unicode representation as required.
            </remarks>
            <remarks>
            This method is a copy of the code in MKY.CharEx.ConvertToPrintableString().
            Intentionally copied since the angle bracket and Unicode representations
            are explicitly required by YAT.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.rawTerminal_ChunkSent(System.Object,MKY.EventArgs{YAT.Domain.RawChunk})">
            <remarks>
            This event is raised when a chunk is sent by the <see cref="P:YAT.Domain.Terminal.UnderlyingIOProvider"/>.
            The event is not raised on reloading, reloading is done by the 'Refresh...()' methods.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.rawTerminal_ChunkReceived(System.Object,MKY.EventArgs{YAT.Domain.RawChunk})">
            <remarks>
            This event is raised when a chunk is received by the <see cref="P:YAT.Domain.Terminal.UnderlyingIOProvider"/>.
            The event is not raised on reloading, reloading is done by the 'Refresh...()' methods.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.OnIOChanged(MKY.EventArgs{System.DateTime})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnIOControlChanged(YAT.Domain.IOControlEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnIOError(YAT.Domain.IOErrorEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnRawChunkSent(MKY.EventArgs{YAT.Domain.RawChunk})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnRawChunkReceived(MKY.EventArgs{YAT.Domain.RawChunk})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnDisplayElementsAdded(YAT.Domain.RepositoryType,YAT.Domain.DisplayElementsEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnDisplayElementsTxAdded(YAT.Domain.DisplayElementsEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnDisplayElementsBidirAdded(YAT.Domain.DisplayElementsEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnDisplayElementsRxAdded(YAT.Domain.DisplayElementsEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnCurrentDisplayLineReplaced(YAT.Domain.RepositoryType,YAT.Domain.DisplayElementsEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnCurrentDisplayLineTxReplaced(YAT.Domain.DisplayElementsEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnCurrentDisplayLineBidirReplaced(YAT.Domain.DisplayElementsEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnCurrentDisplayLineRxReplaced(YAT.Domain.DisplayElementsEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnCurrentDisplayLineCleared(YAT.Domain.RepositoryType,System.EventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnCurrentDisplayLineTxCleared(System.EventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnCurrentDisplayLineBidirCleared(System.EventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnCurrentDisplayLineRxCleared(System.EventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnDisplayLinesAdded(YAT.Domain.RepositoryType,YAT.Domain.DisplayLinesEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnDisplayLinesTxAdded(YAT.Domain.DisplayLinesEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnDisplayLinesBidirAdded(YAT.Domain.DisplayLinesEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnDisplayLinesRxAdded(YAT.Domain.DisplayLinesEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnRepositoryCleared(YAT.Domain.RepositoryType,System.EventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnRepositoryTxCleared(System.EventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnRepositoryBidirCleared(System.EventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnRepositoryRxCleared(System.EventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnRepositoryReloaded(YAT.Domain.RepositoryType,YAT.Domain.DisplayLinesEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnRepositoryTxReloaded(YAT.Domain.DisplayLinesEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnRepositoryBidirReloaded(YAT.Domain.DisplayLinesEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.OnRepositoryRxReloaded(YAT.Domain.DisplayLinesEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.Terminal.ToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.Terminal.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.ToShortIOString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.Terminal.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugMessage(System.String,System.Object[])">
            <remarks>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with the formatted message, and rather than e.g. "Common" for comprehensibility.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugMessage(System.String)">
            <remarks>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with <paramref name="message"/>, and rather than e.g. "Common" for comprehensibility.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugMessageLead(System.String)">
            <remarks>
            Name "DebugWrite" would show relation to <see cref="M:System.Diagnostics.Debug.Write(System.String)"/>.
            However, named "Message" for orthogonality with <see cref="M:YAT.Domain.Terminal.DebugMessage(System.String)"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Terminal.DebugContentEvents(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="T:YAT.Domain.TimeDeltaFormatPreset">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.TimeDeltaFormatPresetEx">
            <summary>
            Extended enum TimeDeltaFormatPresetEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.TimeDeltaFormatPresetEx.Standard_format">
            <remarks>
            Output milliseconds for readability, even though last digit only provides limited accuracy.
            </remarks>
        </member>
        <member name="F:YAT.Domain.TimeDeltaFormatPresetEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.TimeDeltaFormatPreset.Standard"/>.</summary>
        </member>
        <member name="F:YAT.Domain.TimeDeltaFormatPresetEx.DefaultFormat">
            <summary>Default is <see cref="F:YAT.Domain.TimeDeltaFormatPreset.Standard"/>.</summary>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.TimeDeltaFormatPresetEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.#ctor(YAT.Domain.TimeDeltaFormatPreset)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.ToFormat">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.ToDescription">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.TryParse(System.String,YAT.Domain.TimeDeltaFormatPresetEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.TryParse(System.String,YAT.Domain.TimeDeltaFormatPreset@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.op_Implicit(YAT.Domain.TimeDeltaFormatPresetEx)~YAT.Domain.TimeDeltaFormatPreset">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.op_Implicit(YAT.Domain.TimeDeltaFormatPreset)~YAT.Domain.TimeDeltaFormatPresetEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeDeltaFormatPresetEx.op_Implicit(YAT.Domain.TimeDeltaFormatPresetEx)~System.String">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.TimeSpanFormatPreset">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.TimeSpanFormatPresetEx">
            <summary>
            Extended enum TimeSpanFormatPresetEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.TimeSpanFormatPresetEx.Standard_format">
            <remarks>
            Output milliseconds for readability, even though last digit only provides limited accuracy.
            </remarks>
        </member>
        <member name="F:YAT.Domain.TimeSpanFormatPresetEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.TimeSpanFormatPreset.Standard"/>.</summary>
        </member>
        <member name="F:YAT.Domain.TimeSpanFormatPresetEx.DefaultFormat">
            <summary>Default is <see cref="F:YAT.Domain.TimeSpanFormatPreset.Standard"/>.</summary>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.TimeSpanFormatPresetEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.#ctor(YAT.Domain.TimeSpanFormatPreset)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.ToFormat">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.ToDescription">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.TryParse(System.String,YAT.Domain.TimeSpanFormatPresetEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.TryParse(System.String,YAT.Domain.TimeSpanFormatPreset@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.op_Implicit(YAT.Domain.TimeSpanFormatPresetEx)~YAT.Domain.TimeSpanFormatPreset">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.op_Implicit(YAT.Domain.TimeSpanFormatPreset)~YAT.Domain.TimeSpanFormatPresetEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeSpanFormatPresetEx.op_Implicit(YAT.Domain.TimeSpanFormatPresetEx)~System.String">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.TimeStampFormatPreset">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.TimeStampFormatPresetEx">
            <summary>
            Extended enum TimeStampFormatPresetEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.TimeStampFormatPresetEx.Time_format">
            <remarks>
            Output milliseconds for readability, even though last digit only provides limited accuracy.
            </remarks>
        </member>
        <member name="F:YAT.Domain.TimeStampFormatPresetEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.TimeStampFormatPreset.Time"/>.</summary>
        </member>
        <member name="F:YAT.Domain.TimeStampFormatPresetEx.DefaultFormat">
            <summary>Default is <see cref="F:YAT.Domain.TimeStampFormatPreset.Time"/>.</summary>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.TimeStampFormatPresetEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.#ctor(YAT.Domain.TimeStampFormatPreset)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.ToFormat">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.ToDescription">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.TryParse(System.String,YAT.Domain.TimeStampFormatPresetEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.TryParse(System.String,YAT.Domain.TimeStampFormatPreset@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.op_Implicit(YAT.Domain.TimeStampFormatPresetEx)~YAT.Domain.TimeStampFormatPreset">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.op_Implicit(YAT.Domain.TimeStampFormatPreset)~YAT.Domain.TimeStampFormatPresetEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TimeStampFormatPresetEx.op_Implicit(YAT.Domain.TimeStampFormatPresetEx)~System.String">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Separator">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.SeparatorEx">
            <summary>
            Extended enum InfoSeparatorEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.SeparatorEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.Separator.None"/>.</summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.SeparatorEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.#ctor(YAT.Domain.Separator)">
            <remarks>
            Do not use with <see cref="F:YAT.Domain.Separator.Explicit"/> because that selection requires
            a separator string. Use <see cref="M:YAT.Domain.SeparatorEx.#ctor(System.String)"/> instead.
            </remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="separator"/> is <see cref="F:YAT.Domain.Separator.Explicit"/>. Use <see cref="M:YAT.Domain.SeparatorEx.#ctor(System.String)"/> instead.
            </exception>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.SeparatorEx.IsExplicit">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.ToSeparator">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.ToDescription">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.Equals(System.Object)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.Equals(YAT.Domain.SeparatorEx)">
            <summary>
            Determines whether this instance and the specified object have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.op_Equality(YAT.Domain.SeparatorEx,YAT.Domain.SeparatorEx)">
            <summary>
            Determines whether the two specified objects have reference or value equality.
            </summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.op_Inequality(YAT.Domain.SeparatorEx,YAT.Domain.SeparatorEx)">
            <summary>
            Determines whether the two specified objects have reference and value inequality.
            </summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.Parse(System.String)">
            <remarks>
            Opposed to the convention of the .NET framework, whitespace is NOT
            trimmed from <paramref name="s"/> as certain separators contain spaces.
            </remarks>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.TryParse(System.String,YAT.Domain.SeparatorEx@)">
            <remarks>
            Opposed to the convention of the .NET framework, whitespace is NOT
            trimmed from <paramref name="s"/> as certain separators contain spaces.
            </remarks>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.TryParse(System.String,YAT.Domain.Separator@)">
            <remarks>
            Opposed to the convention of the .NET framework, whitespace is NOT
            trimmed from <paramref name="s"/> as certain separators contain spaces.
            </remarks>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.op_Implicit(YAT.Domain.SeparatorEx)~YAT.Domain.Separator">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.op_Explicit(YAT.Domain.Separator)~YAT.Domain.SeparatorEx">
            <remarks>
            Explicit because cast doesn't work for <see cref="F:YAT.Domain.Separator.Explicit"/>.
            </remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="separator"/> is <see cref="F:YAT.Domain.Separator.Explicit"/>.
            </exception>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.op_Implicit(YAT.Domain.SeparatorEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SeparatorEx.op_Implicit(System.String)~YAT.Domain.SeparatorEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.TextSendItem">
            <summary>
            Defines a text data item that shall be sent by the terminal.
            </summary>
        </member>
        <member name="P:YAT.Domain.TextSendItem.Text">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TextSendItem.DefaultRadix">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TextSendItem.ParseMode">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TextSendItem.SendMode">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TextSendItem.IsLine">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextSendItem.#ctor(System.String,YAT.Domain.Radix,YAT.Domain.Parser.Mode,YAT.Domain.SendMode,System.Boolean)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TextSendItem.DataAsPrintableString">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextSendItem.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextSendItem.ToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.TextSendItem.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="T:YAT.Domain.FileSendItem">
            <summary>
            Defines a file item that shall be sent by the terminal.
            </summary>
        </member>
        <member name="P:YAT.Domain.FileSendItem.FilePath">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.FileSendItem.DefaultRadix">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.FileSendItem.#ctor(System.String,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.FileSendItem.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.FileSendItem.ToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.FileSendItem.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="T:YAT.Domain.Radix">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.RadixEx">
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.RadixEx.TextDefault">
            <summary>Default for text terminals is <see cref="F:YAT.Domain.Radix.String"/>.</summary>
        </member>
        <member name="F:YAT.Domain.RadixEx.BinaryDefault">
            <summary>Default for binary terminals is <see cref="F:YAT.Domain.Radix.Hex"/>.</summary>
        </member>
        <member name="F:YAT.Domain.RadixEx.Default">
            <summary>
            Default is <see cref="F:YAT.Domain.RadixEx.TextDefault"/> as its value of
            <see cref="F:YAT.Domain.Radix.String"/> is more general.</summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.#ctor">
            <summary>
            Default is <see cref="F:YAT.Domain.RadixEx.Default"/>.
            </summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.#ctor(YAT.Domain.TerminalType)">
            <summary>
            Default is <see cref="F:YAT.Domain.RadixEx.TextDefault"/> for text
            and <see cref="F:YAT.Domain.RadixEx.BinaryDefault"/> for binary terminals.
            </summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.#ctor(YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.ToShortString">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.ToValueString">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RadixEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RadixEx.TryParse(System.String,YAT.Domain.RadixEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RadixEx.TryParse(System.String,YAT.Domain.Radix@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RadixEx.op_Implicit(YAT.Domain.RadixEx)~YAT.Domain.Radix">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.op_Implicit(YAT.Domain.Radix)~YAT.Domain.RadixEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.op_Implicit(YAT.Domain.RadixEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.op_Implicit(System.Int32)~YAT.Domain.RadixEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.op_Implicit(YAT.Domain.RadixEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RadixEx.op_Implicit(System.String)~YAT.Domain.RadixEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement">
            <remarks>
            This class cannot be implemented immutable [ImmutableObject(true)] because of the
            performance improving /// <see cref="M:YAT.Domain.DisplayElement.Append(YAT.Domain.DisplayElement)"/> method.
            </remarks>
        </member>
        <member name="T:YAT.Domain.DisplayElement.ElementAttributes">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.Nonentity">
            <remarks>Using 'nonentitiy' instead of 'nothing' as that is a keyword in other .NET languages.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.Nonentity.#ctor">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.TxData">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TxData.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TxData.#ctor(System.DateTime,System.Byte,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TxData.#ctor(System.DateTime,System.Byte[],System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TxData.#ctor(System.Byte[],System.String)">
            <remarks>This reduced signature is required for potential unfolding in <see cref="M:YAT.Domain.DisplayElement.RemoveLastContentChar"/>.</remarks>
        </member>
        <member name="T:YAT.Domain.DisplayElement.TxControl">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TxControl.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TxControl.#ctor(System.DateTime,System.Byte,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TxControl.#ctor(System.DateTime,System.Byte[],System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TxControl.#ctor(System.Byte[],System.String)">
            <remarks>This reduced signature is required for potential unfolding in <see cref="M:YAT.Domain.DisplayElement.RemoveLastContentChar"/>.</remarks>
        </member>
        <member name="T:YAT.Domain.DisplayElement.RxData">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.RxData.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.RxData.#ctor(System.DateTime,System.Byte,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.RxData.#ctor(System.DateTime,System.Byte[],System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.RxData.#ctor(System.Byte[],System.String)">
            <remarks>This reduced signature is required for potential unfolding in <see cref="M:YAT.Domain.DisplayElement.RemoveLastContentChar"/>.</remarks>
        </member>
        <member name="T:YAT.Domain.DisplayElement.RxControl">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.RxControl.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.RxControl.#ctor(System.DateTime,System.Byte,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.RxControl.#ctor(System.DateTime,System.Byte[],System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.RxControl.#ctor(System.Byte[],System.String)">
            <remarks>This reduced signature is required for potential unfolding in <see cref="M:YAT.Domain.DisplayElement.RemoveLastContentChar"/>.</remarks>
        </member>
        <member name="T:YAT.Domain.DisplayElement.InfoElement">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InfoElement.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InfoElement.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InfoElement.#ctor(YAT.Domain.Direction,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InfoElement.#ctor(System.DateTime,YAT.Domain.Direction,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InfoElement.#ctor(YAT.Domain.DisplayElement.InfoElement)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.TimeStampInfo">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeStampInfo.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeStampInfo.#ctor(System.DateTime,System.String,System.Boolean,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeStampInfo.ToText(System.DateTime,System.String,System.Boolean,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeStampInfo.Change(System.DateTime,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Replaces <see cref="P:YAT.Domain.DisplayElement.TimeStamp"/> and <see cref="P:YAT.Domain.DisplayElement.Text"/> according to given arguments.
            </summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.TimeSpanInfo">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.TimeSpanInfo.TimeSpan">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeSpanInfo.#ctor(YAT.Domain.DisplayElement.TimeSpanInfo)">
            <remarks>This copy-constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeSpanInfo.#ctor(System.TimeSpan,System.String,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeSpanInfo.ToText(System.TimeSpan,System.String,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeSpanInfo.Change(System.TimeSpan,System.String,System.String,System.String)">
            <summary>
            Replaces <see cref="P:YAT.Domain.DisplayElement.Text"/> according to given arguments.
            </summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.TimeDeltaInfo">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.TimeDeltaInfo.TimeDelta">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeDeltaInfo.#ctor(YAT.Domain.DisplayElement.TimeDeltaInfo)">
            <remarks>This copy-constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeDeltaInfo.#ctor(System.TimeSpan,System.String,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeDeltaInfo.ToText(System.TimeSpan,System.String,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeDeltaInfo.Change(System.TimeSpan,System.String,System.String,System.String)">
            <summary>
            Replaces <see cref="P:YAT.Domain.DisplayElement.Text"/> according to given arguments.
            </summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.TimeDurationInfo">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.TimeDurationInfo.TimeDuration">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeDurationInfo.#ctor(YAT.Domain.DisplayElement.TimeDurationInfo)">
            <remarks>This copy-constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeDurationInfo.#ctor(System.TimeSpan,System.String,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.TimeDurationInfo.ToText(System.TimeSpan,System.String,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.DeviceInfo">
            <remarks>Named "Device" for simplicity even though using "I/O Device" for view.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.DeviceInfo.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.DeviceInfo.#ctor(System.String,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.DeviceInfo.ToText(System.String,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.DirectionInfo">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.DirectionInfo.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.DirectionInfo.#ctor(YAT.Domain.Direction,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.DirectionInfo.ToText(YAT.Domain.Direction,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.DirectionInfo.Change(YAT.Domain.Direction,System.String,System.String)">
            <summary>
            Replaces <see cref="P:YAT.Domain.DisplayElement.Direction"/> and <see cref="P:YAT.Domain.DisplayElement.Text"/> according to given arguments.
            </summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.ContentLength">
            <summary>The length of the data/control content.</summary>
            <remarks>Prefixed "Content" for a) preventing naming conflict and b) orthogonality with <see cref="T:YAT.Domain.DisplayElement.ContentSeparator"/> .</remarks>
        </member>
        <member name="P:YAT.Domain.DisplayElement.ContentLength.Length">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ContentLength.#ctor(YAT.Domain.DisplayElement.ContentLength)">
            <remarks>This copy-constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ContentLength.#ctor(System.Int32,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ContentLength.ToText(System.Int32,System.String,System.String)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.FormatElement">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.FormatElement.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.FormatElement.#ctor(YAT.Domain.Direction)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.FormatElement.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.FormatElement.#ctor(YAT.Domain.Direction,System.String)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.ContentSeparator">
            <summary>The separator that is added inbetween characters of the data/control content (e.g. radix = char).</summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ContentSeparator.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ContentSeparator.#ctor(YAT.Domain.Direction,System.String)">
            <remarks>Using direction since adjacent content is also directed.</remarks>
        </member>
        <member name="T:YAT.Domain.DisplayElement.InfoSeparator">
            <summary>The separator that is added inbetween info elements as well as to the left/right of the data/control content.</summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InfoSeparator.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InfoSeparator.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.LineStart">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.LineStart.#ctor">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.LineBreak">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.LineBreak.#ctor">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.InlineElement">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InlineElement.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InlineElement.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InlineElement.#ctor(YAT.Domain.Direction,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InlineElement.#ctor(System.DateTime,YAT.Domain.Direction,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InlineElement.#ctor(System.DateTime,YAT.Domain.Direction,System.Byte,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InlineElement.#ctor(System.DateTime,YAT.Domain.Direction,System.Byte[],System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.InlineElement.Clone">
            <summary>
            Creates and returns a new object that is a deep-copy of this instance.
            </summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.IOControlInfo">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.IOControlInfo.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.IOControlInfo.#ctor(System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.IOControlInfo.#ctor(System.DateTime,YAT.Domain.Direction,System.String)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.WarningInfo">
            <remarks>
            Named "WarningInfo" rather than just "Warning" for orthogonality with <see cref="T:YAT.Domain.DisplayElement.ErrorInfo"/>.
            <para>
            Note that related format setting is called "WarningFormat", i.e. without "Info".
            </para></remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.WarningInfo.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.WarningInfo.#ctor(System.String,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.WarningInfo.#ctor(YAT.Domain.Direction,System.String,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.WarningInfo.#ctor(System.DateTime,YAT.Domain.Direction,System.String,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.WarningInfo.#ctor(System.DateTime,YAT.Domain.Direction,System.Byte,System.String,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.WarningInfo.#ctor(System.DateTime,YAT.Domain.Direction,System.Byte[],System.String,System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElement.ErrorInfo">
            <remarks>
            This element type should rather be called "Error" because it applies to any error
            that shall be displayed in the terminal. However, "Error" is a keyword in certain
            .NET languages such as VB.NET. As a result, any identifier called "Error" or "error"
            will cause StyleCop/FxCop to issue a severe warning. So "ErrorInfo" is used instead.
            <para>
            Note that related format setting is called "ErrorFormat", i.e. without "Info".
            </para></remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ErrorInfo.#ctor">
            <remarks>This parameterless constructor is required for <see cref="M:YAT.Domain.DisplayElement.Clone"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ErrorInfo.#ctor(System.String,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ErrorInfo.#ctor(YAT.Domain.Direction,System.String,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ErrorInfo.#ctor(System.DateTime,YAT.Domain.Direction,System.String,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ErrorInfo.#ctor(System.DateTime,YAT.Domain.Direction,System.Byte,System.String,System.Boolean)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ErrorInfo.#ctor(System.DateTime,YAT.Domain.Direction,System.Byte[],System.String,System.Boolean)">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.DisplayElement.TimeStampDefault">
            <summary>
            The <see cref="T:System.DateTime"/> used if no dedicated time stamp information is available.
            </summary>
            <remarks>
            Corresponds to <see cref="F:System.DateTime.MinValue"/>.
            </remarks>
        </member>
        <member name="F:YAT.Domain.DisplayElement.DirectionDefault">
            <summary>
            The <see cref="P:YAT.Domain.DisplayElement.Direction"/> used if no dedicated direction information is available.
            </summary>
            <remarks>
            Corresponds to <see cref="F:YAT.Domain.Direction.None"/>.
            </remarks>
        </member>
        <member name="P:YAT.Domain.DisplayElement.Highlight">
            <summary>
            Indicates whether this <see cref="T:YAT.Domain.DisplayElement"/> is highlighted.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.#ctor(YAT.Domain.DisplayElement.ElementAttributes)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.#ctor(YAT.Domain.Direction,YAT.Domain.DisplayElement.ElementAttributes)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.#ctor(System.DateTime,YAT.Domain.Direction,YAT.Domain.DisplayElement.ElementAttributes)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.#ctor(System.DateTime,YAT.Domain.Direction,System.String,YAT.Domain.DisplayElement.ElementAttributes)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.#ctor(System.DateTime,YAT.Domain.Direction,System.Byte,System.String,YAT.Domain.DisplayElement.ElementAttributes)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.#ctor(System.DateTime,YAT.Domain.Direction,System.Byte,System.String,System.Int32,YAT.Domain.DisplayElement.ElementAttributes)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.#ctor(System.DateTime,YAT.Domain.Direction,System.Byte[],System.String,YAT.Domain.DisplayElement.ElementAttributes)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.#ctor(System.DateTime,YAT.Domain.Direction,System.Byte[],System.String,System.Int32,YAT.Domain.DisplayElement.ElementAttributes)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.#ctor(YAT.Domain.DisplayElement)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.TimeStamp">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.Direction">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.Origin">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.Text">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.CharCount">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.ByteCount">
            <remarks>
            Positioned after <see cref="P:YAT.Domain.DisplayElement.CharCount"/> as counts are displayed at the end of a line.
            </remarks>
        </member>
        <member name="P:YAT.Domain.DisplayElement.Attributes">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.IsContent">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.IsDataContent">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.IsControlContent">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.IsInline">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.IsInfo">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElement.IsAuxiliary">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.Clone">
            <summary>
            Creates and returns a new object that is a deep-copy of this instance.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.AcceptsAppendOf(YAT.Domain.DisplayElement)">
            <summary>
            Returns <c>true</c> if <paramref name="other"/> can be appended to this element.
            </summary>
            <remarks>
            Note that the type of the element also has to be checked. This ensures that control
            elements are not appended to 'normal' data elements.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.Append(YAT.Domain.DisplayElement)">
            <summary>
            Appends contents to this element.
            </summary>
            <remarks>
            Useful to improve performance. Appending keeps number of display elements as low as
            possible, thus iteration through display elements gets faster.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayElement.RemoveLastContentChar">
            <summary>
            Removes the last character from the element.
            </summary>
            <remarks>
            Needed to handle backspace; consequence of <see cref="M:YAT.Domain.DisplayElement.Append(YAT.Domain.DisplayElement)"/> above.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The element is no <see cref="F:YAT.Domain.DisplayElement.ElementAttributes.Content"/>.
            -or-
            The element contains text but the origin is empty.
            </exception>
        </member>
        <member name="M:YAT.Domain.DisplayElement.RemoveTrailingContentSeparator(System.String)">
            <summary>
            Remove a potential trailing content separator from the <see cref="T:YAT.Domain.DisplayElementCollection"/>.
            </summary>
            <remarks>
            Needed to handle backspace, thus applies to content only.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The element is not content.
            </exception>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ToOrigin">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayElement.ToDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.DisplayElement.ToString"/> method which can be used for trace/debug.
            </remarks>
            <remarks>
            Limited to a single line to keep debug output compact, same as <see cref="M:YAT.Domain.DisplayElement.ToString"/>.
            </remarks>
        </member>
        <member name="T:YAT.Domain.DisplayRepository">
            <summary>
            This class wraps a size limited <see cref="T:System.Collections.Generic.Queue`1"/> holding <see cref="T:YAT.Domain.DisplayLine"/> items.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.#ctor(YAT.Domain.DisplayRepository)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayRepository.Capacity">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayRepository.Count">
            <summary>
            Returns number of lines within repository.
            </summary>
        </member>
        <member name="P:YAT.Domain.DisplayRepository.ByteCount">
            <summary>
            Returns number of raw byte content within repository.
            </summary>
            <remarks>
            Note that value reflects the byte count of the elements contained in the repository,
            i.e. the byte count of the elements shown. The value thus not necessarily reflects the
            total byte count of a sent or received sequence, a hidden EOL is e.g. not reflected.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.Enqueue(YAT.Domain.DisplayElement)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.Enqueue(System.Collections.Generic.IEnumerable{YAT.Domain.DisplayElement})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.Enqueue(YAT.Domain.DisplayLine)">
            <remarks>
            Ensure that <see cref="M:YAT.Domain.DisplayRepository.Enqueue(YAT.Domain.DisplayElement)"/> is called, which keeps track of the counts.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.Dequeue">
            <remarks>
            Ensure that track of the counts is kept.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.ReplaceCurrentLine(YAT.Domain.DisplayElementCollection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.ClearCurrentLine">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.Clear">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.ToArray">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.ToLines">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.ToElements">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.LastLineAuxiliary">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.ClearLastLineAuxiliary">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.ToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.DisplayRepository.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.LinesToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.DisplayRepository.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.DebugMessage(System.String,System.Object[])">
            <remarks>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with the formatted message, and rather than e.g. "Common" for comprehensibility.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.DebugMessage(System.String)">
            <remarks>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with <paramref name="message"/>, and rather than e.g. "Common" for comprehensibility.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DisplayRepository.DebugByteCount(System.String,System.Object[])">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="T:YAT.Domain.TerminalType">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.TerminalType.Text">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.TerminalType.Binary">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.TerminalTypeEx">
            <summary>
            Extended enum TerminalTypeEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.TerminalTypeEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.TerminalType.Text"/>.</summary>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.TerminalTypeEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.#ctor(YAT.Domain.TerminalType)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TerminalTypeEx.IsText">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TerminalTypeEx.IsBinary">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.TryParse(System.String,YAT.Domain.TerminalTypeEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.TryParse(System.String,YAT.Domain.TerminalType@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.op_Implicit(YAT.Domain.TerminalTypeEx)~YAT.Domain.TerminalType">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.op_Implicit(YAT.Domain.TerminalType)~YAT.Domain.TerminalTypeEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.op_Implicit(YAT.Domain.TerminalTypeEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.op_Implicit(System.Int32)~YAT.Domain.TerminalTypeEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.op_Implicit(YAT.Domain.TerminalTypeEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TerminalTypeEx.op_Implicit(System.String)~YAT.Domain.TerminalTypeEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.RawTerminal">
            <summary>
            Defines a buffered serial interface. The buffers contain raw byte content,
            no formatting is done.
            </summary>
        </member>
        <member name="F:YAT.Domain.RawTerminal.eventHelper">
             <summary>
             A dedicated event helper to allow discarding exceptions when object got disposed.
             </summary>
             <remarks> \remind (2019-08-22 / MKY)
            
             Explicitly setting <see cref="F:MKY.EventHelper.ExceptionHandlingMode.DiscardDisposedTarget"/>
             to handle/workaround the following issue:
            
             <![CDATA[
             System.Reflection.TargetInvocationException was unhandled by user code
               Message=Ein Aufrufziel hat einen Ausnahmefehler verursacht.
               Source=mscorlib
               StackTrace:
                    bei System.RuntimeMethodHandle._InvokeMethodFast(Object target, Object[] arguments, SignatureStruct& sig, MethodAttributes methodAttributes, RuntimeTypeHandle typeOwner)
                    bei System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture, Boolean skipVisibilityChecks)
                    bei System.Delegate.DynamicInvokeImpl(Object[] args)
                    bei MKY.EventHelper.Item.InvokeOnCurrentThread(Delegate sink, Object[] args) in D:\Workspace\YAT\Trunk\MKY\MKY\EventHelper.cs:Zeile 595.
                    bei System.Runtime.Remoting.Messaging.StackBuilderSink._PrivateProcessMessage(IntPtr md, Object[] args, Object server, Int32 methodPtr, Boolean fExecuteInContext, Object[]& outArgs)
                    bei System.Runtime.Remoting.Messaging.StackBuilderSink.AsyncProcessMessage(IMessage msg, IMessageSink replySink)
               InnerException 1:
                    Message=Ein Aufrufziel hat einen Ausnahmefehler verursacht.
                    Source=mscorlib
                    StackTrace:
                         bei System.RuntimeMethodHandle._InvokeMethodFast(Object target, Object[] arguments, SignatureStruct& sig, MethodAttributes methodAttributes, RuntimeTypeHandle typeOwner)
                         bei System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture, Boolean skipVisibilityChecks)
                         bei System.Delegate.DynamicInvokeImpl(Object[] args)
                         bei MKY.EventHelper.Item.InvokeOnCurrentThread(Delegate sink, Object[] args) in D:\Workspace\YAT\Trunk\MKY\MKY\EventHelper.cs:Zeile 595.
                         bei MKY.EventHelper.Item.RaiseSync(Delegate eventDelegate, Object[] args) in D:\Workspace\YAT\Trunk\MKY\MKY\EventHelper.cs:Zeile 370.
                         bei YAT.Domain.RawTerminal.OnIOChanged(EventArgs<DateTime> e) in D:\Workspace\YAT\Trunk\YAT\YAT.Domain\RawTerminal\RawTerminal.cs:Zeile 792.
                         bei YAT.Domain.RawTerminal.io_IOChanged(Object sender, EventArgs e) in D:\Workspace\YAT\Trunk\YAT\YAT.Domain\RawTerminal\RawTerminal.cs:Zeile 689.
                    InnerException 2:
                         Message=Ein Aufrufziel hat einen Ausnahmefehler verursacht.
                         Source=mscorlib
                         StackTrace:
                              bei System.RuntimeMethodHandle._InvokeMethodFast(Object target, Object[] arguments, SignatureStruct& sig, MethodAttributes methodAttributes, RuntimeTypeHandle typeOwner)
                              bei System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture, Boolean skipVisibilityChecks)
                              bei System.Delegate.DynamicInvokeImpl(Object[] args)
                              bei MKY.EventHelper.Item.InvokeOnCurrentThread(Delegate sink, Object[] args) in D:\Workspace\YAT\Trunk\MKY\MKY\EventHelper.cs:Zeile 595.
                              bei MKY.EventHelper.Item.RaiseSync(Delegate eventDelegate, Object[] args) in D:\Workspace\YAT\Trunk\MKY\MKY\EventHelper.cs:Zeile 370.
                              bei YAT.Domain.Terminal.OnIOChanged(EventArgs<DateTime> e) in D:\Workspace\YAT\Trunk\YAT\YAT.Domain\Terminal\Terminal.cs:Zeile 3890.
                              bei YAT.Domain.Terminal.rawTerminal_IOChanged(Object sender, EventArgs e) in D:\Workspace\YAT\Trunk\YAT\YAT.Domain\Terminal\Terminal.cs:Zeile 3767.
                         InnerException 3:
                              Message=Invoke oder BeginInvoke kann fr ein Steuerelement erst aufgerufen werden, wenn das Fensterhandle erstellt wurde.
                              Source=System.Windows.Forms
                              StackTrace:
                                   bei System.Windows.Forms.Control.WaitForWaitHandle(WaitHandle waitHandle)
                                   bei System.Windows.Forms.Control.MarshaledInvoke(Control caller, Delegate method, Object[] args, Boolean synchronous)
                                   bei System.Windows.Forms.Control.Invoke(Delegate method, Object[] args)
                                   bei MKY.EventHelper.Item.InvokeSynchronized(ISynchronizeInvoke sinkTarget, Delegate sink, Object[] args) in D:\Workspace\YAT\Trunk\MKY\MKY\EventHelper.cs:Zeile 567.
                                   bei MKY.EventHelper.Item.RaiseSync(Delegate eventDelegate, Object[] args) in D:\Workspace\YAT\Trunk\MKY\MKY\EventHelper.cs:Zeile 368.
                                   bei YAT.Model.Terminal.OnIOChanged(EventArgs<DateTime> e) in D:\Workspace\YAT\Trunk\YAT\YAT.Model\Terminal.cs:Zeile 5246.
                                   bei YAT.Model.Terminal.terminal_IOChanged(Object sender, EventArgs e) in D:\Workspace\YAT\Trunk\YAT\YAT.Model\Terminal.cs:Zeile 2479.
             ]]>
            
             The terminals get properly closed, but apparently there may still be pending
             asynchronous 'zombie' callback that later throw an exception. No feasible solution has
             been found, however there is a potential approach to deal with this issue:
            
             This raw terminal could dispose of the underlying <see cref="T:MKY.IO.Serial.IIOProvider"/> on each
             <see cref="M:YAT.Domain.RawTerminal.Stop"/>. But of course, the <see cref="T:MKY.IO.Serial.IIOProvider"/> would again have to
             be created on each <see cref="M:YAT.Domain.RawTerminal.Start"/>. Or yet another alternative, the raw terminal's
             owner could invoke <see cref="M:YAT.Domain.RawTerminal.Close"/> instead of <see cref="M:YAT.Domain.RawTerminal.Stop"/>. Migrating to
             such alternative approach would require quite some refactoring, thus decided to keep
             the <see cref="F:MKY.EventHelper.ExceptionHandlingMode.DiscardDisposedTarget"/> approach for
             the moment.
            
             Temporarily disabling this handling/workaround can be useful for debugging, i.e. to
             continue program execution even in case of exceptions and let the debugger handle it.
             </remarks>
        </member>
        <member name="E:YAT.Domain.RawTerminal.IOChanged">
            <summary></summary>
        </member>
        <member name="E:YAT.Domain.RawTerminal.IOControlChanged">
            <summary></summary>
        </member>
        <member name="E:YAT.Domain.RawTerminal.IOWarning">
            <summary></summary>
        </member>
        <member name="E:YAT.Domain.RawTerminal.IOError">
            <summary></summary>
        </member>
        <member name="E:YAT.Domain.RawTerminal.ChunkSent">
            <summary></summary>
        </member>
        <member name="E:YAT.Domain.RawTerminal.ChunkReceived">
            <summary></summary>
        </member>
        <member name="E:YAT.Domain.RawTerminal.RepositoryCleared">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.#ctor(YAT.Domain.Settings.IOSettings,YAT.Domain.Settings.BufferSettings)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.#ctor(YAT.Domain.RawTerminal,YAT.Domain.Settings.IOSettings,YAT.Domain.Settings.BufferSettings)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:YAT.Domain.RawTerminal.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="P:YAT.Domain.RawTerminal.BufferSettings">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawTerminal.IOSettings">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawTerminal.IsStopped">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawTerminal.IsStarted">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawTerminal.IsOpen">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawTerminal.IsConnected">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawTerminal.IsTransmissive">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawTerminal.IsSending">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawTerminal.LastReceivedChunkTimeStamp">
            <remarks>
            Opposed to <see cref="P:YAT.Domain.RawTerminal.IsSending"/>, where the amount of data expected for sending is
            known by the caller, there is no information on the availability and amout of data
            for receiving, nor any way to determine whether data may be coming in soon. Thus, an
            "IsReceiving" property makes little sense. Instead, this time stamp may be used to
            determine for how long the I/O instance has not been receiving data anymore, and can
            combine this time stamp with a time-out.
            </remarks>
        </member>
        <member name="P:YAT.Domain.RawTerminal.UnderlyingIOProvider">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawTerminal.UnderlyingIOInstance">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.Start">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.Stop">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.Close">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.Send(System.Byte[])">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.ClearSendBuffer">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.RepositoryToChunks(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.ClearRepository(YAT.Domain.RepositoryType)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.ClearRepositories">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.RepositoryToExtendedDiagnosticsString(YAT.Domain.RepositoryType,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.io_DataReceived(System.Object,MKY.IO.Serial.DataReceivedEventArgs)">
            <remarks>
            Synchronization to prevent a race condition is required here, see contract.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RawTerminal.io_DataSent(System.Object,MKY.IO.Serial.DataSentEventArgs)">
            <remarks>
            Synchronization to prevent a race condition is required here, see contract.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RawTerminal.OnIOChanged(MKY.EventArgs{System.DateTime})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.OnIOControlChanged(MKY.EventArgs{System.DateTime})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.OnIOWarning(YAT.Domain.IOWarningEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.OnIOError(YAT.Domain.IOErrorEventArgs)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.OnChunkSent(MKY.EventArgs{YAT.Domain.RawChunk})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.OnChunkReceived(MKY.EventArgs{YAT.Domain.RawChunk})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.OnRepositoryCleared(MKY.EventArgs{YAT.Domain.RepositoryType})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.RawTerminal.ToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.RawTerminal.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RawTerminal.ToShortIOString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.RawTerminal.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RawTerminal.DebugMessage(System.String,System.Object[])">
            <remarks>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with the formatted message, and rather than e.g. "Common" for comprehensibility.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RawTerminal.DebugMessage(System.String)">
            <remarks>
            Name "DebugWriteLine" would show relation to <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>.
            However, named "Message" for compactness and more clarity that something will happen
            with <paramref name="message"/>, and rather than e.g. "Common" for comprehensibility.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RawTerminal.DebugDataReceived(System.Int32)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RawTerminal.DebugDataSent(System.Int32)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="T:YAT.Domain.RawChunk">
            <summary>
            Defines an element received from or sent to a serial interface. In addition to the raw byte
            content itself, it also contains interface and time information.
            </summary>
        </member>
        <member name="P:YAT.Domain.RawChunk.Content">
            <remarks>
            "Guidelines for Collections: Do use byte arrays instead of collections of bytes."
            is overruled in order to be able to implement this class as immutable.
            </remarks>
        </member>
        <member name="P:YAT.Domain.RawChunk.TimeStamp">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawChunk.Device">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawChunk.Direction">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawChunk.#ctor(System.Collections.Generic.IList{System.Byte},System.String,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawChunk.#ctor(System.Collections.Generic.IList{System.Byte},System.DateTime,System.String,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawChunk.ContentToString">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawChunk.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.RawChunk.ToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.RawChunk.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="T:YAT.Domain.RawRepository">
            <summary>
            This class wraps a size limited <see cref="T:System.Collections.Generic.Queue`1"/> holding <see cref="T:YAT.Domain.RawChunk"/> items.
            </summary>
        </member>
        <member name="M:YAT.Domain.RawRepository.#ctor(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawRepository.#ctor(YAT.Domain.RawRepository)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.RawRepository.Capacity">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawRepository.Enqueue(YAT.Domain.RawChunk)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawRepository.Clear">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawRepository.ToByteArray">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawRepository.ToChunks">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.RawRepository.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.RawRepository.QueueToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.RawRepository.ToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.RawRepository.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="M:YAT.Domain.RawRepository.QueueToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.RawRepository.QueueToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="T:YAT.Domain.DecodingMismatchBehavior">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DecodingMismatchBehaviorEx">
            <summary>
            Extended enum DecodingMismatchBehaviorEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.DecodingMismatchBehaviorEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.DecodingMismatchBehavior.ComprehensiveWarning"/>.</summary>
        </member>
        <member name="M:YAT.Domain.DecodingMismatchBehaviorEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.DecodingMismatchBehaviorEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.DecodingMismatchBehaviorEx.#ctor(YAT.Domain.DecodingMismatchBehavior)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DecodingMismatchBehaviorEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.DecodingMismatchBehaviorEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.DecodingMismatchBehaviorEx.op_Implicit(YAT.Domain.DecodingMismatchBehaviorEx)~YAT.Domain.DecodingMismatchBehavior">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DecodingMismatchBehaviorEx.op_Implicit(YAT.Domain.DecodingMismatchBehavior)~YAT.Domain.DecodingMismatchBehaviorEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DecodingMismatchBehaviorEx.op_Implicit(YAT.Domain.DecodingMismatchBehaviorEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DecodingMismatchBehaviorEx.op_Implicit(System.Int32)~YAT.Domain.DecodingMismatchBehaviorEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DecodingMismatchBehaviorEx.op_Implicit(YAT.Domain.DecodingMismatchBehaviorEx)~System.String">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.TextUnidirState">
            <remarks>
            So far, only unidirectional state must be kept. Opposed to <see cref="T:YAT.Domain.ProcessState"/> which
            is kept three times (Tx/Bidir/Rx), the text terminal specific state is limited to a "line"
            state which is instantiated four times (Tx/TxBidir/RxBidir/Rx), "line" meaning "display line".
            </remarks>
        </member>
        <member name="P:YAT.Domain.TextUnidirState.EolSequence">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TextUnidirState.PendingMultiBytesToDecode">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TextUnidirState.ShownCharCount">
            <remarks>Required to handle lines that only contain an EOL (=> show) or pending EOL (=> hide).</remarks>
        </member>
        <member name="P:YAT.Domain.TextUnidirState.HasEverShownChar">
            <remarks>Required to handle empty lines that got empty due to backspaces.</remarks>
        </member>
        <member name="P:YAT.Domain.TextUnidirState.EolOfGivenDevice">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TextUnidirState.RetainedUnconfirmedHiddenEolElements">
            <remarks>Must not be a <see cref="T:YAT.Domain.DisplayElementCollection"/> to prevent elements from being appended/merged.</remarks>
        </member>
        <member name="M:YAT.Domain.TextUnidirState.#ctor(System.Byte[])">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TextUnidirState.IsYetEmpty">
            <summary>
            Indicates that line is yet empty.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextUnidirState.InitializeValues">
            <summary>
            Initializes the state.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextUnidirState.Reset">
            <summary>
            Resets the state, i.e. restarts processing with an empty repository.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextUnidirState.NotifyShownCharCount(System.Int32)">
            <summary>
            Notify added or removed <see cref="P:YAT.Domain.DisplayElement.CharCount"/> shown in the current line.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextUnidirState.NotifyLineEnd(System.String)">
            <summary>
            Notify the end of a line, i.e. continues processing with the next line.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextUnidirState.EolIsAnyMatch(System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextUnidirState.EolIsCompleteMatch(System.String)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.CharSubstitution">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.CharSubstitutionEx">
            <summary>
            Extended enum CharSubstitutionEx.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.CharSubstitutionEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.CharSubstitution.None"/>.</summary>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.CharSubstitutionEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.#ctor(YAT.Domain.CharSubstitution)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.TryParse(System.String,YAT.Domain.CharSubstitutionEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.TryParse(System.String,YAT.Domain.CharSubstitution@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.op_Implicit(YAT.Domain.CharSubstitutionEx)~YAT.Domain.CharSubstitution">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.op_Implicit(YAT.Domain.CharSubstitution)~YAT.Domain.CharSubstitutionEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.op_Implicit(YAT.Domain.CharSubstitutionEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.op_Implicit(System.Int32)~YAT.Domain.CharSubstitutionEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.op_Implicit(YAT.Domain.CharSubstitutionEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.CharSubstitutionEx.op_Implicit(System.String)~YAT.Domain.CharSubstitutionEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.IOControlEventArgs">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOControlEventArgs.Direction">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOControlEventArgs.Texts">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOControlEventArgs.TimeStamp">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOControlEventArgs.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOControlEventArgs.#ctor(YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOControlEventArgs.#ctor(YAT.Domain.IODirection,System.Collections.ObjectModel.ReadOnlyCollection{System.String})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOControlEventArgs.#ctor(YAT.Domain.IODirection,System.Collections.ObjectModel.ReadOnlyCollection{System.String},System.DateTime)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.IOWarningEventArgs">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOWarningEventArgs.Direction">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOWarningEventArgs.Message">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOWarningEventArgs.TimeStamp">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOWarningEventArgs.#ctor(YAT.Domain.IODirection,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOWarningEventArgs.#ctor(YAT.Domain.IODirection,System.String,System.DateTime)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.IOErrorEventArgs">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOErrorEventArgs.Severity">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOErrorEventArgs.Direction">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOErrorEventArgs.Message">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.IOErrorEventArgs.TimeStamp">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOErrorEventArgs.#ctor(YAT.Domain.IOErrorSeverity,YAT.Domain.IODirection,System.String)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.IOErrorEventArgs.#ctor(YAT.Domain.IOErrorSeverity,YAT.Domain.IODirection,System.String,System.DateTime)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.SerialPortErrorEventArgs">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.SerialPortErrorEventArgs.SerialPortError">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.SerialPortErrorEventArgs.#ctor(YAT.Domain.IOErrorSeverity,YAT.Domain.IODirection,System.String,System.IO.Ports.SerialError,System.DateTime)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayElementsEventArgs">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayElementsEventArgs.Elements">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayElementsEventArgs.#ctor(YAT.Domain.DisplayElementCollection)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayLineEventArgs">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayLineEventArgs.Line">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayLineEventArgs.#ctor(YAT.Domain.DisplayLine)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.DisplayLinesEventArgs">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.DisplayLinesEventArgs.Lines">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.DisplayLinesEventArgs.#ctor(YAT.Domain.DisplayLineCollection)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.RepositoryType">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.SendMode">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.LinePosition">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.LinePosition.Begin">
            <remarks>
            Also applies if the next line has not been started yet, i.e. 'LinePosition.None'.
            </remarks>
        </member>
        <member name="T:YAT.Domain.PostponeResult">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.TextTerminal">
            <remarks>
            This partial class implements the repository part of <see cref="T:YAT.Domain.TextTerminal"/>.
            </remarks>
            <remarks>
            This partial class implements the process part of <see cref="T:YAT.Domain.TextTerminal"/>.
            </remarks>
            <remarks>
            This partial class implements the send part of <see cref="T:YAT.Domain.TextTerminal"/>.
            </remarks>
            <summary>
            <see cref="T:YAT.Domain.Terminal"/> implementation with text semantics.
            </summary>
            <remarks>
            This class is implemented using partial classes separating sending/processing functionality.
            Using partial classes rather than aggregated sender, processor,... so far for these reasons:
            <list type="bullet">
            <item><description>Simpler for implementing text/binary specialization.</description></item>
            <item><description>Simpler for implementing synchronization among Tx and Rx.</description></item>
            <item><description>Less simple-stupid-forwarder, e.g. directly raising events.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DoFinishReload(YAT.Domain.RepositoryType)">
            <summary>
            Implements the text terminal specific <see cref="P:YAT.Domain.Settings.TextTerminalSettings.GlueCharsOfLine"/> functionality.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ByteToElement(System.Byte,System.DateTime,YAT.Domain.IODirection,YAT.Domain.Radix,System.Collections.Generic.List{System.Byte})">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DecodeAndCreateElement(System.Byte,System.DateTime,YAT.Domain.IODirection,YAT.Domain.Radix,System.Text.Encoding)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateDataElement(System.Byte,System.DateTime,YAT.Domain.IODirection,YAT.Domain.Radix,System.Char)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateDataElement(System.Byte[],System.DateTime,YAT.Domain.IODirection,YAT.Domain.Radix,System.Char)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateDataElement(System.Byte[],System.DateTime,YAT.Domain.IODirection,YAT.Domain.Radix,System.Char[])">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.HandleInvalidByte(System.Byte,System.DateTime,YAT.Domain.IODirection,System.Text.Encoding)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.HandleInvalidBytes(System.Byte[],System.DateTime,YAT.Domain.IODirection,System.Text.Encoding)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.HandleOutsideUnicodePlane0(System.Byte[],System.DateTime,YAT.Domain.IODirection,System.Text.Encoding)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateComprehensiveInvalidByteWarning(System.Byte,System.DateTime,YAT.Domain.IODirection,System.Text.Encoding)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateComprehensiveInvalidBytesWarning(System.Byte[],System.DateTime,YAT.Domain.IODirection,System.Text.Encoding)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateComprehensiveOutsideUnicodePlane0Warning(System.Byte[],System.DateTime,YAT.Domain.IODirection,System.Text.Encoding)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateReplacementCharacterAndCompactInvalidByteWarning(System.Byte,System.DateTime,YAT.Domain.IODirection,System.Text.Encoding,System.String)">
            <remarks>
            <see cref="T:YAT.Domain.DisplayElement"/> requires a string, thus using <c>string</c> instead of <c>char</c> for replacement character.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateReplacementCharacterAndCompactInvalidBytesWarning(System.Byte[],System.DateTime,YAT.Domain.IODirection,System.Text.Encoding,System.String)">
            <remarks>
            <see cref="T:YAT.Domain.DisplayElement"/> requires a string, thus using <c>string</c> instead of <c>char</c> for replacement character.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateReplacementCharacterElement(System.Byte,System.DateTime,YAT.Domain.IODirection,System.String)">
            <remarks>
            <see cref="T:YAT.Domain.DisplayElement"/> requires a string, thus using <c>string</c> instead of <c>char</c> for replacement character.
            </remarks>
            <remarks>
            Using <see cref="T:YAT.Domain.DisplayElement.WarningInfo"/> rather than <see cref="T:YAT.Domain.DisplayElement.TxData"/> or <see cref="T:YAT.Domain.DisplayElement.RxData"/> to enable coloring.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateReplacementCharacterElement(System.Byte[],System.DateTime,YAT.Domain.IODirection,System.String)">
            <remarks>
            <see cref="T:YAT.Domain.DisplayElement"/> requires a string, thus using <c>string</c> instead of <c>char</c> for replacement character.
            </remarks>
            <remarks>
            Using <see cref="T:YAT.Domain.DisplayElement.WarningInfo"/> rather than <see cref="T:YAT.Domain.DisplayElement.TxData"/> or <see cref="T:YAT.Domain.DisplayElement.RxData"/> to enable coloring.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateDiscardElement(System.Byte,System.DateTime,YAT.Domain.IODirection)">
            <remarks>
            <see cref="T:YAT.Domain.DisplayElement"/> requires a string, thus using <c>string</c> instead of <c>char</c> for replacement character.
            </remarks>
            <remarks>
            Using <see cref="T:YAT.Domain.DisplayElement.WarningInfo"/> rather than <see cref="T:YAT.Domain.DisplayElement.TxData"/> or <see cref="T:YAT.Domain.DisplayElement.RxData"/> to enable coloring.
            Using <see cref="T:YAT.Domain.DisplayElement.WarningInfo"/> rather than <see cref="T:YAT.Domain.DisplayElement.Nonentity"/> to keep correct byte count.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.CreateDiscardElement(System.Byte[],System.DateTime,YAT.Domain.IODirection)">
            <remarks>
            <see cref="T:YAT.Domain.DisplayElement"/> requires a string, thus using <c>string</c> instead of <c>char</c> for replacement character.
            </remarks>
            <remarks>
            Using <see cref="T:YAT.Domain.DisplayElement.WarningInfo"/> rather than <see cref="T:YAT.Domain.DisplayElement.TxData"/> or <see cref="T:YAT.Domain.DisplayElement.RxData"/> to enable coloring.
            Using <see cref="T:YAT.Domain.DisplayElement.WarningInfo"/> rather than <see cref="T:YAT.Domain.DisplayElement.Nonentity"/> to keep correct byte count.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.AddContentSeparatorAsNeeded(YAT.Domain.LineState,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection,YAT.Domain.DisplayElement)">
            <remarks>This text specific implementation is based on <see cref="P:YAT.Domain.DisplayElementCollection.CharCount"/>.</remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.InitializeProcess">
            <remarks>
            <c>private</c> rather than <c>protected override</c> because method depends on code
            sequence in constructors.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DisposeProcess">
            <summary>
            Disposes the processing state.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ResetProcess(YAT.Domain.RepositoryType)">
            <summary>
            Resets the processing state for the given <paramref name="repositoryType"/>.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.GetTextUnidirState(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <remarks>
            This method shall not be overridden as it accesses the private members
            <see cref="F:YAT.Domain.TextTerminal.textTxState"/>, <see cref="F:YAT.Domain.TextTerminal.textRxState"/>,
            <see cref="F:YAT.Domain.TextTerminal.textBidirTxState"/>, <see cref="F:YAT.Domain.TextTerminal.textBidirRxState"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.SuspendChunkTimeouts(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ResumeChunkTimeouts(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessChunkPre(YAT.Domain.RepositoryType,YAT.Domain.RawChunk)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessChunk(YAT.Domain.RepositoryType,YAT.Domain.RawChunk,YAT.Domain.PostponeResult@)">
            <summary>
            Implements the text terminal specific <see cref="P:YAT.Domain.Settings.TextTerminalSettings.GlueCharsOfLine"/> functionality.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessChunkPre(YAT.Domain.RepositoryType,YAT.Domain.RawChunk,YAT.Domain.PostponeResult@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.GlueCharsOfLineTimeoutHasElapsed(System.DateTime,System.DateTime)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessByteOfChunk(YAT.Domain.RepositoryType,System.Byte,System.DateTime,System.String,YAT.Domain.IODirection,System.Boolean,System.Boolean,YAT.Domain.DisplayElementCollection@,YAT.Domain.DisplayLineCollection@,System.Boolean@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DoLineEndPost(YAT.Domain.RepositoryType,YAT.Domain.ProcessState,System.DateTime,YAT.Domain.IODirection,System.Boolean,System.Boolean@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DoLineContentCheck(YAT.Domain.RepositoryType,YAT.Domain.ProcessState,System.DateTime,YAT.Domain.IODirection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DoLineBegin(YAT.Domain.RepositoryType,YAT.Domain.ProcessState,System.DateTime,System.String,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ControlCharacterHasBeenProcessed(System.Byte,System.DateTime,YAT.Domain.IODirection,YAT.Domain.DisplayElement@,System.Boolean@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ConfirmRetainedUnconfirmedHiddenEolElements(YAT.Domain.TextUnidirState)">
            <summary>
            Confirms the retained unconfirmed hidden EOL elements by discarding them.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ReleaseRetainedUnconfirmedHiddenEolElements(YAT.Domain.LineState,YAT.Domain.TextUnidirState,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection)">
            <summary>
            Releases the retained unconfirmed hidden EOL elements by adding them to <paramref name="lp"/>.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DoLineEnd(YAT.Domain.RepositoryType,YAT.Domain.ProcessState,System.DateTime,YAT.Domain.IODirection,YAT.Domain.DisplayElementCollection@,YAT.Domain.DisplayLineCollection@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.SuspendGlueCharsOfLineTimeoutIfNeeded(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <remarks>
            Chunk and timed processing is synchronized against <see cref="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj"/>.
            Thus, time-outs can be suspended during chunk processing.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ResumeGlueCharsOfLineTimeoutIfNeeded(YAT.Domain.RepositoryType,YAT.Domain.IODirection)">
            <remarks>
            Chunk and timed processing is synchronized against <see cref="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj"/>.
            Thus, time-outs can be suspended during chunk processing.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.glueCharsOfLineTimeout_Elapsed(System.Object,MKY.EventArgs{System.DateTime})">
             <remarks>
             This event handler must synchronize against <see cref="P:YAT.Domain.Terminal.ChunkVsTimedSyncObj"/>!
            
             Saying hello to StyleCop ;-.
             </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessAndSignalGlueOfCharsTimeoutOfTimedOutPostponedChunks(System.DateTime)">
            <remarks>Rather long name, but makes obvious what is being done.</remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessAndSignalGlueOfCharsTimeoutOfRemainingPostponedChunks">
            <remarks>Rather long name, but makes obvious what is being done.</remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessAndSignalGlueOfCharsTimeout(System.DateTime)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessAndSignalGlueCharsOfLineTimeoutOfTimedOutPostponedChunksOnReloadIfNeeded(System.DateTime)">
            <remarks>Rather long name, but makes obvious what is being done.</remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessAndSignalGlueCharsOfLineTimeoutOfRemainingPostponedChunksOnReloadIfNeeded">
            <remarks>Rather long name, but makes obvious what is being done.</remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ResetWaitForResponse">
            <remarks>
            Could be extracted into a separate class or struct.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.NotifyLineResponse">
            <remarks>
            Could be extracted into a separate class or struct.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.GetLineClearance(YAT.Domain.Utilities.ForSomeTimeEventHelper)">
            <remarks>
            Could be extracted into a separate class or struct.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ClearanceTimeoutHasElapsed(System.DateTime)">
            <remarks>
            Separation into method instead of complicated <c>if</c>-condition.
            </remarks>
            <remarks>
            Must only be called from within a <see cref="F:YAT.Domain.TextTerminal.waitForResponseClearanceSyncObj"/> lock.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DebugGlueCharsOfLine(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DebugWaitForResponse(System.String)">
            <remarks>
            <c>private</c> because value of <see cref="T:System.Diagnostics.ConditionalAttribute"/> is limited to file scope.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DoSendTextItem(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.TextSendItem)">
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessInLineKeywords(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.Parser.KeywordResult,System.Collections.Generic.Queue{System.Byte},System.Boolean@,System.Boolean@)">
            <remarks>Shall not be called if keywords are disabled.</remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessLineEnd(YAT.Domain.Utilities.ForSomeTimeEventHelper,System.Boolean,System.Collections.Generic.Queue{System.Byte},System.Boolean@)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ProcessLineDelayOrInterval(YAT.Domain.Utilities.ForSomeTimeEventHelper,System.Boolean,System.Int32,System.Boolean,System.Int32,System.DateTime,System.DateTime)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DoSendFileItem(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.FileSendItem)">
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.DoSendRtfFileItem(YAT.Domain.Utilities.ForSomeTimeEventHelper,YAT.Domain.FileSendItem)">
            <remarks>
            <paramref name="forSomeTimeEventHelper"/> is located first as needed down the call chain.
            </remarks>
        </member>
        <member name="F:YAT.Domain.TextTerminal.KeywordHelp">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.#ctor(YAT.Domain.Settings.TerminalSettings)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.#ctor(YAT.Domain.Settings.TerminalSettings,YAT.Domain.Terminal)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.Dispose(System.Boolean)">
            <param name="disposing">
            <c>true</c> when called from <see cref="M:YAT.Domain.TextTerminal.Dispose(System.Boolean)"/>,
            <c>false</c> when called from finalizer.
            </param>
        </member>
        <member name="P:YAT.Domain.TextTerminal.TextTerminalSettings">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.TextTerminal.TxEolSequence">
            <summary>
            Gets the Tx EOL sequence.
            </summary>
        </member>
        <member name="P:YAT.Domain.TextTerminal.RxEolSequence">
            <summary>
            Gets the Rx EOL sequence.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.Start">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.TryParse(System.String,YAT.Domain.Radix,YAT.Domain.Parser.Mode,YAT.Domain.Parser.Result[]@,System.String@)">
            <summary>
            Tries to parse <paramref name="s"/>, taking the current settings into account.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.TryParse(System.String,YAT.Domain.Radix,System.Byte[]@)">
            <summary>
            Tries to parse <paramref name="s"/>, taking the current settings into account.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.RemoveFraming(System.Byte[])">
            <summary>
            Removes the framing from the given data.
            </summary>
            <remarks>
            For text terminals, framing is typically defined by EOL.
            For binary terminals, framing is optionally defined by sequence before/after.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            <see cref="P:YAT.Domain.Settings.TextTerminalSettings.TxEol"/> and
            <see cref="P:YAT.Domain.Settings.TextTerminalSettings.RxEol"/> have different values.
            </exception>
        </member>
        <member name="M:YAT.Domain.TextTerminal.RemoveFraming(System.Byte[],YAT.Domain.IODirection)">
            <summary>
            Removes the framing from the given data.
            </summary>
            <remarks>
            For text terminals, framing is typically defined by EOL.
            For binary terminals, framing is optionally defined by sequence before/after.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.RemoveFraming(System.Byte[],System.Byte[])">
            <summary>
            Removes the framing from the given data.
            </summary>
            <remarks>
            For text terminals, framing is typically defined by EOL.
            For binary terminals, framing is optionally defined by sequence before/after.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.GetTextDisplaySettings(YAT.Domain.IODirection)">
            <remarks>
            This method shall not be overridden as it accesses the quasi-private member
            <see cref="P:YAT.Domain.TextTerminal.TextTerminalSettings"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.TextTerminalSettings_Changed(System.Object,MKY.Settings.SettingsEventArgs)">
            <remarks>
            Used for e.g. showing/hiding EOL.
            </remarks>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.TextTerminal.ToExtendedDiagnosticsString(System.String)">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
            <remarks>
            Extended <see cref="M:YAT.Domain.TextTerminal.ToString"/> method which can be used for trace/debug.
            </remarks>
        </member>
        <member name="T:YAT.Domain.ControlCharRadix">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.ControlCharRadix.String">
            <remarks>
            Keep this item to ensure that items can 1:1 be mapped to <see cref="T:YAT.Domain.Radix"/>
            and that additional items get distinct enum identifiers.
            </remarks>
        </member>
        <member name="F:YAT.Domain.ControlCharRadix.Char">
            <remarks>
            Keep this item to ensure that items can 1:1 be mapped to <see cref="T:YAT.Domain.Radix"/>
            and that additional items get distinct enum identifiers.
            </remarks>
        </member>
        <member name="F:YAT.Domain.ControlCharRadix.Unicode">
            <remarks>
            Keep this item to ensure that items can 1:1 be mapped to <see cref="T:YAT.Domain.Radix"/>
            and that additional items get distinct enum identifiers.
            </remarks>
        </member>
        <member name="T:YAT.Domain.ControlCharRadixEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.ControlCharRadixEx.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.ControlCharRadixEx.#ctor(YAT.Domain.ControlCharRadix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.ControlCharRadixEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.ControlCharRadixEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.ControlCharRadixEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.ControlCharRadixEx.TryParse(System.String,YAT.Domain.ControlCharRadixEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.ControlCharRadixEx.TryParse(System.String,YAT.Domain.ControlCharRadix@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.ControlCharRadixEx.op_Implicit(YAT.Domain.ControlCharRadixEx)~YAT.Domain.ControlCharRadix">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.ControlCharRadixEx.op_Implicit(YAT.Domain.ControlCharRadix)~YAT.Domain.ControlCharRadixEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.ControlCharRadixEx.op_Explicit(YAT.Domain.ControlCharRadixEx)~YAT.Domain.Radix">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.ControlCharRadixEx.op_Explicit(YAT.Domain.Radix)~YAT.Domain.ControlCharRadixEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Utilities.ForSomeTimeEventHelper">
            <summary>
            While sending, the 'IsSendingForSomeTimeChanged' event must be raised before or when
            intensive processing is done. This is required because a client may want to indicate that
            time intensive sending is currently ongoing and no further data shall be sent.
            The event shall be raised if the time lag will significantly be noticeable by the user
            (i.e. >= 250 ms). But the event shall be raised BEFORE the actual time lag. This helper
            struct manages the state and the various criteria.
            </summary>
        </member>
        <member name="F:YAT.Domain.Utilities.ForSomeTimeEventHelper.Threshold">
            <remarks>In milliseconds.</remarks>
        </member>
        <member name="M:YAT.Domain.Utilities.ForSomeTimeEventHelper.#ctor(System.DateTime)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Utilities.ForSomeTimeEventHelper.EventMustBeRaised">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.ForSomeTimeEventHelper.ChunkSizeIsAboveThreshold(System.Int32,System.Double)">
            <remarks>Using term "byte" rather than "octet" as that is more common, and .NET uses "byte" as well.</remarks>
        </member>
        <member name="M:YAT.Domain.Utilities.ForSomeTimeEventHelper.RaiseEventIfChunkSizeIsAboveThreshold(System.Int32,System.Double)">
            <remarks>Using term "byte" rather than "octet" as that is more common, and .NET uses "byte" as well.</remarks>
        </member>
        <member name="M:YAT.Domain.Utilities.ForSomeTimeEventHelper.DelayIsAboveThreshold(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.ForSomeTimeEventHelper.RaiseEventIfDelayIsAboveThreshold(System.Int32)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.ForSomeTimeEventHelper.TotalTimeLagIsAboveThreshold">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.ForSomeTimeEventHelper.RaiseEventIfTotalTimeLagIsAboveThreshold">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Utilities.ByteHelper">
            <summary>
            Static utility class providing byte functionality for YAT.
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.ByteHelper.FormatHexString(System.Byte,System.Boolean)">
            <summary>
            Formats the given value into a hexadecimal string (e.g. "0Ah").
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.ByteHelper.FormatHexString(System.Collections.Generic.IEnumerable{System.Byte},System.Boolean)">
            <summary>
            Formats the given values into a hexadecimal string (e.g. "0Ah FFh 20h").
            </summary>
        </member>
        <member name="T:YAT.Domain.Utilities.LengthSelection">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Utilities.LengthSelection.ByteCount">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Utilities.LengthSelection.CharCount">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Utilities.LengthSelectionEx">
            <summary>
            Extended enum LengthSelectionEx which extends <see cref="T:YAT.Domain.Utilities.LengthSelection"/>.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Utilities.LengthSelectionEx.TextDefault">
            <summary>Default for text terminals is <see cref="F:YAT.Domain.Utilities.LengthSelection.CharCount"/>.</summary>
        </member>
        <member name="F:YAT.Domain.Utilities.LengthSelectionEx.BinaryDefault">
            <summary>Default for binary terminals is <see cref="F:YAT.Domain.Utilities.LengthSelection.ByteCount"/>.</summary>
        </member>
        <member name="F:YAT.Domain.Utilities.LengthSelectionEx.Default">
            <summary>
            Default is <see cref="F:YAT.Domain.Utilities.LengthSelectionEx.BinaryDefault"/> as its value of
            <see cref="F:YAT.Domain.Utilities.LengthSelection.ByteCount"/> is supported by all terminal types.
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.#ctor">
            <summary>
            Default is <see cref="F:YAT.Domain.Utilities.LengthSelectionEx.Default"/>.
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.#ctor(YAT.Domain.TerminalType)">
            <summary>
            Default is <see cref="F:YAT.Domain.Utilities.LengthSelectionEx.TextDefault"/> for text
            and <see cref="F:YAT.Domain.Utilities.LengthSelectionEx.BinaryDefault"/> for binary terminals.
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.#ctor(YAT.Domain.Utilities.LengthSelection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.Parse(System.String,YAT.Domain.TerminalType)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.TryParse(System.String,YAT.Domain.TerminalType,YAT.Domain.Utilities.LengthSelectionEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.TryParse(System.String,YAT.Domain.TerminalType,YAT.Domain.Utilities.LengthSelection@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.op_Implicit(YAT.Domain.Utilities.LengthSelectionEx)~YAT.Domain.Utilities.LengthSelection">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.op_Implicit(YAT.Domain.Utilities.LengthSelection)~YAT.Domain.Utilities.LengthSelectionEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.op_Implicit(YAT.Domain.Utilities.LengthSelectionEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.op_Implicit(System.Int32)~YAT.Domain.Utilities.LengthSelectionEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.op_Implicit(YAT.Domain.Utilities.LengthSelectionEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LengthSelectionEx.op_Implicit(System.String)~YAT.Domain.Utilities.LengthSelectionEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Utilities.LineNumberSelection">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Utilities.LineNumberSelection.Total">
            <summary></summary>
        </member>
        <member name="F:YAT.Domain.Utilities.LineNumberSelection.Buffer">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Utilities.LineNumberSelectionEx">
            <summary>
            Extended enum LineNumberSelectionEx which extends <see cref="T:YAT.Domain.Utilities.LineNumberSelection"/>.
            </summary>
            <remarks>
            This <see cref="T:MKY.EnumEx"/> based type is not serializable because <see cref="T:System.Enum"/> isn't.
            Use the underlying enum for serialization, or alternatively, a string representation.
            </remarks>
        </member>
        <member name="F:YAT.Domain.Utilities.LineNumberSelectionEx.Default">
            <summary>Default is <see cref="F:YAT.Domain.Utilities.LineNumberSelection.Total"/>.</summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.#ctor">
            <summary>Default is <see cref="F:YAT.Domain.Utilities.LineNumberSelectionEx.Default"/>.</summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.#ctor(YAT.Domain.Utilities.LineNumberSelection)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.ToString">
            <summary>
            Converts the value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.GetItems">
            <remarks>
            An array of extended enum items is returned for more versatile use, e.g. view lists.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.Parse(System.String)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.TryParse(System.String,YAT.Domain.Utilities.LineNumberSelectionEx@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.TryParse(System.String,YAT.Domain.Utilities.LineNumberSelection@)">
            <remarks>
            Following the convention of the .NET framework, whitespace is trimmed from <paramref name="s"/>.
            </remarks>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.op_Implicit(YAT.Domain.Utilities.LineNumberSelectionEx)~YAT.Domain.Utilities.LineNumberSelection">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.op_Implicit(YAT.Domain.Utilities.LineNumberSelection)~YAT.Domain.Utilities.LineNumberSelectionEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.op_Implicit(YAT.Domain.Utilities.LineNumberSelectionEx)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.op_Implicit(System.Int32)~YAT.Domain.Utilities.LineNumberSelectionEx">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.op_Implicit(YAT.Domain.Utilities.LineNumberSelectionEx)~System.String">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.LineNumberSelectionEx.op_Implicit(System.String)~YAT.Domain.Utilities.LineNumberSelectionEx">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Utilities.RtfReaderHelper">
            <summary>
            Static utility class providing RTF reader functionality for YAT.
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.RtfReaderHelper.LinesFromRtfFile(System.String,System.String[]@)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Utilities.ValidationHelper">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.ValidationHelper.ValidateText(System.String,System.String,YAT.Domain.Parser.Mode,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.ValidationHelper.ValidateText(System.String,System.String,System.String@,YAT.Domain.Parser.Mode,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.ValidationHelper.ValidateText(System.String,System.String,System.Int32@,System.Int32@,System.String@,YAT.Domain.Parser.Mode,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.ValidationHelper.ValidateText(System.String,System.String,System.String@,System.String@,YAT.Domain.Parser.Mode,YAT.Domain.Radix)">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Utilities.XmlReaderHelper">
            <summary>
            Static utility class providing XML reader functionality for YAT.
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.XmlReaderHelper.LinesFromFile(System.String,System.String[]@)">
            <exception cref="T:System.IO.FileNotFoundException">
            A <see cref="T:System.IO.FileNotFoundException"/> is thrown if the file could not be found.
            </exception>
            <exception cref="T:System.UnauthorizedAccessException">
            A <see cref="T:System.UnauthorizedAccessException"/> is thrown if the file could not be accessed.
            </exception>
            <exception cref="T:System.IO.InvalidDataException">
            A <see cref="T:System.IO.InvalidDataException"/> is thrown if the file is empty or doesn't match the expected XML schema.
            </exception>
        </member>
        <member name="T:YAT.Domain.Utilities.XmlTransferLine">
            <summary>
            A line's XML object model for import/export transfers.
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.XmlTransferLine.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.XmlTransferLine.#ctor(System.DateTime,System.String,YAT.Domain.Direction)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Utilities.XmlTransferLine.TimeStamp">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Utilities.XmlTransferLine.Device">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Utilities.XmlTransferLine.Direction">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Utilities.XmlTransferRawLine">
            <summary>
            A line's XML object model for raw import/export transfers.
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.XmlTransferRawLine.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.XmlTransferRawLine.#ctor(System.DateTime,System.String,YAT.Domain.Direction,System.Byte[])">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Utilities.XmlTransferRawLine.DataAsBase64">
            <remarks>Data byte array is converted to Base64 encoded string.</remarks>
        </member>
        <member name="P:YAT.Domain.Utilities.XmlTransferRawLine.Content">
            <summary></summary>
        </member>
        <member name="T:YAT.Domain.Utilities.XmlTransferTextLine">
            <summary>
            A line's XML object model for text import/export transfers.
            </summary>
        </member>
        <member name="M:YAT.Domain.Utilities.XmlTransferTextLine.#ctor">
            <summary></summary>
        </member>
        <member name="M:YAT.Domain.Utilities.XmlTransferTextLine.#ctor(System.DateTime,System.String,YAT.Domain.Direction,System.String,System.Int32)">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Utilities.XmlTransferTextLine.Text">
            <summary></summary>
        </member>
        <member name="P:YAT.Domain.Utilities.XmlTransferTextLine.Length">
            <summary></summary>
        </member>
    </members>
</doc>
