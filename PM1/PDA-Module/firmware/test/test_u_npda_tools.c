/* ************************************************************************** */
/** @file test_u_npda_tools.c
 *
 *  @brief Unit tests verifying npda_tools.c module.
 *
 *  @copyright Occuity Limited (c) 2020
 */
/* ************************************************************************** */

#ifndef TEST_FILE_C /* Guard against accidental multiple inclusion */
#define TEST_FILE_C

/* ************************************************************************** */
/* Section: Included Files                                                    */
/* ************************************************************************** */

/* Header file for selective initialisation of hardware modules. */
#include "init_minimum_plus_timer.h" 
/* Library containing the test harness. */
#include "unity.h" 
#include <string.h> 

/* ************************************************************************** */
/* Include additional files to compile here                                   */
/* ************************************************************************** */
//TEST_FILE("file_to_compile.c")

/* ************************************************************************** */
/* Include files to test here                                                 */
/* ************************************************************************** */
#include "pdab_types.h"
#include "npda.h"
#include "npda_tools.h"

/* ************************************************************************** */
/* Section: File Scope or Global Data                                         */
/* ************************************************************************** */

/* ************************************************************************** */
/* Section: Local Functions                                                   */
/* ************************************************************************** */

/* ************************************************************************** */
/* Section: Interface Functions                                               */
/* ************************************************************************** */

/* ************************************************************************** */
/** 
 * @brief            This function contains code to be executed before unit
 *                   tests.
 *
 * @note             For testing npda_tools.c nothing needs to be set up.
 */
/* ************************************************************************** */
void setUp(void)
{
    __npda_offsetted_x_start = 0;
    memset(__npda_hhw, 0, MAX_AC_HHW*sizeof(byte));
    memset(__npda_avg, 0, MAX_WINDOW_SIZE*sizeof(fptype));
}

/* ************************************************************************** */
/** 
 * @brief            This function contains code to be executed after unit
 *                   tests.
 *
 * @note             For testing npda_tools.c nothing needs to be set up.
 */
/* ************************************************************************** */
void tearDown(void)
{
    __npda_offsetted_x_start = 0;
    memset(__npda_hhw, 0, MAX_AC_HHW*sizeof(byte));
    memset(__npda_avg, 0, MAX_WINDOW_SIZE*sizeof(fptype));
}

/* ************************************************************************** */
/** 
 * @brief            is_increasing_monotonically()
 *
 * @test             This is to test whether the is_increasing_monotonically()
 *                   function returns true on sample calibration data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_is_increasing_monotonically_returns_true_on_cal_data(void)
{
    const fptype cal_data[5000] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708, 0.0038819, 0.004993, 0.0061041, 0.0072153, 0.0083264, 0.0094375, 0.010549, 0.01166, 0.012771, 0.013882, 0.014993, 0.016104, 0.017215, 0.018326, 0.019437, 0.020549, 0.02166, 0.022771, 0.023882, 0.024993, 0.026104, 0.027215, 0.028326, 0.029437, 0.030549, 0.03166, 0.032771, 0.033882, 0.034993, 0.036104, 0.037215, 0.038326, 0.039437, 0.040549, 0.04166, 0.042771, 0.043882, 0.044993, 0.046104, 0.047215, 0.048326, 0.049437, 0.050549, 0.05166, 0.052771, 0.053882, 0.054994, 0.056108, 0.057223, 0.058335, 0.059335, 0.060336, 0.061339, 0.062342, 0.063347, 0.06435, 0.065353, 0.066353, 0.067353, 0.068351, 0.069358, 0.070364, 0.071368, 0.072371, 0.073373, 0.074374, 0.075375, 0.076378, 0.077381, 0.078385, 0.07939, 0.080395, 0.081402, 0.082409, 0.083417, 0.084427, 0.085436, 0.086446, 0.087455, 0.088468, 0.089566, 0.090664, 0.091762, 0.09286, 0.093957, 0.095054, 0.096151, 0.097247, 0.098343, 0.099443, 0.10046, 0.10147, 0.10249, 0.1035, 0.10451, 0.10553, 0.10654, 0.10756, 0.10857, 0.10958, 0.11046, 0.11135, 0.11224, 0.11313, 0.11402, 0.1149, 0.11579, 0.11668, 0.11757, 0.11844, 0.11954, 0.12064, 0.12173, 0.12283, 0.12394, 0.12504, 0.12614, 0.12724, 0.12834, 0.12947, 0.13035, 0.13123, 0.13211, 0.13298, 0.13385, 0.13472, 0.13558, 0.13645, 0.13732, 0.13819, 0.13919, 0.14026, 0.14134, 0.14241, 0.14349, 0.14457, 0.14565, 0.14673, 0.14781, 0.14889, 0.14987, 0.15075, 0.15162, 0.15249, 0.15336, 0.15423, 0.1551, 0.15596, 0.15683, 0.15753, 0.1586, 0.15967, 0.16075, 0.16182, 0.16289, 0.16396, 0.16504, 0.16611, 0.16718, 0.16826, 0.16933, 0.17029, 0.17126, 0.17223, 0.1732, 0.17417, 0.17515, 0.17612, 0.17709, 0.17807, 0.17904, 0.17994, 0.18082, 0.1817, 0.18258, 0.18347, 0.18435, 0.18524, 0.18612, 0.18701, 0.18789, 0.18889, 0.18996, 0.19103, 0.1921, 0.19316, 0.19423, 0.19529, 0.19635, 0.19742, 0.19849, 0.19957, 0.20051, 0.20149, 0.20248, 0.20347, 0.20445, 0.20545, 0.20644, 0.20742, 0.20841, 0.2094, 0.21026, 0.21114, 0.21201, 0.21289, 0.21376, 0.21463, 0.2155, 0.21637, 0.21724, 0.2181, 0.21908, 0.22007, 0.22106, 0.22204, 0.22303, 0.22402, 0.22501, 0.226, 0.22699, 0.22799, 0.22905, 0.23013, 0.23122, 0.23231, 0.23339, 0.23448, 0.23557, 0.23665, 0.23774, 0.23882, 0.23981, 0.2407, 0.24159, 0.24248, 0.24337, 0.24426, 0.24515, 0.24604, 0.24693, 0.24781, 0.24874, 0.24972, 0.2507, 0.25168, 0.25266, 0.25364, 0.25462, 0.2556, 0.25658, 0.25756, 0.25854, 0.25952, 0.2605, 0.26149, 0.26247, 0.26345, 0.26444, 0.26542, 0.2664, 0.26739, 0.26838, 0.26945, 0.27052, 0.27159, 0.27266, 0.27373, 0.2748, 0.27587, 0.27695, 0.27802, 0.27909, 0.28, 0.28088, 0.28176, 0.28264, 0.28353, 0.28441, 0.2853, 0.28619, 0.28707, 0.28796, 0.28891, 0.2899, 0.2909, 0.29189, 0.29288, 0.29387, 0.29486, 0.29586, 0.29685, 0.29784, 0.29887, 0.29994, 0.30101, 0.30208, 0.30314, 0.30421, 0.30528, 0.30634, 0.30741, 0.30848, 0.30955, 0.31052, 0.31151, 0.3125, 0.31348, 0.31448, 0.31547, 0.31646, 0.31744, 0.31843, 0.31941, 0.32028, 0.32116, 0.32203, 0.3229, 0.32377, 0.32463, 0.32549, 0.32635, 0.32721, 0.32803, 0.32909, 0.33016, 0.33123, 0.33231, 0.33338, 0.33446, 0.33554, 0.33662, 0.3377, 0.33878, 0.33974, 0.34063, 0.34152, 0.3424, 0.34329, 0.34418, 0.34507, 0.34595, 0.34684, 0.34768, 0.34866, 0.34964, 0.35061, 0.35159, 0.35256, 0.35354, 0.35452, 0.3555, 0.35648, 0.35746, 0.35844, 0.35942, 0.36064, 0.36173, 0.36282, 0.36391, 0.365, 0.36609, 0.36718, 0.36827, 0.36935, 0.37034, 0.37132, 0.37231, 0.37329, 0.37427, 0.37526, 0.37624, 0.37722, 0.37819, 0.37917, 0.38006, 0.38094, 0.38182, 0.38269, 0.38357, 0.38444, 0.38531, 0.38619, 0.38707, 0.38793, 0.38891, 0.3899, 0.39089, 0.39188, 0.39287, 0.39387, 0.39487, 0.39587, 0.39688, 0.39783, 0.39892, 0.40001, 0.40109, 0.40217, 0.40325, 0.40433, 0.4054, 0.40648, 0.40756, 0.40863, 0.40966, 0.41056, 0.41146, 0.41236, 0.41326, 0.41416, 0.41505, 0.41595, 0.41684, 0.41774, 0.41865, 0.41962, 0.42059, 0.42157, 0.42254, 0.42351, 0.42448, 0.42545, 0.42642, 0.42739, 0.42835, 0.42933, 0.4303, 0.43127, 0.43224, 0.43321, 0.43418, 0.43516, 0.43613, 0.4371, 0.43804, 0.43912, 0.44019, 0.44126, 0.44233, 0.4434, 0.44448, 0.44555, 0.44662, 0.44769, 0.44876, 0.44974, 0.4506, 0.45146, 0.45232, 0.45317, 0.45403, 0.45489, 0.45575, 0.45661, 0.45747, 0.45834, 0.45931, 0.46029, 0.46126, 0.46224, 0.46321, 0.46419, 0.46517, 0.46615, 0.46712, 0.46807, 0.46914, 0.47021, 0.47127, 0.47234, 0.4734, 0.47446, 0.47551, 0.47657, 0.47763, 0.47869, 0.47975, 0.4805, 0.48137, 0.48224, 0.48311, 0.48398, 0.48485, 0.48572, 0.4866, 0.48747, 0.48834, 0.48923, 0.49011, 0.49099, 0.49187,
                                        0.49276, 0.49364, 0.49453, 0.49541, 0.49629, 0.49722, 0.4984, 0.49958, 0.50076, 0.50194, 0.50311, 0.50429, 0.50546, 0.50664, 0.50783, 0.50901, 0.5102, 0.51078, 0.51167, 0.51256, 0.51346, 0.51436, 0.51526, 0.51616, 0.51706, 0.51795, 0.51894, 0.51994, 0.52094, 0.52195, 0.52295, 0.52395, 0.52495, 0.52595, 0.52694, 0.52794, 0.52893, 0.52992, 0.53091, 0.5319, 0.53289, 0.53387, 0.53486, 0.53584, 0.53684, 0.53783, 0.53891, 0.54002, 0.54113, 0.54225, 0.54338, 0.5445, 0.54563, 0.54676, 0.54788, 0.54906, 0.54996, 0.55086, 0.55175, 0.55264, 0.55353, 0.55441, 0.55529, 0.55618, 0.55706, 0.55795, 0.55889, 0.55989, 0.56089, 0.5619, 0.5629, 0.5639, 0.5649, 0.5659, 0.5669, 0.5679, 0.56889, 0.56989, 0.57088, 0.57187, 0.57286, 0.57384, 0.57483, 0.57582, 0.5768, 0.57778, 0.57878, 0.57977, 0.58076, 0.58176, 0.58275, 0.58374, 0.58474, 0.58573, 0.58673, 0.58772, 0.58872, 0.58971, 0.5907, 0.59169, 0.59268, 0.59368, 0.59467, 0.59567, 0.59667, 0.59767, 0.59868, 0.59968, 0.60069, 0.6017, 0.60271, 0.60373, 0.60475, 0.60577, 0.60678, 0.60779, 0.6088, 0.6098, 0.6108, 0.61179, 0.61278, 0.61377, 0.61476, 0.61575, 0.61674, 0.61773, 0.61872, 0.61973, 0.62074, 0.62174, 0.62275, 0.62376, 0.62477, 0.62578, 0.62678, 0.62779, 0.62874, 0.62963, 0.63051, 0.6314, 0.63228, 0.63316, 0.63403, 0.63491, 0.63579, 0.63654, 0.63764, 0.63874, 0.63985, 0.64095, 0.64206, 0.64317, 0.64428, 0.6454, 0.64651, 0.64763, 0.6487, 0.64972, 0.65074, 0.65175, 0.65276, 0.65377, 0.65478, 0.65579, 0.6568, 0.65781, 0.65882, 0.65983, 0.66084, 0.66185, 0.66286, 0.66387, 0.66488, 0.66589, 0.6669, 0.66791, 0.66892, 0.66991, 0.67091, 0.6719, 0.6729, 0.6739, 0.67489, 0.67588, 0.67687, 0.67786, 0.67885, 0.67985, 0.68084, 0.68184, 0.68283, 0.68383, 0.68482, 0.68582, 0.68681, 0.6878, 0.6888, 0.68989, 0.69095, 0.69201, 0.69307, 0.69413, 0.69519, 0.69624, 0.69731, 0.69837, 0.69944, 0.70018, 0.70097, 0.70177, 0.70256, 0.70336, 0.70416, 0.70496, 0.70575, 0.70635, 0.70734, 0.70834, 0.70933, 0.71032, 0.7113, 0.71229, 0.71327, 0.71425, 0.71523, 0.71622, 0.71719, 0.71829, 0.71938, 0.72048, 0.72158, 0.72268, 0.72378, 0.72489, 0.72599, 0.7271, 0.72821, 0.7292, 0.73019, 0.73118, 0.73217, 0.73316, 0.73415, 0.73514, 0.73613, 0.73712, 0.7381, 0.7391, 0.74009, 0.74108, 0.74207, 0.74306, 0.74404, 0.74503, 0.74601, 0.747, 0.74798, 0.74896, 0.7501, 0.75118, 0.75226, 0.75334, 0.75442, 0.7555, 0.75657, 0.75765, 0.75874, 0.75971, 0.76058, 0.76146, 0.76233, 0.76322, 0.7641, 0.76499, 0.76587, 0.76675, 0.76764, 0.76854, 0.76953, 0.77052, 0.7715, 0.77249, 0.77347, 0.77445, 0.77543, 0.77641, 0.77739, 0.77838, 0.77937, 0.78036, 0.78135, 0.78234, 0.78334, 0.78433, 0.78533, 0.78633, 0.78732, 0.78832, 0.7894, 0.79049, 0.79157, 0.79265, 0.79374, 0.79482, 0.7959, 0.79698, 0.79806, 0.79918, 0.80007, 0.80096, 0.80185, 0.80273, 0.80362, 0.8045, 0.80539, 0.80627, 0.80715, 0.80803, 0.80897, 0.80994, 0.81091, 0.81188, 0.81285, 0.81382, 0.81479, 0.81576, 0.81673, 0.81771, 0.81868, 0.81967, 0.82065, 0.82164, 0.82262, 0.82361, 0.8246, 0.82559, 0.82658, 0.82757, 0.82856, 0.82953, 0.83051, 0.83148, 0.83245, 0.83342, 0.83439, 0.83536, 0.83633, 0.8373, 0.83828, 0.83926, 0.84025, 0.84123, 0.84222, 0.84321, 0.8442, 0.8452, 0.84619, 0.84718, 0.84817, 0.84924, 0.85032, 0.85141, 0.85249, 0.85357, 0.85465, 0.85573, 0.85681, 0.85789, 0.85897, 0.85999, 0.86097, 0.86195, 0.86293, 0.8639, 0.86487, 0.86585, 0.86682, 0.86779, 0.86876, 0.8697, 0.87057, 0.87144, 0.87231, 0.87318, 0.87406, 0.87493, 0.8758, 0.87667, 0.87745, 0.87843, 0.8794, 0.88038, 0.88135, 0.88233, 0.88331, 0.88428, 0.88526, 0.88624, 0.88721, 0.88817, 0.88924, 0.89032, 0.89139, 0.89246, 0.89353, 0.8946, 0.89566, 0.89673, 0.8978, 0.89887, 0.89988, 0.90085, 0.90183, 0.9028, 0.90378, 0.90475, 0.90573, 0.90671, 0.90768, 0.90866, 0.9096, 0.91047, 0.91134, 0.91221, 0.91308, 0.91394, 0.91481, 0.91568, 0.91654, 0.91741, 0.91828, 0.91925, 0.92022, 0.92119, 0.92215, 0.92312, 0.92409, 0.92506, 0.92603, 0.927, 0.92797, 0.92894, 0.9299, 0.93087, 0.93184, 0.93281, 0.93378, 0.93475, 0.93571, 0.93668, 0.93765, 0.93862, 0.93958, 0.94054, 0.94151, 0.94247, 0.94343, 0.9444, 0.94536, 0.94632, 0.94729, 0.94826, 0.94924, 0.95023, 0.95122, 0.9522, 0.95319, 0.95419, 0.95518, 0.95617, 0.95716, 0.95815, 0.95922, 0.9603, 0.96138, 0.96246, 0.96355, 0.96463, 0.96571, 0.96678, 0.96786, 0.96894, 0.96988, 0.97076, 0.97164, 0.97252, 0.9734, 0.97428, 0.97516, 0.97604, 0.97692, 0.9778, 0.97872, 0.9797, 0.98068, 0.98166, 0.98264, 0.98362, 0.9846, 0.98558,
                                        0.98656, 0.98753, 0.98851, 0.98948, 0.99045, 0.99142, 0.99238, 0.99335, 0.99432, 0.99528, 0.99625, 0.99722, 0.99819, 0.99915, 1.0001, 1.0011, 1.0021, 1.003, 1.004, 1.005, 1.0059, 1.0069, 1.0078, 1.0088, 1.0098, 1.0108, 1.0117, 1.0127, 1.0137, 1.0147, 1.0156, 1.0166, 1.0175, 1.0185, 1.0196, 1.0207, 1.0217, 1.0228, 1.0238, 1.0249, 1.026, 1.027, 1.0281, 1.0292, 1.0301, 1.0311, 1.0321, 1.033, 1.034, 1.035, 1.0359, 1.0369, 1.0379, 1.0389, 1.0398, 1.0406, 1.0415, 1.0424, 1.0432, 1.0441, 1.045, 1.0458, 1.0467, 1.0475, 1.0484, 1.0495, 1.0506, 1.0516, 1.0527, 1.0538, 1.0548, 1.0559, 1.0569, 1.058, 1.0591, 1.0599, 1.0608, 1.0616, 1.0625, 1.0634, 1.0642, 1.0651, 1.066, 1.0668, 1.0677, 1.0686, 1.0696, 1.0706, 1.0716, 1.0726, 1.0735, 1.0745, 1.0755, 1.0765, 1.0774, 1.0784, 1.0794, 1.0804, 1.0814, 1.0823, 1.0833, 1.0843, 1.0853, 1.0862, 1.0872, 1.0882, 1.0893, 1.0904, 1.0914, 1.0925, 1.0936, 1.0947, 1.0958, 1.0969, 1.098, 1.099, 1.1, 1.1008, 1.1017, 1.1026, 1.1035, 1.1043, 1.1052, 1.1061, 1.107, 1.1078, 1.1088, 1.1097, 1.1107, 1.1117, 1.1127, 1.1137, 1.1146, 1.1156, 1.1166, 1.1176, 1.1186, 1.1195, 1.1205, 1.1215, 1.1225, 1.1235, 1.1244, 1.1254, 1.1264, 1.1274, 1.1284, 1.1293, 1.1303, 1.1313, 1.1323, 1.1333, 1.1343, 1.1353, 1.1362, 1.1372, 1.1382, 1.1392, 1.1402, 1.1412, 1.1422, 1.1432, 1.1442, 1.1451, 1.1461, 1.1471, 1.1481, 1.1491, 1.1501, 1.1511, 1.1521, 1.1531, 1.1541, 1.1551, 1.1561, 1.1571, 1.1581, 1.1591, 1.1601, 1.1611, 1.1621, 1.1631, 1.1641, 1.165, 1.166, 1.167, 1.168, 1.169, 1.17, 1.171, 1.172, 1.1729, 1.1739, 1.1749, 1.1759, 1.1769, 1.1779, 1.1789, 1.1799, 1.1809, 1.1819, 1.1829, 1.1839, 1.1849, 1.1859, 1.1869, 1.1879, 1.1888, 1.1898, 1.1908, 1.1918, 1.1928, 1.1938, 1.1948, 1.1958, 1.1968, 1.1977, 1.1987, 1.1997, 1.2007, 1.2017, 1.2027, 1.2037, 1.2047, 1.2057, 1.2067, 1.2076, 1.2086, 1.2096, 1.2106, 1.2116, 1.2126, 1.2136, 1.2146, 1.2156, 1.2166, 1.2175, 1.2185, 1.2195, 1.2205, 1.2215, 1.2225, 1.2235, 1.2244, 1.2254, 1.2264, 1.2274, 1.2284, 1.2294, 1.2304, 1.2314, 1.2324, 1.2334, 1.2344, 1.2354, 1.2364, 1.2374, 1.2384, 1.2394, 1.2404, 1.2413, 1.2423, 1.2433, 1.2443, 1.2453, 1.2463, 1.2473, 1.2483, 1.2493, 1.2503, 1.2513, 1.2523, 1.2533, 1.2543, 1.2553, 1.2563, 1.2573, 1.2584, 1.2595, 1.2606, 1.2617, 1.2628, 1.2639, 1.265, 1.2661, 1.2672, 1.2683, 1.2694, 1.2703, 1.2712, 1.2721, 1.273, 1.2739, 1.2748, 1.2757, 1.2766, 1.2775, 1.2784, 1.2794, 1.2805, 1.2815, 1.2825, 1.2835, 1.2845, 1.2855, 1.2866, 1.2876, 1.2886, 1.2896, 1.2906, 1.2916, 1.2926, 1.2936, 1.2946, 1.2956, 1.2966, 1.2975, 1.2985, 1.2995, 1.3005, 1.3015, 1.3026, 1.3036, 1.3046, 1.3056, 1.3066, 1.3076, 1.3086, 1.3095, 1.3105, 1.3115, 1.3125, 1.3135, 1.3144, 1.3154, 1.3164, 1.3174, 1.3183, 1.3193, 1.3203, 1.3213, 1.3222, 1.3232, 1.3242, 1.3252, 1.3261, 1.3271, 1.3281, 1.3291, 1.3301, 1.331, 1.332, 1.333, 1.334, 1.3349, 1.3359, 1.3369, 1.3379, 1.3389, 1.3399, 1.3408, 1.3418, 1.3428, 1.3438, 1.3448, 1.3458, 1.3467, 1.3477, 1.3487, 1.3497, 1.3507, 1.3517, 1.3527, 1.3536, 1.3546, 1.3556, 1.3566, 1.3576, 1.3586, 1.3597, 1.3608, 1.3618, 1.3629, 1.364, 1.3651, 1.3662, 1.3673, 1.3683, 1.3694, 1.3703, 1.3712, 1.372, 1.3729, 1.3738, 1.3747, 1.3755, 1.3764, 1.3773, 1.3782, 1.3791, 1.3801, 1.3811, 1.382, 1.383, 1.384, 1.385, 1.3859, 1.3869, 1.3879, 1.3889, 1.39, 1.3911, 1.3921, 1.3932, 1.3943, 1.3954, 1.3964, 1.3975, 1.3987, 1.3996, 1.4005, 1.4014, 1.4022, 1.4031, 1.404, 1.4048, 1.4057, 1.4066, 1.4074, 1.4083, 1.4092, 1.4102, 1.4112, 1.4121, 1.4131, 1.4141, 1.415, 1.416, 1.417, 1.4179, 1.4189, 1.4199, 1.4208, 1.4218, 1.4228, 1.4237, 1.4247, 1.4257, 1.4266, 1.4276, 1.4286, 1.4296, 1.4307, 1.4317, 1.4328, 1.4338, 1.4349, 1.4359, 1.437, 1.438, 1.4391, 1.4402, 1.4408, 1.4417, 1.4426, 1.4435, 1.4443, 1.4452, 1.4461, 1.447, 1.4478, 1.4488, 1.4498, 1.4507, 1.4517, 1.4526, 1.4536, 1.4546, 1.4555, 1.4565, 1.4575, 1.4584, 1.4594, 1.4604, 1.4614, 1.4623, 1.4633, 1.4643, 1.4653, 1.4663, 1.4672, 1.4682, 1.4692, 1.4702, 1.4711, 1.4721, 1.4731, 1.474, 1.475, 1.476,
                                        1.4769, 1.4779, 1.4788, 1.4798, 1.4808, 1.4817, 1.4827, 1.4837, 1.4846, 1.4856, 1.4866, 1.4875, 1.4885, 1.4896, 1.4907, 1.4917, 1.4928, 1.4939, 1.4949, 1.496, 1.4971, 1.4982, 1.4992, 1.5001, 1.501, 1.5018, 1.5027, 1.5036, 1.5045, 1.5053, 1.5062, 1.5071, 1.508, 1.5089, 1.5099, 1.5109, 1.5118, 1.5128, 1.5138, 1.5148, 1.5157, 1.5167, 1.5177, 1.5186, 1.5196, 1.5206, 1.5216, 1.5225, 1.5235, 1.5245, 1.5254, 1.5264, 1.5274, 1.5283, 1.5293, 1.5304, 1.5315, 1.5325, 1.5336, 1.5346, 1.5357, 1.5367, 1.5378, 1.5388, 1.5398, 1.5406, 1.5415, 1.5424, 1.5432, 1.5441, 1.545, 1.5458, 1.5467, 1.5476, 1.5485, 1.5494, 1.5504, 1.5514, 1.5523, 1.5533, 1.5542, 1.5552, 1.5561, 1.5571, 1.5581, 1.559, 1.56, 1.561, 1.5619, 1.5629, 1.5639, 1.5649, 1.5658, 1.5668, 1.5678, 1.5687, 1.5697, 1.5707, 1.5717, 1.5726, 1.5736, 1.5746, 1.5756, 1.5765, 1.5775, 1.5785, 1.5793, 1.5802, 1.5811, 1.5819, 1.5828, 1.5836, 1.5845, 1.5854, 1.5862, 1.5871, 1.5881, 1.5892, 1.5903, 1.5913, 1.5924, 1.5935, 1.5945, 1.5956, 1.5967, 1.5977, 1.5988, 1.5997, 1.6007, 1.6016, 1.6026, 1.6036, 1.6045, 1.6055, 1.6064, 1.6074, 1.6084, 1.6093, 1.6103, 1.6113, 1.6122, 1.6132, 1.6142, 1.6151, 1.6161, 1.6171, 1.6181, 1.619, 1.62, 1.621, 1.622, 1.6229, 1.6239, 1.6249, 1.6259, 1.6269, 1.6278, 1.6288, 1.6298, 1.6307, 1.6317, 1.6327, 1.6336, 1.6346, 1.6356, 1.6365, 1.6375, 1.6385, 1.6394, 1.6404, 1.6414, 1.6423, 1.6433, 1.6442, 1.6452, 1.6462, 1.6471, 1.6481, 1.649, 1.6499, 1.6507, 1.6516, 1.6525, 1.6533, 1.6542, 1.655, 1.6559, 1.6568, 1.6576, 1.6588, 1.6599, 1.661, 1.6621, 1.6633, 1.6644, 1.6655, 1.6666, 1.6678, 1.6689, 1.6699, 1.6707, 1.6716, 1.6724, 1.6733, 1.6741, 1.675, 1.6758, 1.6767, 1.6776, 1.6784, 1.6794, 1.6803, 1.6812, 1.6822, 1.6831, 1.6841, 1.685, 1.686, 1.6869, 1.6878, 1.6888, 1.6897, 1.6907, 1.6916, 1.6926, 1.6935, 1.6945, 1.6954, 1.6964, 1.6974, 1.6983, 1.6994, 1.7004, 1.7015, 1.7025, 1.7036, 1.7046, 1.7057, 1.7067, 1.7078, 1.7088, 1.7097, 1.7106, 1.7114, 1.7123, 1.7131, 1.714, 1.7148, 1.7157, 1.7165, 1.7174, 1.7183, 1.7192, 1.7202, 1.7212, 1.7221, 1.7231, 1.7241, 1.725, 1.726, 1.727, 1.7279, 1.7289, 1.7299, 1.7308, 1.7318, 1.7327, 1.7337, 1.7347, 1.7356, 1.7366, 1.7375, 1.7385, 1.7394, 1.7404, 1.7414, 1.7423, 1.7433, 1.7443, 1.7452, 1.7462, 1.7471, 1.7481, 1.7491, 1.75, 1.751, 1.7519, 1.7529, 1.7539, 1.7548, 1.7558, 1.7567, 1.7577, 1.7587, 1.7596, 1.7606, 1.7616, 1.7625, 1.7635, 1.7644, 1.7654, 1.7664, 1.7673, 1.7683, 1.7692, 1.7702, 1.7712, 1.7721, 1.7731, 1.774, 1.775, 1.7759, 1.7769, 1.7778, 1.7788, 1.7797, 1.7807, 1.7817, 1.7826, 1.7836, 1.7845, 1.7855, 1.7865, 1.7874, 1.7884, 1.7893, 1.7903, 1.7912, 1.7922, 1.7931, 1.7941, 1.795, 1.796, 1.7969, 1.7979, 1.7988, 1.7998, 1.8007, 1.8017, 1.8027, 1.8036, 1.8046, 1.8056, 1.8065, 1.8075, 1.8085, 1.8094, 1.8104, 1.8114, 1.8123, 1.8133, 1.8142, 1.8152, 1.8162, 1.8171, 1.8181, 1.8191, 1.82, 1.821, 1.822, 1.8229, 1.8239, 1.8248, 1.8258, 1.8268, 1.8277, 1.8287, 1.8297, 1.8306, 1.8316, 1.8326, 1.8336, 1.8345, 1.8355, 1.8365, 1.8375, 1.8384, 1.8394, 1.8404, 1.8413, 1.8423, 1.8433, 1.8442, 1.8452, 1.8462, 1.8471, 1.8481, 1.8491, 1.85, 1.851, 1.8519, 1.8529, 1.8539, 1.8549, 1.8558, 1.8568, 1.8577, 1.8587, 1.8597, 1.8606, 1.8616, 1.8626, 1.8635, 1.8645, 1.8655, 1.8664, 1.8674, 1.8683, 1.8693, 1.8703, 1.8712, 1.8722, 1.8731, 1.8741, 1.8751, 1.876, 1.877, 1.8779, 1.8789, 1.8799, 1.8808, 1.8818, 1.8827, 1.8837, 1.8847, 1.8856, 1.8866, 1.8876, 1.8885, 1.8895, 1.8905, 1.8914, 1.8924, 1.8934, 1.8944, 1.8953, 1.8963, 1.8973, 1.8982, 1.8992, 1.9002, 1.9011, 1.9021, 1.903, 1.904, 1.9049, 1.9059, 1.9068, 1.9078, 1.9087, 1.9097, 1.9107, 1.9116, 1.9126, 1.9135, 1.9145, 1.9155, 1.9164, 1.9174, 1.9183, 1.9193, 1.9202, 1.9212, 1.9221, 1.9231, 1.924, 1.925, 1.9259, 1.9269, 1.9278, 1.9288, 1.9298, 1.9307, 1.9317, 1.9327, 1.9336, 1.9346, 1.9356, 1.9366, 1.9376, 1.9385, 1.9395, 1.9405, 1.9414, 1.9424, 1.9433, 1.9443, 1.9453, 1.9462, 1.9472, 1.9482, 1.9491, 1.9501, 1.9511, 1.9521, 1.9531, 1.9541, 1.9551, 1.9561, 1.9571,
                                        1.958, 1.959, 1.96, 1.961, 1.962, 1.9629, 1.9639, 1.9649, 1.9658, 1.9668, 1.9678, 1.9688, 1.9697, 1.9707, 1.9717, 1.9727, 1.9737, 1.9747, 1.9756, 1.9766, 1.9776, 1.9786, 1.9796, 1.9805, 1.9815, 1.9825, 1.9835, 1.9845, 1.9854, 1.9864, 1.9874, 1.9884, 1.9894, 1.9904, 1.9915, 1.9925, 1.9935, 1.9945, 1.9955, 1.9966, 1.9976, 1.9986, 1.9996, 2.0006, 2.0016, 2.0025, 2.0035, 2.0045, 2.0055, 2.0065, 2.0075, 2.0085, 2.0096, 2.0108, 2.0119, 2.013, 2.0141, 2.0153, 2.0164, 2.0175, 2.0186, 2.0197, 2.0205, 2.0214, 2.0223, 2.0232, 2.0241, 2.0249, 2.0258, 2.0266, 2.0275, 2.0284, 2.0293, 2.0303, 2.0313, 2.0323, 2.0332, 2.0342, 2.0352, 2.0362, 2.0372, 2.0381, 2.0391, 2.0401, 2.0411, 2.0421, 2.0431, 2.0441, 2.0451, 2.0461, 2.0471, 2.0481, 2.0491, 2.05, 2.051, 2.052, 2.053, 2.054, 2.055, 2.0559, 2.0569, 2.0579, 2.0589, 2.0599, 2.0609, 2.0619, 2.063, 2.064, 2.065, 2.066, 2.067, 2.068, 2.069, 2.0701, 2.0712, 2.0723, 2.0734, 2.0745, 2.0755, 2.0766, 2.0777, 2.0788, 2.0798, 2.0806, 2.0815, 2.0823, 2.0832, 2.0841, 2.0849, 2.0858, 2.0867, 2.0875, 2.0884, 2.0894, 2.0903, 2.0913, 2.0923, 2.0933, 2.0942, 2.0952, 2.0962, 2.0972, 2.0981, 2.0991, 2.1001, 2.1011, 2.102, 2.103, 2.104, 2.105, 2.1059, 2.1069, 2.1079, 2.1089, 2.1099, 2.1109, 2.1119, 2.1129, 2.1139, 2.1149, 2.1159, 2.1169, 2.1179, 2.1189, 2.1199, 2.1209, 2.1219, 2.1229, 2.124, 2.125, 2.126, 2.127, 2.128, 2.129, 2.13, 2.131, 2.1319, 2.1329, 2.1339, 2.1349, 2.1359, 2.1369, 2.1379, 2.1389, 2.1398, 2.1408, 2.1418, 2.1428, 2.1439, 2.1449, 2.1459, 2.1469, 2.1479, 2.1489, 2.1499, 2.1508, 2.1518, 2.1528, 2.1538, 2.1548, 2.1557, 2.1567, 2.1577, 2.1588, 2.1599, 2.161, 2.1621, 2.1632, 2.1643, 2.1654, 2.1665, 2.1676, 2.1687, 2.1698, 2.1708, 2.1718, 2.1728, 2.1738, 2.1748, 2.1758, 2.1768, 2.1778, 2.1788, 2.1798, 2.1807, 2.1816, 2.1825, 2.1834, 2.1843, 2.1852, 2.1861, 2.187, 2.1879, 2.1889, 2.1898, 2.1908, 2.1918, 2.1928, 2.1938, 2.1948, 2.1957, 2.1967, 2.1977, 2.1987, 2.1997, 2.2006, 2.2016, 2.2026, 2.2036, 2.2046, 2.2055, 2.2065, 2.2075, 2.2085, 2.2095, 2.2104, 2.2114, 2.2124, 2.2134, 2.2144, 2.2154, 2.2164, 2.2174, 2.2184, 2.2193, 2.2203, 2.2213, 2.2222, 2.2232, 2.2242, 2.2251, 2.2261, 2.2271, 2.228, 2.229, 2.23, 2.231, 2.232, 2.233, 2.234, 2.235, 2.236, 2.237, 2.238, 2.239, 2.2401, 2.2412, 2.2423, 2.2434, 2.2444, 2.2455, 2.2466, 2.2477, 2.2487, 2.2498, 2.2506, 2.2515, 2.2524, 2.2533, 2.2542, 2.2551, 2.256, 2.2569, 2.2578, 2.2587, 2.2597, 2.2607, 2.2617, 2.2627, 2.2636, 2.2646, 2.2656, 2.2666, 2.2676, 2.2686, 2.2696, 2.2706, 2.2716, 2.2726, 2.2736, 2.2746, 2.2756, 2.2766, 2.2776, 2.2786, 2.2796, 2.2806, 2.2816, 2.2826, 2.2836, 2.2846, 2.2856, 2.2866, 2.2876, 2.2886, 2.2896, 2.2906, 2.2916, 2.2926, 2.2936, 2.2946, 2.2956, 2.2966, 2.2975, 2.2985, 2.2995, 2.3005, 2.3015, 2.3025, 2.3034, 2.3044, 2.3054, 2.3064, 2.3073, 2.3083, 2.3094, 2.3105, 2.3116, 2.3126, 2.3137, 2.3148, 2.3159, 2.317, 2.3181, 2.3192, 2.3201, 2.321, 2.3219, 2.3227, 2.3236, 2.3245, 2.3254, 2.3263, 2.3272, 2.328, 2.329, 2.33, 2.331, 2.332, 2.333, 2.3339, 2.3349, 2.3359, 2.3369, 2.3379, 2.3388, 2.3398, 2.3408, 2.3418, 2.3428, 2.3438, 2.3447, 2.3457, 2.3467, 2.3477, 2.3487, 2.3497, 2.3506, 2.3516, 2.3526, 2.3536, 2.3546, 2.3556, 2.3566, 2.3575, 2.3586, 2.3596, 2.3607, 2.3618, 2.3628, 2.3639, 2.365, 2.3661, 2.3671, 2.3682, 2.3693, 2.3702, 2.3711, 2.372, 2.3729, 2.3737, 2.3746, 2.3755, 2.3764, 2.3773, 2.3781, 2.3792, 2.3803, 2.3814, 2.3825, 2.3835, 2.3846, 2.3857, 2.3868, 2.3879, 2.3889, 2.3899, 2.3908, 2.3917, 2.3925, 2.3934, 2.3943, 2.3952, 2.396, 2.3969, 2.3978, 2.3987, 2.3997, 2.4007, 2.4017, 2.4026, 2.4036, 2.4046, 2.4056, 2.4066, 2.4075, 2.4085, 2.4096, 2.4107, 2.4118, 2.4128, 2.4139, 2.415, 2.416, 2.4171, 2.4182, 2.4192, 2.4201, 2.421, 2.4219, 2.4228, 2.4236, 2.4245, 2.4254, 2.4263, 2.4272, 2.4281, 2.4291, 2.4302, 2.4313, 2.4323, 2.4334, 2.4345, 2.4356, 2.4366, 2.4377, 2.4388, 2.4397, 2.4406, 2.4415, 2.4424, 2.4433, 2.4442, 2.4451, 2.446, 2.4469, 2.4478, 2.4488, 2.4497, 2.4507,
                                        2.4517, 2.4527, 2.4537, 2.4546, 2.4556, 2.4566, 2.4576, 2.4586, 2.4596, 2.4606, 2.4616, 2.4626, 2.4636, 2.4646, 2.4656, 2.4666, 2.4676, 2.4686, 2.4696, 2.4706, 2.4716, 2.4726, 2.4736, 2.4746, 2.4756, 2.4766, 2.4776, 2.4786, 2.4796, 2.4806, 2.4816, 2.4826, 2.4836, 2.4846, 2.4856, 2.4866, 2.4876, 2.4886, 2.4895, 2.4905, 2.4915, 2.4925, 2.4935, 2.4945, 2.4955, 2.4965, 2.4975, 2.4985, 2.4995, 2.5005, 2.5015, 2.5025, 2.5035, 2.5045, 2.5055, 2.5064, 2.5074, 2.5084, 2.5094, 2.5104, 2.5114, 2.5123, 2.5133, 2.5143, 2.5153, 2.5162, 2.5172, 2.5182, 2.5192, 2.5202, 2.5212, 2.5221, 2.5231, 2.5241, 2.5251, 2.5261, 2.5271, 2.528, 2.5291, 2.5301, 2.5312, 2.5323, 2.5333, 2.5344, 2.5354, 2.5365, 2.5375, 2.5386, 2.5396, 2.5405, 2.5414, 2.5423, 2.5432, 2.544, 2.5449, 2.5458, 2.5467, 2.5476, 2.5485, 2.5496, 2.5507, 2.5517, 2.5528, 2.5538, 2.5549, 2.5559, 2.557, 2.558, 2.5591, 2.56, 2.5609, 2.5618, 2.5627, 2.5635, 2.5644, 2.5653, 2.5662, 2.5671, 2.5679, 2.5689, 2.5698, 2.5708, 2.5717, 2.5727, 2.5736, 2.5746, 2.5755, 2.5765, 2.5775, 2.5784, 2.5794, 2.5804, 2.5813, 2.5823, 2.5833, 2.5843, 2.5853, 2.5862, 2.5872, 2.5882, 2.5892, 2.5902, 2.5911, 2.5921, 2.5931, 2.5941, 2.5951, 2.596, 2.597, 2.598, 2.5989, 2.5999, 2.6009, 2.6019, 2.6028, 2.6038, 2.6048, 2.6058, 2.6068, 2.6077, 2.6087, 2.6097, 2.6107, 2.6117, 2.6127, 2.6137, 2.6146, 2.6156, 2.6166, 2.6176, 2.6186, 2.6197, 2.6207, 2.6218, 2.6229, 2.624, 2.625, 2.6261, 2.6272, 2.6282, 2.6293, 2.6303, 2.631, 2.6319, 2.6328, 2.6336, 2.6345, 2.6353, 2.6362, 2.6371, 2.6379, 2.6389, 2.6398, 2.6408, 2.6418, 2.6427, 2.6437, 2.6447, 2.6457, 2.6466, 2.6475, 2.6486, 2.6497, 2.6507, 2.6518, 2.6528, 2.6539, 2.6549, 2.656, 2.657, 2.6581, 2.6591, 2.6601, 2.6609, 2.6618, 2.6627, 2.6636, 2.6645, 2.6653, 2.6662, 2.6671, 2.668, 2.669, 2.67, 2.6711, 2.6721, 2.6732, 2.6743, 2.6753, 2.6764, 2.6774, 2.6785, 2.6795, 2.6803, 2.6812, 2.6821, 2.6829, 2.6838, 2.6846, 2.6855, 2.6864, 2.6872, 2.6881, 2.689, 2.69, 2.691, 2.6919, 2.6929, 2.6939, 2.6948, 2.6958, 2.6968, 2.6978, 2.6987, 2.6997, 2.7006, 2.7016, 2.7026, 2.7035, 2.7045, 2.7055, 2.7064, 2.7074, 2.7083, 2.7093, 2.7103, 2.7113, 2.7122, 2.7132, 2.7142, 2.7152, 2.7161, 2.7171, 2.7181, 2.7191, 2.72, 2.721, 2.722, 2.723, 2.7239, 2.7249, 2.7259, 2.7268, 2.7278, 2.7288, 2.7297, 2.7307, 2.7317, 2.7326, 2.7336, 2.7346, 2.7355, 2.7365, 2.7375, 2.7384, 2.7394, 2.7403, 2.7413, 2.7423, 2.7432, 2.7442, 2.7452, 2.7461, 2.7471, 2.7481, 2.749, 2.75, 2.751, 2.7519, 2.7529, 2.7539, 2.7549, 2.7558, 2.7568, 2.7578, 2.7587, 2.7597, 2.7607, 2.7616, 2.7626, 2.7635, 2.7645, 2.7655, 2.7664, 2.7674, 2.7683, 2.7693, 2.7703, 2.7712, 2.7722, 2.7732, 2.7741, 2.7751, 2.7761, 2.777, 2.778, 2.779, 2.7799, 2.7809, 2.7819, 2.7828, 2.7838, 2.7847, 2.7857, 2.7867, 2.7876, 2.7886, 2.7895, 2.7905, 2.7915, 2.7924, 2.7934, 2.7943, 2.7953, 2.7962, 2.7972, 2.7981, 2.7992, 2.8002, 2.8013, 2.8023, 2.8034, 2.8045, 2.8055, 2.8066, 2.8076, 2.8088, 2.8097, 2.8105, 2.8114, 2.8123, 2.8131, 2.814, 2.8148, 2.8157, 2.8166, 2.8174, 2.8182, 2.8193, 2.8203, 2.8214, 2.8224, 2.8235, 2.8246, 2.8256, 2.8267, 2.8277, 2.8288, 2.8297, 2.8306, 2.8315, 2.8323, 2.8332, 2.834, 2.8349, 2.8357, 2.8366, 2.8374, 2.8383, 2.8392, 2.8402, 2.8411, 2.8421, 2.843, 2.844, 2.8449, 2.8459, 2.8468, 2.8478, 2.8487, 2.8497, 2.8506, 2.8516, 2.8525, 2.8535, 2.8544, 2.8554, 2.8563, 2.8573, 2.8582, 2.8592, 2.8601, 2.8611, 2.8621, 2.863, 2.864, 2.8649, 2.8659, 2.8668, 2.8678, 2.8687, 2.8697, 2.8706, 2.8716, 2.8725, 2.8735, 2.8744, 2.8753, 2.8763, 2.8772, 2.8782, 2.8791, 2.8801, 2.881, 2.882, 2.8829, 2.8839, 2.8848, 2.8858, 2.8868, 2.8877, 2.8887, 2.8896, 2.8906, 2.8915, 2.8925, 2.8934, 2.8944, 2.8954, 2.8963, 2.8973, 2.8982, 2.8993, 2.9004, 2.9014, 2.9025, 2.9035, 2.9046, 2.9057, 2.9067, 2.9078, 2.9089, 2.9098, 2.9107, 2.9115, 2.9124, 2.9133, 2.9141, 2.915, 2.9159, 2.9167, 2.9176, 2.9185, 2.9195, 2.9204, 2.9214, 2.9224, 2.9234, 2.9243, 2.9253, 2.9263, 2.9272, 2.9282, 2.9293, 2.9303, 2.9314, 2.9324, 2.9335, 2.9346, 2.9356,
                                        2.9367, 2.9377, 2.9388, 2.9398, 2.9408, 2.9418, 2.9427, 2.9437, 2.9447, 2.9457, 2.9467, 2.9477, 2.9486, 2.9496, 2.9505, 2.9513, 2.9522, 2.9531, 2.954, 2.9548, 2.9557, 2.9566, 2.9575, 2.9583, 2.9593, 2.9603, 2.9613, 2.9623, 2.9633, 2.9643, 2.9652, 2.9662, 2.9672, 2.9682, 2.9693, 2.9703, 2.9714, 2.9725, 2.9736, 2.9746, 2.9757, 2.9768, 2.9778, 2.979, 2.9799, 2.9809, 2.9819, 2.9829, 2.9838, 2.9848, 2.9858, 2.9867, 2.9877, 2.9887, 2.9897, 2.9905, 2.9914, 2.9923, 2.9931, 2.994, 2.9949, 2.9957, 2.9966, 2.9975, 2.9983, 2.9993, 3.0002, 3.0012, 3.0022, 3.0031, 3.0041, 3.005, 3.006, 3.007, 3.0079, 3.0089, 3.0098, 3.0108, 3.0117, 3.0127, 3.0137, 3.0146, 3.0156, 3.0165, 3.0175, 3.0185, 3.0194, 3.0204, 3.0214, 3.0223, 3.0233, 3.0243, 3.0253, 3.0262, 3.0272, 3.0282, 3.0291, 3.0301, 3.0311, 3.032, 3.033, 3.0339, 3.0349, 3.0358, 3.0368, 3.0377, 3.0387, 3.0397, 3.0406, 3.0416, 3.0426, 3.0435, 3.0445, 3.0455, 3.0465, 3.0474, 3.0484, 3.0494, 3.0503, 3.0513, 3.0523, 3.0532, 3.0542, 3.0552, 3.0561, 3.0571, 3.0581, 3.059, 3.06, 3.061, 3.062, 3.063, 3.064, 3.0649, 3.0659, 3.0669, 3.0679, 3.0689, 3.0699, 3.0709, 3.0719, 3.0729, 3.0739, 3.0749, 3.0759, 3.0769, 3.0778, 3.0788, 3.0798, 3.0808, 3.0818, 3.0828, 3.0838, 3.0848, 3.0858, 3.0868, 3.0878, 3.0888, 3.0898, 3.0908, 3.0918, 3.0928, 3.0938, 3.0948, 3.0957, 3.0967, 3.0977, 3.0987, 3.0997, 3.1007, 3.1017, 3.1026, 3.1036, 3.1046, 3.1056, 3.1066, 3.1075, 3.1085, 3.1095, 3.1105, 3.1115, 3.1124, 3.1134, 3.1144, 3.1154, 3.1164, 3.1173, 3.1183, 3.1193, 3.1203, 3.1213, 3.1222, 3.1232, 3.1242, 3.1252, 3.1261, 3.1271, 3.1281, 3.1291, 3.1301, 3.131, 3.132, 3.133, 3.134, 3.135, 3.136, 3.1369, 3.1379, 3.1389, 3.14, 3.1411, 3.1422, 3.1432, 3.1443, 3.1454, 3.1464, 3.1475, 3.1486, 3.1496, 3.1505, 3.1513, 3.1522, 3.1531, 3.1539, 3.1548, 3.1557, 3.1566, 3.1574, 3.1583, 3.1593, 3.1603, 3.1612, 3.1622, 3.1632, 3.1641, 3.1651, 3.1661, 3.167, 3.168, 3.1691, 3.1701, 3.1712, 3.1723, 3.1734, 3.1744, 3.1755, 3.1766, 3.1776, 3.1787, 3.1797, 3.1806, 3.1814, 3.1823, 3.1832, 3.1841, 3.185, 3.1858, 3.1867, 3.1876, 3.1885, 3.1895, 3.1905, 3.1915, 3.1924, 3.1934, 3.1944, 3.1954, 3.1964, 3.1974, 3.1983, 3.1993, 3.2003, 3.2013, 3.2023, 3.2033, 3.2042, 3.2052, 3.2062, 3.2072, 3.2082, 3.2092, 3.2101, 3.2111, 3.2121, 3.2131, 3.2141, 3.2151, 3.2161, 3.2171, 3.2181, 3.219, 3.22, 3.221, 3.222, 3.223, 3.224, 3.225, 3.2259, 3.2269, 3.2279, 3.2289, 3.2299, 3.2309, 3.2319, 3.2329, 3.2338, 3.2348, 3.2358, 3.2368, 3.2378, 3.2388, 3.2397, 3.2407, 3.2417, 3.2427, 3.2436, 3.2446, 3.2456, 3.2466, 3.2475, 3.2485, 3.2495, 3.2505, 3.2515, 3.2525, 3.2534, 3.2544, 3.2554, 3.2564, 3.2574, 3.2584, 3.2593, 3.2603, 3.2613, 3.2623, 3.2633, 3.2642, 3.2652, 3.2662, 3.2672, 3.2682, 3.2692, 3.2701, 3.2711, 3.2721, 3.2731, 3.2741, 3.2751, 3.2761, 3.2771, 3.2781, 3.2792, 3.2802, 3.2813, 3.2824, 3.2835, 3.2846, 3.2857, 3.2868, 3.2879, 3.289, 3.2899, 3.2908, 3.2917, 3.2926, 3.2935, 3.2944, 3.2953, 3.2961, 3.297, 3.2979, 3.2989, 3.2999, 3.3008, 3.3018, 3.3028, 3.3038, 3.3048, 3.3058, 3.3068, 3.3077, 3.3088, 3.3099, 3.3109, 3.312, 3.3131, 3.3142, 3.3153, 3.3164, 3.3174, 3.3185, 3.3195, 3.3204, 3.3213, 3.3222, 3.3231, 3.324, 3.3249, 3.3258, 3.3266, 3.3275, 3.3284, 3.3294, 3.3304, 3.3313, 3.3323, 3.3333, 3.3343, 3.3353, 3.3363, 3.3372, 3.3382, 3.3393, 3.3404, 3.3415, 3.3426, 3.3437, 3.3448, 3.3459, 3.347, 3.3481, 3.3492, 3.3501, 3.351, 3.3519, 3.3527, 3.3536, 3.3545, 3.3554, 3.3563, 3.3572, 3.3581, 3.3592, 3.3602, 3.3613, 3.3624, 3.3635, 3.3646, 3.3657, 3.3668, 3.3679, 3.369, 3.3701, 3.3708, 3.3717, 3.3726, 3.3735, 3.3744, 3.3753, 3.3761, 3.377, 3.3779, 3.3789, 3.38, 3.3811, 3.3822, 3.3833, 3.3844, 3.3854, 3.3865, 3.3876, 3.3887, 3.3897, 3.3906, 3.3915, 3.3923, 3.3932, 3.3941, 3.395, 3.3959, 3.3968, 3.3977, 3.3987, 3.3997, 3.4007, 3.4017, 3.4027, 3.4037, 3.4047, 3.4057, 3.4067, 3.4076, 3.4086, 3.4097, 3.4107, 3.4117, 3.4127, 3.4137, 3.4147, 3.4157, 3.4167, 3.4177, 3.4187, 3.4197, 3.4207, 3.4217, 3.4227, 3.4237, 3.4247, 3.4257,
                                        3.4267, 3.4277, 3.4287, 3.4297, 3.4307, 3.4316, 3.4326, 3.4336, 3.4346, 3.4356, 3.4366, 3.4376, 3.4386, 3.4396, 3.4406, 3.4416, 3.4426, 3.4436, 3.4446, 3.4456, 3.4466, 3.4476, 3.4486, 3.4496, 3.4506, 3.4516, 3.4526, 3.4535, 3.4545, 3.4555, 3.4565, 3.4575, 3.4585, 3.4595, 3.4605, 3.4615, 3.4625, 3.4635, 3.4645, 3.4655, 3.4665, 3.4675, 3.4685, 3.4695, 3.4705, 3.4715, 3.4725, 3.4735, 3.4745, 3.4755, 3.4765, 3.4775, 3.4785, 3.4795, 3.4805, 3.4815, 3.4825, 3.4835, 3.4845, 3.4855, 3.4865, 3.4875, 3.4885, 3.4894, 3.4904, 3.4914, 3.4924, 3.4934, 3.4944, 3.4954, 3.4964, 3.4974, 3.4984, 3.4994, 3.5004, 3.5014, 3.5024, 3.5034, 3.5044, 3.5055, 3.5065, 3.5075, 3.5084, 3.5095, 3.5105, 3.5115, 3.5125, 3.5135, 3.5145, 3.5154, 3.5164, 3.5174, 3.5184, 3.5194, 3.5204, 3.5214, 3.5223, 3.5233, 3.5243, 3.5253, 3.5263, 3.5272, 3.5282, 3.5292, 3.5302, 3.5312, 3.5322, 3.5332, 3.5342, 3.5351, 3.5361, 3.5371, 3.5381, 3.5391, 3.5401, 3.541, 3.542, 3.543, 3.5439, 3.5449, 3.5459, 3.5468, 3.5478, 3.5488, 3.5499, 3.551, 3.5521, 3.5532, 3.5543, 3.5554, 3.5564, 3.5575, 3.5586, 3.5596, 3.5605, 3.5614, 3.5623, 3.5632, 3.5641, 3.565, 3.5658, 3.5667, 3.5675, 3.5685, 3.5695, 3.5705, 3.5715, 3.5725, 3.5735, 3.5745, 3.5755, 3.5765, 3.5775, 3.5785, 3.5796, 3.5807, 3.5818, 3.5829, 3.584, 3.5851, 3.5862, 3.5873, 3.5884, 3.5895, 3.5903, 3.5912, 3.5921, 3.593, 3.5939, 3.5948, 3.5957, 3.5965, 3.5974, 3.5983, 3.5993, 3.6003, 3.6013, 3.6023, 3.6033, 3.6042, 3.6052, 3.6062, 3.6072, 3.6082, 3.6092, 3.6102, 3.6112, 3.6121, 3.6131, 3.6141, 3.6151, 3.6161, 3.6171, 3.6181, 3.6191, 3.6202, 3.6213, 3.6224, 3.6235, 3.6245, 3.6256, 3.6267, 3.6278, 3.629, 3.6299, 3.6308, 3.6316, 3.6325, 3.6334, 3.6343, 3.6352, 3.6361, 3.637, 3.6379, 3.6388, 3.6398, 3.6407, 3.6417, 3.6427, 3.6437, 3.6446, 3.6456, 3.6466, 3.6476, 3.6485, 3.6495, 3.6505, 3.6515, 3.6525, 3.6535, 3.6544, 3.6554, 3.6564, 3.6574, 3.6584, 3.6594, 3.6603, 3.6613, 3.6623, 3.6632, 3.6642, 3.6652, 3.6662, 3.6671, 3.6681, 3.6691, 3.67, 3.671, 3.672, 3.6729, 3.6739, 3.6749, 3.6759, 3.6768, 3.6778, 3.6788, 3.6799, 3.681, 3.6821, 3.6832, 3.6842, 3.6853, 3.6864, 3.6875, 3.6886, 3.6896, 3.6905, 3.6914, 3.6922, 3.6931, 3.694, 3.6949, 3.6957, 3.6966, 3.6975, 3.6983, 3.6993, 3.7003, 3.7013, 3.7022, 3.7032, 3.7042, 3.7052, 3.7062, 3.7071, 3.7081, 3.7091, 3.7101, 3.7111, 3.7121, 3.7131, 3.7141, 3.7151, 3.716, 3.717, 3.718, 3.719, 3.7201, 3.7212, 3.7223, 3.7234, 3.7244, 3.7255, 3.7266, 3.7276, 3.7287, 3.7298, 3.7306, 3.7314, 3.7323, 3.7332, 3.7341, 3.7349, 3.7358, 3.7367, 3.7376, 3.7385, 3.7395, 3.7404, 3.7414, 3.7423, 3.7433, 3.7443, 3.7452, 3.7462, 3.7472, 3.7481, 3.7491, 3.7501, 3.7511, 3.752, 3.753, 3.754, 3.755, 3.756, 3.7569, 3.7579, 3.7589, 3.76, 3.7611, 3.7622, 3.7632, 3.7643, 3.7654, 3.7665, 3.7675, 3.7686, 3.7696, 3.7705, 3.7714, 3.7722, 3.7731, 3.774, 3.7749, 3.7758, 3.7767, 3.7776, 3.7784, 3.7794, 3.7804, 3.7814, 3.7824, 3.7834, 3.7843, 3.7853, 3.7863, 3.7873, 3.7882, 3.7892, 3.7902, 3.7912, 3.7922, 3.7932, 3.7941, 3.7951, 3.7961, 3.7971, 3.7981, 3.7991, 3.8001, 3.8011, 3.802, 3.803, 3.804, 3.805, 3.806, 3.8069, 3.8079, 3.8089, 3.8099, 3.8109, 3.8119, 3.8129, 3.8139, 3.8149, 3.8159, 3.8169, 3.8179, 3.8189, 3.8201, 3.8212, 3.8222, 3.8233, 3.8244, 3.8255, 3.8266, 3.8277, 3.8288, 3.8299, 3.8307, 3.8316, 3.8325, 3.8334, 3.8343, 3.8352, 3.8361, 3.837, 3.8379, 3.8388, 3.8398, 3.8408, 3.8418, 3.8427, 3.8437, 3.8447, 3.8457, 3.8466, 3.8476, 3.8486, 3.8496, 3.8506, 3.8516, 3.8526, 3.8536, 3.8546, 3.8556, 3.8566, 3.8576, 3.8587, 3.8598, 3.8608, 3.8619, 3.863, 3.8641, 3.8651, 3.8662, 3.8673, 3.8684, 3.8694, 3.8703, 3.8712, 3.8721, 3.873, 3.8738, 3.8747, 3.8756, 3.8765, 3.8774, 3.8783, 3.8793, 3.8803, 3.8813, 3.8823, 3.8832, 3.8842, 3.8852, 3.8862, 3.8872, 3.8882, 3.8892, 3.8902, 3.8912, 3.8921, 3.8931, 3.8941, 3.8951, 3.8961, 3.8971, 3.8981, 3.8991, 3.9002, 3.9013, 3.9024, 3.9035, 3.9046, 3.9057, 3.9067, 3.9078, 3.9089, 3.9098, 3.9107, 3.9116, 3.9126, 3.9135, 3.9144, 3.9153, 3.9162, 3.9171, 3.9179, 3.9189,
                                        3.9199, 3.9209, 3.9219, 3.9229, 3.9239, 3.9248, 3.9258, 3.9268, 3.9278, 3.9289, 3.93, 3.9311, 3.9322, 3.9333, 3.9344, 3.9355, 3.9366, 3.9378, 3.9389, 3.9398, 3.9408, 3.9417, 3.9426, 3.9435, 3.9444, 3.9453, 3.9462, 3.9471, 3.948, 3.9491, 3.9501, 3.9511, 3.9521, 3.9531, 3.9541, 3.9551, 3.9561, 3.9572, 3.9582, 3.9592, 3.9604, 3.9616, 3.9627, 3.9639, 3.965, 3.9662, 3.9673, 3.9684, 3.9695, 3.9706, 3.9716, 3.9726, 3.9736, 3.9746, 3.9756, 3.9766, 3.9776, 3.9786, 3.9796, 3.9805, 3.9814, 3.9823, 3.9832, 3.9841, 3.985, 3.9859, 3.9868, 3.9877, 3.9886, 3.9896, 3.9907, 3.9917, 3.9927, 3.9937, 3.9947, 3.9957, 3.9967, 3.9977, 3.9987, 3.9997, 4.0007, 4.0017, 4.0027, 4.0036, 4.0046, 4.0056, 4.0065, 4.0075, 4.0085, 4.0095, 4.0105, 4.0115, 4.0125, 4.0135, 4.0145, 4.0155, 4.0166, 4.0176, 4.0186, 4.0196, 4.0207, 4.0217, 4.0227, 4.0237, 4.0248, 4.0258, 4.0268, 4.0278, 4.0289, 4.0299, 4.0309, 4.0319, 4.0329, 4.0339, 4.0349, 4.036, 4.037, 4.038, 4.039, 4.0401, 4.0411, 4.0422, 4.0432, 4.0443, 4.0453, 4.0464, 4.0474, 4.0484, 4.0495, 4.0506, 4.0517, 4.0528, 4.0538, 4.0549, 4.056, 4.0571, 4.0581, 4.0592, 4.0601, 4.061, 4.0619, 4.0628, 4.0637, 4.0647, 4.0656, 4.0665, 4.0674, 4.0683, 4.0692, 4.0702, 4.0712, 4.0722, 4.0732, 4.0742, 4.0752, 4.0761, 4.0771, 4.0781, 4.0791, 4.0801, 4.0812, 4.0822, 4.0832, 4.0842, 4.0852, 4.0862, 4.0872, 4.0882, 4.0892, 4.0902, 4.0912, 4.0922, 4.0932, 4.0942, 4.0952, 4.0962, 4.0972, 4.0981, 4.0991, 4.1001, 4.1011, 4.1021, 4.1031, 4.1041, 4.1051, 4.1061, 4.1071, 4.1081, 4.1091, 4.11, 4.111, 4.1119, 4.1129, 4.1138, 4.1148, 4.1158, 4.1167, 4.1177, 4.1187, 4.1196, 4.1206, 4.1216, 4.1226, 4.1236, 4.1246, 4.1256, 4.1266, 4.1276, 4.1286, 4.1296, 4.1305, 4.1315, 4.1324, 4.1334, 4.1343, 4.1353, 4.1363, 4.1372, 4.1382, 4.1392, 4.1402, 4.1412, 4.1423, 4.1433, 4.1443, 4.1453, 4.1463, 4.1473, 4.1483, 4.1494, 4.1504, 4.1514, 4.1524, 4.1534, 4.1544, 4.1554, 4.1564, 4.1574, 4.1584, 4.1595, 4.1607, 4.1618, 4.1629, 4.1641, 4.1652, 4.1663, 4.1675, 4.1686, 4.1697, 4.1705, 4.1715, 4.1724, 4.1733, 4.1742, 4.1751, 4.176, 4.1769, 4.1777, 4.1787, 4.1798, 4.1808, 4.1818, 4.1828, 4.1839, 4.1849, 4.1859, 4.187, 4.188, 4.189, 4.1901, 4.1912, 4.1923, 4.1934, 4.1945, 4.1955, 4.1966, 4.1977, 4.1988, 4.1998, 4.2008, 4.2018, 4.2028, 4.2038, 4.2048, 4.2058, 4.2069, 4.2079, 4.2089, 4.2098, 4.2107, 4.2116, 4.2125, 4.2134, 4.2142, 4.2151, 4.216, 4.2169, 4.2177, 4.2187, 4.2196, 4.2206, 4.2216, 4.2226, 4.2236, 4.2246, 4.2256, 4.2266, 4.2276, 4.2286, 4.2296, 4.2306, 4.2315, 4.2325, 4.2335, 4.2345, 4.2355, 4.2365, 4.2374, 4.2384, 4.2394, 4.2404, 4.2414, 4.2423, 4.2433, 4.2443, 4.2452, 4.2462, 4.2472, 4.2481, 4.2491, 4.2501, 4.251, 4.252, 4.253, 4.254, 4.2549, 4.2559, 4.2569, 4.2579, 4.2588, 4.2598, 4.2607, 4.2617, 4.2627, 4.2636, 4.2646, 4.2656, 4.2665, 4.2675, 4.2685, 4.2695, 4.2706, 4.2716, 4.2727, 4.2737, 4.2748, 4.2758, 4.2769, 4.2779, 4.279, 4.28, 4.2808, 4.2817, 4.2826, 4.2835, 4.2844, 4.2853, 4.2862, 4.287, 4.2879, 4.2888, 4.2898, 4.2907, 4.2917, 4.2926, 4.2936, 4.2945, 4.2954, 4.2964, 4.2973, 4.2982, 4.2992, 4.3002, 4.3011, 4.3021, 4.3031, 4.3041, 4.305, 4.306, 4.307, 4.3079, 4.3089, 4.3099, 4.3109, 4.3119, 4.3129, 4.3139, 4.3148, 4.3158, 4.3168, 4.3178, 4.3187, 4.3197, 4.3207, 4.3216, 4.3226, 4.3236, 4.3245, 4.3255, 4.3265, 4.3274, 4.3284, 4.3294, 4.3307, 4.3318, 4.3329, 4.334, 4.3352, 4.3363, 4.3374, 4.3386, 4.3395, 4.3404, 4.3413, 4.3422, 4.3431, 4.344, 4.3449, 4.3457, 4.3466, 4.3475, 4.3484, 4.3494, 4.3504, 4.3513, 4.3523, 4.3533, 4.3543, 4.3552, 4.3562, 4.3572, 4.3582, 4.3593, 4.3604, 4.3615, 4.3627, 4.3638, 4.3649, 4.366, 4.3671, 4.3684, 4.3693, 4.3702, 4.3711, 4.3719, 4.3728, 4.3736, 4.3745, 4.3753, 4.3761, 4.377, 4.3778, 4.3788, 4.3798, 4.3808, 4.3819, 4.3829, 4.384, 4.385, 4.3861, 4.3871, 4.3882, 4.3892, 4.3902, 4.3912, 4.3922, 4.3932, 4.3942, 4.3952, 4.3962, 4.3972, 4.3982, 4.3993, 4.4004, 4.4016, 4.4027, 4.4038, 4.4049, 4.4061, 4.4072, 4.4083, 4.4094, 4.4105, 4.4117, 4.4128, 4.413, 4.414, 4.4149, 4.4158, 4.4167,
                                        4.4177, 4.4186, 4.4196, 4.4206, 4.4216, 4.4226, 4.4236, 4.4246, 4.4256, 4.4265, 4.4275, 4.4285, 4.4297, 4.4308, 4.4319, 4.433, 4.4341, 4.4353, 4.4364, 4.4376, 4.4387, 4.4397, 4.4407, 4.4417, 4.4428, 4.4438, 4.4448, 4.4459, 4.4469, 4.448, 4.4491, 4.45, 4.451, 4.4519, 4.4528, 4.4538, 4.4547, 4.4556, 4.4565, 4.4574, 4.4583, 4.4595, 4.4606, 4.4618, 4.463, 4.4641, 4.4653, 4.4665, 4.4677, 4.4689, 4.4699, 4.4709, 4.4718, 4.4727, 4.4736, 4.4744, 4.4753, 4.4762, 4.4771, 4.478, 4.4789, 4.4799, 4.4809, 4.482, 4.483, 4.484, 4.485, 4.486, 4.4871, 4.4881, 4.489, 4.4899, 4.4908, 4.4916, 4.4925, 4.4934, 4.4943, 4.4951, 4.496, 4.4967, 4.4978, 4.4989, 4.5001, 4.5012, 4.5023, 4.5034, 4.5045, 4.5056, 4.5067, 4.5078, 4.5089, 4.51, 4.5111, 4.5122, 4.5133, 4.5143, 4.5154, 4.5165, 4.5176, 4.5187, 4.5197, 4.5206, 4.5215, 4.5224, 4.5233, 4.5242, 4.5251, 4.526, 4.5269, 4.5278, 4.5286, 4.5295, 4.5304, 4.5313, 4.5322, 4.5331, 4.534, 4.5348, 4.5357, 4.5365, 4.5377, 4.5389, 4.5401, 4.5413, 4.5425, 4.5437, 4.5449, 4.5461, 4.5473, 4.5485, 4.5498, 4.551, 4.5514, 4.5523, 4.5532, 4.554, 4.5549, 4.5558, 4.5567, 4.5576, 4.5585, 4.5594, 4.5603, 4.5613, 4.5622, 4.5631, 4.564, 4.5649, 4.5658, 4.5668, 4.5678, 4.5689, 4.57, 4.5711, 4.5723, 4.5734, 4.5745, 4.5756, 4.5767, 4.5778, 4.5789, 4.5801, 4.5812, 4.5823, 4.5835, 4.5846, 4.5857, 4.5869, 4.588, 4.5892, 4.5902, 4.5911, 4.592, 4.5929, 4.5939, 4.5948, 4.5957, 4.5966, 4.5975, 4.5984, 4.5994, 4.6004, 4.6014, 4.6024, 4.6035, 4.6045, 4.6055, 4.6065, 4.6075, 4.6085, 4.6095, 4.6106, 4.6116, 4.6126, 4.6136, 4.6146, 4.6156, 4.6166, 4.6176, 4.6186, 4.6196, 4.6206, 4.6216, 4.6226, 4.6236, 4.6246, 4.6255, 4.6265, 4.6275, 4.6285, 4.6294, 4.6304, 4.6314, 4.6324, 4.6334, 4.6344, 4.6353, 4.6363, 4.6373, 4.6383, 4.6393, 4.6403, 4.6413, 4.6423, 4.6433, 4.6442, 4.6452, 4.6462, 4.6471, 4.6482, 4.6493, 4.6504, 4.6515, 4.6526, 4.6537, 4.6548, 4.6559, 4.657, 4.6581, 4.6592, 4.6603, 4.6614, 4.6615, 4.6623, 4.6631, 4.6638, 4.6646, 4.6654, 4.6662, 4.667, 4.6681, 4.6692, 4.6703, 4.6714, 4.6725, 4.6736, 4.6747, 4.6759, 4.677, 4.6781, 4.6791, 4.6801, 4.6811, 4.682, 4.683, 4.684, 4.685, 4.686, 4.687, 4.688, 4.689, 4.69, 4.691, 4.692, 4.693, 4.694, 4.695, 4.6961, 4.6971, 4.6981, 4.6992, 4.7002, 4.7012, 4.7023, 4.7033, 4.7043, 4.7053, 4.7063, 4.7073, 4.7083, 4.7094, 4.7104, 4.7114, 4.7124, 4.7135, 4.7145, 4.7155, 4.7165, 4.7175, 4.7186, 4.7196, 4.7206, 4.7217, 4.7227, 4.7237, 4.7248, 4.7258, 4.7268, 4.7279, 4.7289, 4.7299, 4.731, 4.732, 4.733, 4.7341, 4.7351, 4.7361, 4.7371, 4.7382, 4.7392, 4.7402, 4.7413, 4.7423, 4.7433, 4.7443, 4.7454, 4.7464, 4.7474, 4.7484, 4.7494, 4.7505, 4.7515, 4.7525, 4.7535, 4.7546, 4.7556, 4.7566, 4.7577, 4.7587, 4.7597, 4.7608, 4.7618, 4.7628, 4.7639, 4.7649, 4.7659, 4.7669, 4.768, 4.769, 4.7701, 4.7711, 4.7722, 4.7732, 4.7743, 4.7753, 4.7764, 4.7774, 4.7785, 4.7796, 4.7808, 4.7819, 4.783, 4.7842, 4.7853, 4.7865, 4.7877, 4.7889, 4.7899, 4.7909, 4.7919, 4.7928, 4.7938, 4.7948, 4.7957, 4.7966, 4.7976, 4.7985, 4.7995, 4.8006, 4.8016, 4.8027, 4.8037, 4.8048, 4.8058, 4.8069, 4.8079, 4.809, 4.81, 4.811, 4.812, 4.813, 4.814, 4.8151, 4.8161, 4.8171, 4.8181, 4.8191, 4.8201, 4.8211, 4.8221, 4.8231, 4.8241, 4.8251, 4.8261, 4.8271, 4.8281, 4.8292, 4.8302, 4.8312, 4.8322, 4.8332, 4.8342, 4.8352, 4.8362, 4.8373, 4.8383, 4.8394, 4.8405, 4.8416, 4.8427, 4.8438, 4.8449, 4.8461, 4.8472, 4.8483, 4.8496, 4.8509, 4.8522, 4.8534, 4.8547, 4.856, 4.8573, 4.8585, 4.8598, 4.8611, 4.8613, 4.8621, 4.8629, 4.8637, 4.8645, 4.8653, 4.866, 4.8668, 4.8676, 4.8685, 4.8693, 4.8701, 4.8709, 4.8718, 4.8726, 4.8734, 4.8743, 4.8751, 4.876, 4.8768, 4.8777, 4.8786, 4.8797, 4.8807, 4.8818, 4.8828, 4.8839, 4.8849, 4.886, 4.887, 4.8881, 4.8981, 4.9003, 4.9024, 4.9046, 4.9068, 4.909, 4.9112, 4.9133, 4.9155, 4.9177, 4.9199, 4.922, 4.9242, 4.9263, 4.9285, 4.9307, 4.9328, 4.935, 4.9371, 4.9393, 4.9415, 4.9436, 4.9458, 4.9479, 4.9501, 4.9522, 4.9544, 4.9566, 4.9587, 4.9609, 4.963, 4.9652, 4.9674, 4.9695,
                                    };    
    bool idx;

    idx = is_increasing_monotonically(cal_data, PDAB_SCAN_LENGTH_16);

  	TEST_ASSERT_EQUAL_INT(true, idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            is_increasing_monotonically()
 *
 * @test             This is to test whether the is_increasing_monotonically()
 *                   function returns true on sample data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_is_increasing_monotonically_returns_true_on_small_sample(void)
{
    bool idx;
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};

    idx = is_increasing_monotonically(sample_data, 8);

  	TEST_ASSERT_EQUAL_INT(true, idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            is_increasing_monotonically()
 *
 * @test             This is to test whether the is_increasing_monotonically()
 *                   function returns false on non-monotonically-increasing data
 *                   where two elements equal to each other are at the beginning
 *                   of the array.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_is_increasing_monotonically_returns_false_equal_data_at_the_beginning(void)
{
    bool idx;
    const fptype sample_data[8] = { -0.005007, -0.005007, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};

    idx = is_increasing_monotonically(sample_data, 8);

  	TEST_ASSERT_EQUAL_INT(false, idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            is_increasing_monotonically()
 *
 * @test             This is to test whether the is_increasing_monotonically()
 *                   function returns false on non-monotonically-increasing data
 *                   where two elements are inverted at the beginning
 *                   of the array.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_is_increasing_monotonically_returns_false_inverted_data_at_the_beginning(void)
{
    bool idx;
    const fptype sample_data[8] = { -0.0038958, -0.005007,  -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};

    idx = is_increasing_monotonically(sample_data, 8);

  	TEST_ASSERT_EQUAL_INT(false, idx);
}

/* ************************************************************************** */
/** 
 * @brief            is_increasing_monotonically()
 *
 * @test             This is to test whether the is_increasing_monotonically()
 *                   function returns false on non-monotonically-increasing data
 *                   where two elements equal to each other are at the end
 *                   of the array.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_is_increasing_monotonically_returns_false_equal_data_at_the_end(void)
{
    bool idx;
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0016597};

    idx = is_increasing_monotonically(sample_data, 8);

  	TEST_ASSERT_EQUAL_INT(false, idx);
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   works on non-monotonous data.
 * 
 * @note             This test can fail, but it is to show that data must be
 *                   monotonous.
 */
/* ************************************************************************** */
void test_nearest_neighbour_not_monotonous_data(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, 0.0005486, -0.00056251, 0.0016597, 0.0027708};
    float val = -0.00056252;
    int s_idx = 0;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(4,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   works with monotonous, but not strictly monotonous data.
 * 
 * @note             This test can fail. Given how data from nearest_neighbour() 
 *                   is used by interpolate_scan(), it is preferred that the 
 *                   return from nearest_neighbour is the second from the two 
 *                   consecutive same data points. 
 */
/* ************************************************************************** */
void test_nearest_neighbour_not_strictly_monotonous_data(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, 0.0005486, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0006;
    int s_idx = 0;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(5,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   works with strictly monotonous data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_strictly_monotonous_data(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0006;
    int s_idx = 0;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(5,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   always returns idx corresponsding to array elem that is
 *                   smaller than value.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_val_closer_to_higher_idx(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0016596;
    int s_idx = 0;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(5,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   always returns idx corresponding to array elem that is
 *                   smaller than value.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_val_equal_to_array_element(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0016597;
    int s_idx = 0;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(6,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   returns error when value is less than smallest elem in 
 *                   array.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_returns_error_when_value_too_small(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = -0.006;
    int s_idx = 0;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(-1,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   returns first elem (0) when value is equal to the smallest 
 *                   element in array.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_returns_zero_when_value_equals_first_elem_in_arr(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = -0.005007;
    int s_idx = 0;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(0,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   returns error when value is higher than last element
 *                   in array.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_returns_error_when_value_too_big(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 1.0025;
    int s_idx = 0;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(-1,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   returns idx of last elem minus one when value is equal to
 *                   the last element in array.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_returns_last_elem_minus_one_when_value_equals_last_elem_in_arr(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0027708;
    int s_idx = 0;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(6,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   returns last_array_elem-1 when value is just under last 
 *                   element in array.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_returns_last_elem_minus_one_for_under_max_value(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0027;
    int s_idx = 0;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(6,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   returns error when start_idx is below 0.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_returns_error_when_start_idx_is_below_0(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0027;
    int s_idx = -1;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(-1,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   returns error when start_idx is above len-1.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_returns_error_when_start_idx_is_above_len_minus_1(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0027;
    int s_idx = 8;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(-1,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   returns error when start_idx is above len-1 and value is
 *                   equal last array element.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_returns_error_when_start_idx_is_above_len_minus_1_and_value_equal_last_elem(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0027708;
    int s_idx = 8;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(-1,idx);
    
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   returns error when start_idx is equal len-1 and value is
 *                   equal last array element.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_returns_error_when_start_idx_is_equal_len_minus_1_and_value_equal_last_elem(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0027708;
    int s_idx = 7;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 8);
  	TEST_ASSERT_EQUAL_INT(6,idx);
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   returns error when array length is negative.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_returns_error_when_array_len_negative(void)
{
    const fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0016597;
    int s_idx = 3;
    int idx;

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, -1);
  	TEST_ASSERT_EQUAL_INT(-1,idx);
}

/* ************************************************************************** */
/** 
 * @brief            nearest_neighbour()
 *
 * @test             This is to test whether the nearest neighbour function
 *                   returns error when array length is 0.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_nearest_neighbour_returns_error_when_array_len_0(void)
{
    fptype sample_data[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    float val = 0.0016597;
    int s_idx = 0;
    int idx;
    
    int window = 5;
    
    int transformed_len;
    
    transform_to_uniform_distribution(sample_data, window, INTERPOLATION_DISTANCE, &__npda_offsetted_x_start, &transformed_len);

    idx = nearest_neighbour(val, s_idx, (fptype*) sample_data, 0);
  	TEST_ASSERT_EQUAL_INT(-1,idx);
}

/* ************************************************************************** */
/** 
 * @brief            transform_to_uniform_distribution()
 *
 * @test             This is to test whether the transform_to_uniform_distribution()
 *                   function returns correct array_length and x_start.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_transform_to_uniform_distribution_transformed_size_and_start_correct(void)
{
    fptype x[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    fptype x_start;
    int x_size;
    int retval;
    
    retval = transform_to_uniform_distribution(x, 8, 0.001f, &x_start, &x_size);
    
  	TEST_ASSERT_EQUAL_INT(8, x_size);
  	TEST_ASSERT_FLOAT_WITHIN(0.0000001, -0.005, x_start);
  	TEST_ASSERT_FLOAT_WITHIN(0.0000001, 0.002, (x_start + (x_size-1) * 0.001f));
  	TEST_ASSERT_EQUAL_INT(0, retval);
}

/* ************************************************************************** */
/** 
 * @brief            transform_to_uniform_distribution()
 *
 * @test             This is to test whether the transform_to_uniform_distribution()
 *                   function returns correct values when element at the beginning
 *                   of the array is divisible by resolution.
 * 
 * @note             When first and/or last value of the x variable are
 *                   divisible by resolution, the result of the function is
 *                   indeterministic due to floating point arithmetics rounding
 *                   error. Regardless of the outcome, x_start must be 
 */
/* ************************************************************************** */
void test_transform_to_uniform_distribution_first_x_equal_to_resolution(void)
{
    fptype x[8] = { -0.005, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    fptype x_start;
    int x_size;
    int retval;
    
    retval = transform_to_uniform_distribution(x, 8, 0.001f, &x_start, &x_size);
    
    if(!(x_size == 8 || x_size == 7))
    {
        TEST_FAIL();
    }
  	TEST_ASSERT_FLOAT_WITHIN(0.0000001, 0.002, (x_start + (x_size-1) * 0.001f));
    if(!(x_start >= x[0] && (x_start + (x_size-1) * 0.001f) <= x[7]))
    {
        TEST_FAIL();
    }
  	TEST_ASSERT_EQUAL_INT(0, retval);
}

/* ************************************************************************** */
/** 
 * @brief            transform_to_uniform_distribution()
 *
 * @test             This is to test whether the transform_to_uniform_distribution()
 *                   function returns correct values when element at the end
 *                   of the array is divisible by resolution.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_transform_to_uniform_distribution_last_x_equal_to_resolution(void)
{
    fptype x[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.002};
    fptype x_start;
    int x_size;
    int retval;
    
    retval = transform_to_uniform_distribution(x, 8, 0.001f, &x_start, &x_size);
    
    if(!(x_size == 8 || x_size == 7))
    {
        TEST_FAIL();
    }
  	TEST_ASSERT_FLOAT_WITHIN(0.0000001, -0.005, x_start);
    if(!(x_start >= x[0] && (x_start + (x_size-1) * 0.001f) <= x[7]))
    {
        TEST_FAIL();
    }
  	TEST_ASSERT_EQUAL_INT(0, retval);
}

/* ************************************************************************** */
/** 
 * @brief            transform_to_uniform_distribution()
 *
 * @test             This is to test whether the transform_to_uniform_distribution()
 *                   function returns error when resolution is zero.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_transform_to_uniform_distribution_throws_error_when_resolution_is_zero(void)
{
    fptype x[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    fptype x_start;
    int x_size;
    int retval;
    
    retval = transform_to_uniform_distribution(x, 8, 0, &x_start, &x_size);

  	TEST_ASSERT_EQUAL_INT(1, retval);
}

/* ************************************************************************** */
/** 
 * @brief            transform_to_uniform_distribution()
 *
 * @test             This is to test whether the transform_to_uniform_distribution()
 *                   function returns error when resolution is negative.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_transform_to_uniform_distribution_throws_error_when_resolution_too_low(void)
{
    fptype x[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    fptype x_start;
    int x_size;
    int retval;
    
    retval = transform_to_uniform_distribution(x, 8, -0.001, &x_start, &x_size);

  	TEST_ASSERT_EQUAL_INT(1, retval);
}

/* ************************************************************************** */
/** 
 * @brief            transform_to_uniform_distribution()
 *
 * @test             This is to test whether the transform_to_uniform_distribution()
 *                   function returns error when x_length is 1.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_transform_to_uniform_distribution_throws_error_when_x_len_is_1(void)
{
    fptype x[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    fptype x_start;
    int x_size;
    int retval;
    
    retval = transform_to_uniform_distribution(x, 1, 0.001, &x_start, &x_size);

  	TEST_ASSERT_EQUAL_INT(1, retval);
}

/* ************************************************************************** */
/** 
 * @brief            transform_to_uniform_distribution()
 *
 * @test             This is to test whether the transform_to_uniform_distribution()
 *                   function returns error when x_length is 0.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_transform_to_uniform_distribution_throws_error_when_x_len_is_0(void)
{
    fptype x[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    fptype x_start;
    int x_size;
    int retval;
    
    retval = transform_to_uniform_distribution(x, 0, 0.001, &x_start, &x_size);

  	TEST_ASSERT_EQUAL_INT(1, retval);
}

/* ************************************************************************** */
/** 
 * @brief            transform_to_uniform_distribution()
 *
 * @test             This is to test whether the transform_to_uniform_distribution()
 *                   function returns error when transformed_len is less or equal
 *                   to 1.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_transform_to_uniform_distribution_throws_error_when_transformed_len_is_less_than_2(void)
{
    fptype x[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, -0.0049007};
    fptype x_start;
    int x_size;
    int retval;
    
    retval = transform_to_uniform_distribution(x, 8, 0.001, &x_start, &x_size);

  	TEST_ASSERT_EQUAL_INT(2, retval);
}

/* ************************************************************************** */
/** 
 * @brief            interpolate_scan()
 *
 * @test             This is to test whether the interpolate_scan()
 *                   function returns correct values on sample data. Uniformly
 *                   distributed data is calculated using
 *                   transform_to_uniform_distribution().
 *                   Verified against MATLAB interp1().
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_interpolate_scan_with_transform_to_uniform(void)
{
    int iret;
    fptype x0[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    uint16_t y0[8] = { 0, 2, 5, 0, 6, 3, 2, 1};
    int x0_y0_length = 8;
    int x_y_interp_length;
    fptype res = INTERPOLATION_DISTANCE;
    
    transform_to_uniform_distribution(x0, x0_y0_length, res, &__npda_offsetted_x_start, &x_y_interp_length);

    fptype y[8];
    fptype y_desired[8] = {0.012598992080634, 1.812455003599712, 4.418684186841869,
                        1.468814688146882, 3.637509112673141, 4.481221481221482,
                        2.593735937359374, 1.693726937269373}; //Generated with MATLAB interp1(x0, y0, x) where x(i)=__npda_offsetted_x_start + i*res
    
    iret = interpolate_scan(x0, y0, x0_y0_length, y, x_y_interp_length);

    TEST_ASSERT_EQUAL_INT(0,iret);
    
    int i;
    for(i=0; i<x_y_interp_length; i++)
    {
      	TEST_ASSERT_FLOAT_WITHIN(0.00001,  y_desired[i], y[i]);
    }
}

/* ************************************************************************** */
/** 
 * @brief            interpolate_scan()
 *
 * @test             This is to test whether the interpolate_scan()
 *                   function returns correct values on sample data, when x0
 *                   equals x. Verified against MATLAB interp1().
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_interpolate_scan_x0_is_x(void)
{
    int iret;
    fptype x0[8] = { -0.005, -0.004, -0.003, -0.002, -0.001, 0.0, 0.001, 0.002};
    uint16_t y0[8] = { 0, 2, 5, 0, 6, 3, 2, 1};
    int x0_y0_length = 8;
    int x_y_interp_length = x0_y0_length;
    __npda_offsetted_x_start = -0.005;
    
    fptype y[8];
    fptype y_desired[8] = { 0, 2, 5, 0, 6, 3, 2, 1}; //Generated with MATLAB interp1(x0, y0, x) where x(i)=__npda_offsetted_x_start + i*res
    
    iret = interpolate_scan(x0, y0, x0_y0_length, y, x_y_interp_length);

    TEST_ASSERT_EQUAL_INT(0,iret);
    
    int i;
    for(i=0; i<x_y_interp_length; i++)
    {
      	TEST_ASSERT_FLOAT_WITHIN(0.00001,  y_desired[i], y[i]);
    }
}

/* ************************************************************************** */
/** 
 * @brief            interpolate_scan()
 *
 * @test             This is to test whether the interpolate_scan()
 *                   function returns error when first element of x0 is smaller
 *                   than __npda_offsetted_x_start.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_interpolate_scan_throws_error_when_x0_starts_after_x_start(void)
{
    int iret;
    fptype x0[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    uint16_t y0[8] = { 0, 2, 5, 0, 6, 3, 2, 1};
    int x0_y0_length = 8;
    int x_y_interp_length = x0_y0_length;
    __npda_offsetted_x_start = -0.006;
    
    fptype y[8];
    
    iret = interpolate_scan(x0, y0, x0_y0_length, y, x_y_interp_length);

    TEST_ASSERT_EQUAL_INT(1,iret);
}

/* ************************************************************************** */
/** 
 * @brief            interpolate_scan()
 *
 * @test             This is to test whether the interpolate_scan()
 *                   function returns error when last element of x0 is lower
 *                   than __npda_offsetted_x_start + INTERPOLATION_DISTANCE *
 *                   (x_y_interp_length-1).
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_interpolate_scan_throws_error_when_x0_ends_before_x(void)
{
    int iret;
    fptype x0[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    uint16_t y0[8] = { 0, 2, 5, 0, 6, 3, 2, 1};
    int x0_y0_length = 8;
    int x_y_interp_length = x0_y0_length;
    __npda_offsetted_x_start = -0.0042291;
    
    fptype y[8];
    
    iret = interpolate_scan(x0, y0, x0_y0_length, y, x_y_interp_length);

    TEST_ASSERT_EQUAL_INT(1,iret);
}

/* ************************************************************************** */
/** 
 * @brief            interpolate_scan()
 *
 * @test             This is to test whether the interpolate_scan()
 *                   function returns error when x_y_inter_len is too
 *                   small (i.e. is equal to 0).
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_interpolate_scan_returns_error_when_x_y_inter_len_too_small(void)
{
    int iret;
    fptype x0[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    uint16_t y0[8] = { 0, 2, 5, 0, 6, 3, 2, 1};
    int x0_y0_length = 8;
    int x_y_interp_length = 0;
    
    __npda_offsetted_x_start = -0.005;
    
    fptype y[8];
    
    iret = interpolate_scan(x0, y0, x0_y0_length, y, x_y_interp_length);

    TEST_ASSERT_EQUAL_INT(4,iret);
}

/* ************************************************************************** */
/** 
 * @brief            interpolate_scan()
 *
 * @test             This is to test whether the interpolate_scan()
 *                   function returns correct values when x_y_inter_len equals 1.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_interpolate_scan_x_y_inter_len_equals_1(void)
{
    int iret;
    fptype x0[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    uint16_t y0[8] = { 0, 2, 5, 0, 6, 3, 2, 1};
    int x0_y0_length = 8;
    int x_y_interp_length = 1;
    
    __npda_offsetted_x_start = -0.005;
    
    fptype y[8];
    
    iret = interpolate_scan(x0, y0, x0_y0_length, y, x_y_interp_length);

    TEST_ASSERT_EQUAL_INT(0,iret);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.012598992080634, y[0]);
}

/* ************************************************************************** */
/** 
 * @brief            interpolate_scan()
 *
 * @test             This is to test whether the interpolate_scan()
 *                   function returns error when x0/y0 length is too small (i.e.
 *                   is equal to 1).
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_interpolate_scan_returns_error_when_x0_y0_length_too_small(void)
{
    int iret;
    fptype x0[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    uint16_t y0[8] = { 0, 2, 5, 0, 6, 3, 2, 1};
    int x0_y0_length = 1;
    int x_y_interp_length = 1;
    
    __npda_offsetted_x_start = -0.005;
    
    fptype y[8];
    
    iret = interpolate_scan(x0, y0, x0_y0_length, y, x_y_interp_length);

    TEST_ASSERT_EQUAL_INT(1,iret);
}

/* ************************************************************************** */
/** 
 * @brief            interpolate_scan()
 *
 * @test             This is to test whether the interpolate_scan()
 *                   function returns correct values when x0/y0 length equals 2.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_interpolate_scan_x0_y0_length_equals_2(void)
{
    int iret;
    fptype x0[8] = { -0.005007, -0.0038958, -0.0027847, -0.0016736, -0.00056251, 0.0005486, 0.0016597, 0.0027708};
    uint16_t y0[8] = { 0, 2, 5, 0, 6, 3, 2, 1};
    int x0_y0_length = 2;
    int x_y_interp_length = 1;
    
    __npda_offsetted_x_start = -0.005;
    
    fptype y[8];
    
    iret = interpolate_scan(x0, y0, x0_y0_length, y, x_y_interp_length);

    TEST_ASSERT_EQUAL_INT(0,iret);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.012598992080634, y[0]);
}

/* ************************************************************************** */
/** 
 * @brief            interpolate_scan()
 *
 * @test             This is to test whether the interpolate_scan()
 *                   function returns error when x0 is not monotonically
 *                   increasing.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_interpolate_returns_error_when_x0_is_not_strictly_monotonically_increasing(void)
{
    int iret;
    fptype x0[8] = { -0.005007, -0.0038958, -0.0027847, 0.0005486, 0.0005486, 0.0005486, 0.0016597, 0.0027708};
    uint16_t y0[8] = { 0, 2, 5, 0, 6, 3, 2, 1};
    int x0_y0_length = 8;
    int x_y_interp_length = x0_y0_length;
    
    __npda_offsetted_x_start = -0.005;
    
    fptype y[8];
    
    iret = interpolate_scan(x0, y0, x0_y0_length, y, x_y_interp_length);

    TEST_ASSERT_EQUAL_INT(3,iret);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_peak()
 *
 * @test             This is to test whether the find_ac_peak()
 *                   function returns correct values when presented with
 *                   meaningful data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_peak_correct_data()
{
    int iret;
    fptype scany[9] = { 0.1, 0.8, 0.5, 2.0, 1.6, 1.2, 0.8, 1.4, 2.0};
    int x0_y0_length = 9;
    fptype maxval = 2.0;
    int maxpos = 3;
    int q1, q2;
    
    iret = find_ac_peak(scany, x0_y0_length, maxval, maxpos, &q1, &q2);

    TEST_ASSERT_EQUAL_INT(0,iret);
    TEST_ASSERT_EQUAL_INT(2,q1);
    TEST_ASSERT_EQUAL_INT(6,q2);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_peak()
 *
 * @test             This is to test whether the find_ac_peak()
 *                   function returns correct values when q1 and q2 are at 
 *                   scany limits.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_peak_q1_q2_at_limits()
{
    int iret;
    fptype scany[9] = { 0.1, 1.8, 1.5, 2.0, 1.6, 1.2, 1.8, 1.4, 0.0};
    int x0_y0_length = 9;
    fptype maxval = 2.0;
    int maxpos = 3;
    int q1, q2;
    
    iret = find_ac_peak(scany, x0_y0_length, maxval, maxpos, &q1, &q2);

    TEST_ASSERT_EQUAL_INT(0,iret);
    TEST_ASSERT_EQUAL_INT(0,q1);
    TEST_ASSERT_EQUAL_INT(8,q2);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_peak()
 *
 * @test             This is to test whether the find_ac_peak()
 *                   function returns correct values when scany is flat, at maxval.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_peak_returns_error_flat_data()
{
    int iret;
    fptype scany[9] = { 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0};
    int x0_y0_length = 9;
    fptype maxval = 2.0;
    int maxpos = 3;
    int q1, q2;
    
    iret = find_ac_peak(scany, x0_y0_length, maxval, maxpos, &q1, &q2);

    TEST_ASSERT_EQUAL_INT(2,iret);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_peak()
 *
 * @test             This is to test whether the find_ac_peak()
 *                   function returns correct values when scany is flat, at 0.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_peak_returns_error_flat_data_equal_zero()
{
    int iret;
    fptype scany[9] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
    int x0_y0_length = 9;
    fptype maxval = 2.0;
    int maxpos = 3;
    int q1, q2;
    
    iret = find_ac_peak(scany, x0_y0_length, maxval, maxpos, &q1, &q2);

    TEST_ASSERT_EQUAL_INT(0,iret);
    TEST_ASSERT_EQUAL_INT(3,q1);
    TEST_ASSERT_EQUAL_INT(3,q2);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_peak()
 *
 * @test             This is to test whether the find_ac_peak()
 *                   function returns idx=0 values when scany values are flat to
 *                   the left of the peak.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_peak_left_flattened_data()
{
    int iret;
    fptype scany[9] = { 1.5, 1.5, 1.5, 2.0, 1.6, 1.2, 0.8, 1.4, 2.0};
    int x0_y0_length = 9;
    fptype maxval = 2.0;
    int maxpos = 3;
    int q1, q2;
    
    iret = find_ac_peak(scany, x0_y0_length, maxval, maxpos, &q1, &q2);

    TEST_ASSERT_EQUAL_INT(0,iret);
    TEST_ASSERT_EQUAL_INT(0,q1);
    TEST_ASSERT_EQUAL_INT(6,q2);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_peak()
 *
 * @test             This is to test whether the find_ac_peak()
 *                   function returns error when values of the scany are flat
 *                   to the right of the peak.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_peak_returns_error_right_flattened_data()
{
    int iret;
    fptype scany[9] = { 0.1, 0.8, 0.5, 2.0, 1.6, 1.2, 1.2, 1.2, 1.2};
    int x0_y0_length = 9;
    fptype maxval = 2.0;
    int maxpos = 3;
    int q1, q2;
    
    iret = find_ac_peak(scany, x0_y0_length, maxval, maxpos, &q1, &q2);

    TEST_ASSERT_EQUAL_INT(2,iret);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_peak()
 *
 * @test             This is to test whether the find_ac_peak()
 *                   function returns error when maxpos is too low (<1).
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_peak_returns_error_when_maxpos_too_low()
{
    int iret;
    fptype scany[9] = { 0.1, 0.8, 0.5, 2.0, 1.6, 1.2, 0.8, 1.4, 2.0};
    int x0_y0_length = 9;
    fptype maxval = 2.0;
    int maxpos = 0;
    int q1, q2;
    
    iret = find_ac_peak(scany, x0_y0_length, maxval, maxpos, &q1, &q2);

    TEST_ASSERT_EQUAL_INT(1,iret);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_peak()
 *
 * @test             This is to test whether the find_ac_peak()
 *                   function returns error when maxpos is too high
 *                   ( >= scany_len - 1 ).
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_peak_returns_error_when_maxpos_too_high()
{
    int iret;
    fptype scany[9] = { 0.1, 0.8, 0.5, 2.0, 1.6, 1.2, 0.8, 1.4, 2.0};
    int x0_y0_length = 9;
    fptype maxval = 2.0;
    int maxpos = 8;
    int q1, q2;
    
    iret = find_ac_peak(scany, x0_y0_length, maxval, maxpos, &q1, &q2);

    TEST_ASSERT_EQUAL_INT(1,iret);
}


/* ************************************************************************** */
/** 
 * @brief            find_active_points()
 *
 * @test             This is to test whether the find_active_points()
 *                   function returns correct values when presented with normal
 *                   data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_active_points_normal_peak()
{
    int iret;
    fptype scany[] = { 0.8, 1.5, 2.0, 1.6, 1.2, 0.8, 1.4, 2.0};
    int q1 = 1;
    int q2 = 6;
    int range = q2 - q1;
    fptype maxval = 2.0;
    byte active_points[] = {0, 0, 0, 0, 0, 0, 0, 0};
    byte expected_active_points[] = {0, 1, 0, 1, 1, 0, 0, 0};
    
    
    iret = find_active_points(scany, range, maxval, active_points);
    
    TEST_ASSERT_EQUAL_INT(0,iret);
    int i;
    for(i=0; i<8; i++) {
        TEST_ASSERT_EQUAL_INT(expected_active_points[i], active_points[i]);
    }
}

/* ************************************************************************** */
/** 
 * @brief            find_active_points()
 *
 * @test             This is to test whether the find_active_points()
 *                   function returns correct values when presented with scany
 *                   data that contains q1, peak and q2 values at 0.5 and 0.95 
 *                   of scany_max.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_active_points_normal_peak_y_values_at_limits()
{
    int iret;
    fptype scany[] = { 1.0, 1.5, 1.9, 1.6, 1.2, 1.0, 1.4, 2.0};
    int q1 = 1;
    int q2 = 6;
    int range = q2 - q1;
    fptype maxval = 2.0;
    byte active_points[] = { 0, 0, 0, 0, 0, 0, 0, 0};
    byte expected_active_points[] = {1, 1, 1, 1, 1, 0, 0, 0};
    
    iret = find_active_points(scany, range, maxval, active_points);
    
    TEST_ASSERT_EQUAL_INT(0,iret);
    int i;
    for(i=0; i<8; i++) {
        TEST_ASSERT_EQUAL_INT(expected_active_points[i], active_points[i]);
    }
}

/* ************************************************************************** */
/** 
 * @brief            find_active_points()
 *
 * @test             This is to test whether the find_active_points()
 *                   function returns error when q2 is q1 + 2.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_active_points_returns_error_when_q2_is_q1_plus_2()
{
    int iret;
    fptype scany[] = { 0.8, 1.5, 1.9, 1.6, 1.2, 0.8, 1.4, 2.0};
    int q1 = 1;
    int q2 = 3;
    int range = q2 - q1;
    fptype maxval = 2.0;
    byte active_points[] = {0, 0, 0, 0, 0, 0, 0, 0};
    
    iret = find_active_points(scany, range, maxval, active_points);
    
    TEST_ASSERT_EQUAL_INT(1,iret);
}

/* ************************************************************************** */
/** 
 * @brief            polyfit2()
 *
 * @test             This is to test whether the polyfit2()
 *                   function returns correct coefficients when presented with
 *                   normal peak data. Verified against MATLAB polyfit().
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_polyfit2_normal_data()
{
    int iret;
    __npda_offsetted_x_start = -0.004;
    fptype scany[32] = {447.4435, 447.9161, 448.8861, 451.1408, 451.6197,
    451.5343, 453.4046, 452.1111, 453.3917, 453.6834, 454.7914, 455.1248,
    454.1162, 454.8640, 454.8517, 455.2631, 455.3333, 455.3019, 454.1566,
    454.7100, 454.3408, 452.9698, 452.4305, 452.6713, 453.0100, 451.1213,
    450.8950, 449.3901, 449.5969, 447.6906, 447.2122, 446.5524};
    int q1 = 0;
    byte active_members[32] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int wsize = 32;
    double coeffs[3];
    double expected_coeffs[3] = {451.06095339076, 737.24946847508, -34157.05645161291};
    
    iret = polyfit2(scany, q1, active_members, wsize, coeffs);

  	TEST_ASSERT_EQUAL_INT(0, iret);
    
  	TEST_ASSERT_FLOAT_WITHIN(0.01, expected_coeffs[0], coeffs[0]); //Ensure first 5 digits are correct
  	TEST_ASSERT_FLOAT_WITHIN(0.01, expected_coeffs[1], coeffs[1]);
  	TEST_ASSERT_FLOAT_WITHIN(1.0, expected_coeffs[2], coeffs[2]);
}

/* ************************************************************************** */
/** 
 * @brief            polyfit2()
 *
 * @test             This is to test whether the polyfit2()
 *                   function returns correct coefficients when presented with
 *                   normal peak data, when offset and active_members
 *                   constraints are applied. Verified against MATLAB polyfit().
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_polyfit2_half_empty_active_member_buffer_and_offset_applied()
{
    int iret;
    __npda_offsetted_x_start = -0.004;
    fptype scany[] = {448.8861, 451.1408, 451.6197,
    451.5343, 453.4046, 452.1111, 453.3917, 453.6834, 454.7914, 455.1248,
    454.1162, 454.8640, 454.8517, 455.2631, 455.3333, 455.3019, 454.1566,
    454.7100, 454.3408, 452.9698, 452.4305, 452.6713, 453.0100, 451.1213,
    450.8950, 449.3901, 449.5969, 447.6906, 447.2122, 446.5524, 447.9161, 447.4435};
    int q1 = 2;
    byte active_members[32] = {0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 
    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    int wsize = 28;
    double coeffs[3];
    double expected_coeffs[3] = {451.46047459647, 764.64077181345, -36623.38460569814};

    iret = polyfit2(scany, q1, active_members, wsize, coeffs);

  	TEST_ASSERT_EQUAL_INT(0, iret);
    
  	TEST_ASSERT_FLOAT_WITHIN(0.01, expected_coeffs[0], coeffs[0]); //Ensure first 5 digits are correct
  	TEST_ASSERT_FLOAT_WITHIN(0.01, expected_coeffs[1], coeffs[1]);
  	TEST_ASSERT_FLOAT_WITHIN(1.0, expected_coeffs[2], coeffs[2]);
}

/* ************************************************************************** */
/** 
 * @brief            polyfit2()
 *
 * @test             This is to test whether the polyfit2()
 *                   function returns correct coefficients when presented with
 *                   straight line data. Verified against MATLAB polyfit().
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_polyfit2_straight_line()
{
    int iret;
    __npda_offsetted_x_start = -0.004;
    fptype scany[32] = {447.0, 448.0, 449.0, 450.0, 451.0,
    452.0, 453.0, 454.0, 455.0, 456.0, 457.0, 458.0,
    459.0, 460.0, 461.0, 462.0, 463.0, 464.0, 465.0,
    466.0, 467.0, 468.0, 469.0, 470.0, 471.0, 472.0,
    473.0, 474.0, 475.0, 476.0, 477.0, 478.0};
    int q1 = 0;
    byte active_members[32] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int wsize = 32;
    double coeffs[3];
    double expected_coeffs[3] = {451.0, 1000.0, 0.0};
    
    iret = polyfit2(scany, q1, active_members, wsize, coeffs);

  	TEST_ASSERT_EQUAL_INT(0, iret);
    
  	TEST_ASSERT_FLOAT_WITHIN(0.01, expected_coeffs[0], coeffs[0]); //Ensure first 5 digits are correct
  	TEST_ASSERT_FLOAT_WITHIN(0.1, expected_coeffs[1], coeffs[1]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, expected_coeffs[2], coeffs[2]);
}

/* ************************************************************************** */
/** 
 * @brief            polyfit2()
 *
 * @test             This is to test whether the polyfit2()
 *                   function returns correct coefficients when presented with
 *                   flat straight line data. Verified against MATLAB polyfit().
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_polyfit2_flat_straight_line()
{
    int iret;
    __npda_offsetted_x_start = -0.004;
    fptype scany[32] = {451.0, 451.0, 451.0, 451.0, 451.0,
    451.0, 451.0, 451.0, 451.0, 451.0, 451.0, 451.0,
    451.0, 451.0, 451.0, 451.0, 451.0, 451.0, 451.0,
    451.0, 451.0, 451.0, 451.0, 451.0, 451.0, 451.0,
    451.0, 451.0, 451.0, 451.0, 451.0, 451.0};
    int q1 = 0;
    byte active_members[32] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int wsize = 32;
    double coeffs[3];
    double expected_coeffs[3] = {451.0, 0.0, 0.0};
    
    iret = polyfit2(scany, q1, active_members, wsize, coeffs);

  	TEST_ASSERT_EQUAL_INT(0, iret);
    
  	TEST_ASSERT_FLOAT_WITHIN(0.01, expected_coeffs[0], coeffs[0]); //Ensure first 5 digits are correct
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, expected_coeffs[1], coeffs[1]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, expected_coeffs[2], coeffs[2]);
}

/* ************************************************************************** */
/** 
 * @brief            polyfit2()
 *
 * @test             This is to test whether the polyfit2()
 *                   function returns error when active_members_cnt is too low.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_polyfit2_returns_error_when_active_members_cnt_too_low()
{
    int iret;
    __npda_offsetted_x_start = -0.004;
    fptype scany[32] = {447.4435, 447.9161, 448.8861, 451.1408, 451.6197,
    451.5343, 453.4046, 452.1111, 453.3917, 453.6834, 454.7914, 455.1248,
    454.1162, 454.8640, 454.8517, 455.2631, 455.3333, 455.3019, 454.1566,
    454.7100, 454.3408, 452.9698, 452.4305, 452.6713, 453.0100, 451.1213,
    450.8950, 449.3901, 449.5969, 447.6906, 447.2122, 446.5524};
    int q1 = 0;
    byte active_members[32] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    int wsize = 32;
    double coeffs[3];
    
    iret = polyfit2(scany, q1, active_members, wsize, coeffs);

  	TEST_ASSERT_EQUAL_INT(1, iret);
}

/* ************************************************************************** */
/** 
 * @brief            polyfit2()
 *
 * @test             This is to test whether the polyfit2()
 *                   function returns correct coefficients when presented with
 *                   minimum number of active members.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_polyfit2_minimum_active_members_cnt()
{
    int iret;
    __npda_offsetted_x_start = -0.004;
    fptype scany[32] = {447.4435, 447.9161, 448.8861, 451.1408, 451.6197,
    451.5343, 453.4046, 452.1111, 453.3917, 453.6834, 454.7914, 455.1248,
    454.1162, 454.8640, 454.8517, 455.2631, 455.3333, 455.3019, 454.1566,
    454.7100, 454.3408, 452.9698, 452.4305, 452.6713, 453.0100, 451.1213,
    450.8950, 449.3901, 449.5969, 447.6906, 447.2122, 446.5524};
    int q1 = 0;
    byte active_members[32] = {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    int wsize = 32;
    double coeffs[3];
    double expected_coeffs[3] = {452.3183, 2213.5, 248700.0};

    iret = polyfit2(scany, q1, active_members, wsize, coeffs);

  	TEST_ASSERT_EQUAL_INT(0, iret);
    
  	TEST_ASSERT_FLOAT_WITHIN(0.01, expected_coeffs[0], coeffs[0]); //Ensure first 5 digits are correct
  	TEST_ASSERT_FLOAT_WITHIN(0.1, expected_coeffs[1], coeffs[1]);
  	TEST_ASSERT_FLOAT_WITHIN(10.0, expected_coeffs[2], coeffs[2]);
}

/* ************************************************************************** */
/** 
 * @brief            polyfit2()
 *
 * @test             This is to test whether the polyfit2()
 *                   function returns error when offset is negative.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_polyfit2_returns_error_when_offset_negative()
{
    int iret;
    __npda_offsetted_x_start = -0.004;
    fptype scany[32] = {447.4435, 447.9161, 448.8861, 451.1408, 451.6197,
    451.5343, 453.4046, 452.1111, 453.3917, 453.6834, 454.7914, 455.1248,
    454.1162, 454.8640, 454.8517, 455.2631, 455.3333, 455.3019, 454.1566,
    454.7100, 454.3408, 452.9698, 452.4305, 452.6713, 453.0100, 451.1213,
    450.8950, 449.3901, 449.5969, 447.6906, 447.2122, 446.5524};
    int q1 = -1;
    byte active_members[32] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int wsize = 32;
    double coeffs[3];

    iret = polyfit2(scany, q1, active_members, wsize, coeffs);

  	TEST_ASSERT_EQUAL_INT(3, iret);
}

/* ************************************************************************** */
/** 
 * @brief            polyfit2()
 *
 * @test             This is to test whether the polyfit2()
 *                   function returns error when the data is translated far from
 *                   the origin of the coordinate system.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_polyfit2_translation_along_x()
{
    int iret;
    fptype scany[] = {501.0, 601.0, 701.0};
    byte act_mem[] = {1, 1, 1};
    
    int size = 3;

//    __npda_offsetted_x_start = -0.005; //This fits fine
    __npda_offsetted_x_start = 2.326; //This does not
    double coeffs[3];
            
    iret = polyfit2(scany, 0, act_mem, size, coeffs);

  	TEST_ASSERT_EQUAL_INT(0, iret);
    //UnityPrintFloat(coeffs[0]);
    //UnityPrint("|");
    //UnityPrintFloat(coeffs[1]);
    //UnityPrint("|");
    //UnityPrintFloat(coeffs[2]);
    //UnityPrint("|");
  	TEST_ASSERT_FLOAT_WITHIN(0.1, 0.0, coeffs[2]);
}

/* ************************************************************************** */
/** 
 * @brief            calc_parabola_max()
 *
 * @test             This is to test whether the calc_parabola_max()
 *                   function returns correct values when presented with correct
 *                   coefficients.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_calc_parabola_max_returns_correct_vals()
{
    int iret;
    __npda_offsetted_x_start = -0.004;
    double coeffs[3] = {2.0, 0.0, -4.0};
    int auto_peak_idx;
    
    iret = calc_parabola_max(coeffs, &auto_peak_idx);

    int correct_peak_idx = 4;
    
  	TEST_ASSERT_EQUAL_INT(0, iret);
  	TEST_ASSERT_EQUAL_INT(correct_peak_idx, auto_peak_idx);
}

/* ************************************************************************** */
/** 
 * @brief            calc_parabola_max()
 *
 * @test             This is to test whether the calc_parabola_max()
 *                   function returns correct values when presented with a sweep
 *                   of correct coefficients.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_calc_parabola_max_returns_correct_vals_sweep()
{
    int iret;
    __npda_offsetted_x_start = -0.004;
    double coeffs[3] = {2.0, 0.0, -4.0};
    const int range = 10;
    int i, j;
    int auto_peak_idx;

    for(j=0; j<1000; j++)
    {
        coeffs[1] = 0.000009 * (double)j;
        iret = calc_parabola_max(coeffs, &auto_peak_idx);

        fptype alt_peak_val = -FPTYPE_MAX;
        int alt_peak_idx = 0;

        for(i=0; i < range; i++)
        {
            double v = NPDA_X(i)*(coeffs[2]*NPDA_X(i) + coeffs[1]) + coeffs[0];
            if (v > (alt_peak_val)) {
                    alt_peak_val = v;
                    alt_peak_idx = i;
            }
        }

        TEST_ASSERT_EQUAL_INT(0, iret);
        TEST_ASSERT_EQUAL_INT(alt_peak_idx, auto_peak_idx);
    }
}

/* ************************************************************************** */
/** 
 * @brief            calc_parabola_max()
 *
 * @test             This is to test whether the calc_parabola_max()
 *                   function returns error when coeff[2] is positive.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_calc_parabola_max_returns_error_when_positive_a()
{
    int iret;
    __npda_offsetted_x_start = -0.004;
    double coeffs[3] = {2.0, 0.0, 4.0};
    int auto_peak_idx;
    
    iret = calc_parabola_max(coeffs, &auto_peak_idx);

  	TEST_ASSERT_EQUAL_INT(1, iret);
}

/* ************************************************************************** */
/** 
 * @brief            calc_parabola_max()
 *
 * @test             This is to test whether the calc_parabola_max()
 *                   function returns error when the parabola is a line.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_calc_parabola_max_returns_error_when_line()
{
    int iret;
    __npda_offsetted_x_start = -0.004;
    double coeffs[3] = {2.0, 0.0, 0.0};
    int auto_peak_idx;
    
    iret = calc_parabola_max(coeffs, &auto_peak_idx);

  	TEST_ASSERT_EQUAL_INT(2, iret);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_quad()
 *
 * @test             This is to test whether the find_ac_quad()
 *                   function returns correct values when presented with normal
 *                   data. Checked against findAC_quad_jr2()
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_quad_normal_data()
{
    int iret;
    fptype scany[] = {467.066667, 522.622222, 501.400000, 527.400000, 543.400000,
    445.400000, 397.400000, 422.400000, 396.700000, 353.600000, 351.700000,
    406.900000, 480.622222, 551.200000, 654.200000, 733.000000, 756.000000,
    853.600000, 859.511111, 887.200000, 861.200000, 794.000000, 714.300000,
    674.000000, 645.400000, 637.400000, 626.000000, 659.800000, 703.000000,
    738.800000, 746.000000, 789.400000, 839.854545, 865.200000, 852.309091,
    840.945455, 821.800000, 779.763636, 815.490909, 796.400000, 825.490909,
    910.300000, 885.036364, 835.945455, 787.733333, 759.733333, 810.400000,
    802.525000, 790.733333, 839.177778, 965.288889, 1054.400000, 1071.400000,
    1078.763636, 1062.945455, 1031.581818, 1002.127273, 993.400000, 999.218182,
    1038.490909, 1117.036364, 1160.309091, 1191.100000, 1182.300000, 1131.177778,
    1151.844444, 1163.775000, 1256.622222, 1310.400000, 1342.066667, 1295.400000,
    1304.288889, 1252.511111, 1239.400000, 1236.900000, 1238.100000, 1224.733333,
    1266.200000, 1314.600000, 1367.800000, 1427.600000, 1445.177778, 1475.400000,
    1517.945455, 1538.309091, 1486.945455, 1402.600000, 1424.490909, 1332.127273,
    1259.400000, 1252.400000, 1224.218182, 1235.309091, 1315.200000, 1442.844444,
    1575.400000, 1699.400000, 1774.400000, 1831.400000, 1851.955556, 1902.400000,
    1957.066667, 2066.622222, 2277.400000, 2456.490909, 2639.036364, 2781.200000,
    2894.763636, 2968.400000, 3062.036364, 3171.600000, 3222.581818, 3270.672727,
    3348.733333, 3327.400000, 3292.733333, 3296.066667, 3358.066667, 3390.177778,
    3410.177778, 3420.400000, 3415.955556, 3344.400000, 3324.177778, 3276.700000,
    3193.800000, 3141.200000, 3017.500000, 2878.733333, 2750.200000, 2676.200000,
    2582.200000, 2463.800000, 2313.000000, 2182.400000, 2046.000000, 1895.200000,
    1774.000000, 1697.600000, 1618.000000, 1593.400000, 1635.000000, 1762.800000,
    1963.400000, 2166.400000, 2492.200000, 2829.800000, 3206.800000, 3701.800000,
    4141.800000, 4689.200000, 5165.200000, 5723.800000, 6535.200000, 7441.200000,
    8614.800000, 9870.800000, 11069.200000, 12294.800000, 13565.400000, 14861.200000,
    16186.400000, 17529.400000, 18972.955556, 20568.400000, 21983.400000, 23342.400000,
    24718.900000, 26041.900000, 27317.900000, 28659.400000, 29967.400000, 31060.900000,
    32019.400000, 32779.900000, 33447.900000, 34069.900000, 34553.900000, 34908.400000,
    35164.400000, 35310.288889, 35315.600000, 35190.200000, 34956.600000, 34583.800000,
    34041.600000, 33358.400000, 32605.300000, 31877.300000, 31071.200000, 30122.844444,
    29208.400000, 28263.800000, 27278.000000, 26211.400000, 24918.400000, 23644.955556,
    22449.300000, 21532.100000, 20287.800000, 19370.100000, 18375.200000, 17372.400000,
    16734.218182, 15900.900000, 15102.763636, 14410.581818, 13696.600000, 13067.854545,
    12464.200000, 11908.672727, 11480.900000, 11024.490909, 10463.400000, 9900.400000,
    9058.177778, 8557.066667, 8310.733333, 7926.400000, 7588.066667, 7294.288889,
    6990.733333, 6670.288889, 6398.672727, 6142.672727, 5835.700000, 5505.490909,
    5185.400000, 5026.672727, 4930.100000, 4814.581818, 4766.400000, 4641.400000,
    4423.218182, 4253.400000, 4021.844444, 3864.733333, 3643.775000, 3528.288889,
    3356.066667, 3121.400000, 2930.511111, 2651.400000, 2518.511111, 2459.200000,
    2433.955556, 2378.600000, 2313.400000, 2284.600000, 2187.511111, 2058.400000,
    1947.400000, 1829.955556, 1683.000000, 1512.400000, 1342.400000, 1161.600000,
    1054.600000, 958.900000, 958.900000, 1010.511111, 1003.800000, 1017.800000,
    982.400000, 941.200000, 964.511111, 900.000000, 879.800000, 864.000000,
    837.200000, 882.400000, 905.400000, 981.400000, 1042.900000, 1075.100000,
    1080.200000, 1065.400000, 1028.000000, 1006.400000, 998.800000, 954.400000,
    894.400000, 845.900000, 729.400000, 638.500000, 596.000000, 517.600000,
    473.900000, 472.400000, 473.200000, 457.000000, 498.600000, 542.200000,
    523.490909, 454.000000, 384.854545, 357.036364, 239.218182, 247.400000,
    239.400000, 356.672727, 321.763636, 408.200000, 481.127273, 534.400000,
    538.400000, 533.511111, 442.900000, 455.511111, 430.025000, 439.511111,
    428.622222, 485.300000, 483.177778, 475.600000, 465.400000, 378.955556,
    360.400000, 382.000000, 347.000000, 385.400000, 382.066667, 369.490909,
    356.218182, 297.700000, 263.945455, 208.200000, 192.127273, 138.100000,
    105.309091, 74.400000, 74.400000, 142.581818, 131.400000, 158.200000,
    182.288889, 122.066667, 135.733333, 120.622222, 130.275000, 203.288889,
    264.844444, 307.400000, 356.400000, 345.400000, 370.854545, 327.500000,
    307.672727, 316.036364, 273.500000, 267.400000, 285.600000, 303.309091,
    266.900000, 205.775000, 186.288889, 181.622222, 130.511111, 120.650000,
    129.288889, 136.511111, 119.400000, 171.622222, 194.400000, 226.400000,
    216.400000, 226.800000, 226.900000, 272.844444, 238.000000, 223.200000,
    254.200000, 204.955556, 202.800000, 193.733333, 156.800000, 96.800000,
    22.511111, -22.100000, -47.100000, -96.377778, -94.600000, -77.933333,
    -32.100000, 29.400000, 132.100000, 152.844444, 178.800000, 46.400000,
    56.200000, 53.177778, 26.200000, 102.600000, 148.300000, 210.400000,
    335.400000, 255.400000, 257.400000, 196.300000, 148.500000, 126.400000 };
    
    int q1 = 162;
    int q2 = 202;
    fptype wmax = 35315.6;

    int peak_idx;

    __npda_offsetted_x_start = 2.326;
            
    iret = find_ac_quad(scany, q1, q2, wmax, &peak_idx);

  	TEST_ASSERT_EQUAL_INT(0, iret);
  	TEST_ASSERT_EQUAL_INT(181, peak_idx);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_quad()
 *
 * @test             This is to test whether the find_ac_quad()
 *                   function returns correct values when presented with normal
 *                   data, but q1 and q2 are at max limit. Checked against
 *                   findAC_quad_jr2()
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_quad_q1_q2_at_max_limit() //TODO: step over
{
    int iret;
    fptype scany[] = {467.066667, 522.622222, 501.400000, 527.400000, 543.400000,
    445.400000, 397.400000, 422.400000, 396.700000, 353.600000, 351.700000,
    406.900000, 480.622222, 551.200000, 654.200000, 733.000000, 756.000000,
    853.600000, 859.511111, 887.200000, 861.200000, 794.000000, 714.300000,
    674.000000, 645.400000, 637.400000, 626.000000, 659.800000, 703.000000,
    738.800000, 746.000000, 789.400000, 839.854545, 865.200000, 852.309091,
    840.945455, 821.800000, 779.763636, 815.490909, 796.400000, 825.490909,
    910.300000, 885.036364, 835.945455, 787.733333, 759.733333, 810.400000,
    802.525000, 790.733333, 839.177778, 965.288889, 1054.400000, 1071.400000,
    1078.763636, 1062.945455, 1031.581818, 1002.127273, 993.400000, 999.218182,
    1038.490909, 1117.036364, 1160.309091, 1191.100000, 1182.300000, 1131.177778,
    1151.844444, 1163.775000, 1256.622222, 1310.400000, 1342.066667, 1295.400000,
    1304.288889, 1252.511111, 1239.400000, 1236.900000, 1238.100000, 1224.733333,
    1266.200000, 1314.600000, 1367.800000, 1427.600000, 1445.177778, 1475.400000,
    1517.945455, 1538.309091, 1486.945455, 1402.600000, 1424.490909, 1332.127273,
    1259.400000, 1252.400000, 1224.218182, 1235.309091, 1315.200000, 1442.844444,
    1575.400000, 1699.400000, 1774.400000, 1831.400000, 1851.955556, 1902.400000,
    1957.066667, 2066.622222, 2277.400000, 2456.490909, 2639.036364, 2781.200000,
    2894.763636, 2968.400000, 3062.036364, 3171.600000, 3222.581818, 3270.672727,
    3348.733333, 3327.400000, 3292.733333, 3296.066667, 3358.066667, 3390.177778,
    3410.177778, 3420.400000, 3415.955556, 3344.400000, 3324.177778, 3276.700000,
    3193.800000, 3141.200000, 3017.500000, 2878.733333, 2750.200000, 2676.200000,
    2582.200000, 2463.800000, 2313.000000, 2182.400000, 2046.000000, 1895.200000,
    1774.000000, 1697.600000, 1618.000000, 1593.400000, 1635.000000, 1762.800000,
    1963.400000, 2166.400000, 2492.200000, 2829.800000, 3206.800000, 3701.800000,
    4141.800000, 4689.200000, 5165.200000, 5723.800000, 6535.200000, 7441.200000,
    8614.800000, 9870.800000, 11069.200000, 12294.800000, 13565.400000, 14861.200000,
    16186.400000, 17529.400000, 18972.955556, 20568.400000, 21983.400000, 23342.400000,
    24718.900000, 26041.900000, 27317.900000, 28659.400000, 29967.400000, 31060.900000,
    32019.400000, 32779.900000, 33447.900000, 34069.900000, 34553.900000, 34908.400000,
    35164.400000, 35310.288889, 35315.600000, 35190.200000, 34956.600000, 34583.800000,
    34041.600000, 33358.400000, 32605.300000, 31877.300000, 31071.200000, 30122.844444,
    29208.400000, 28263.800000, 27278.000000, 26211.400000, 24918.400000, 23644.955556,
    22449.300000, 21532.100000, 20287.800000, 19370.100000, 18375.200000, 17372.400000,
    16734.218182, 15900.900000, 15102.763636, 14410.581818, 13696.600000, 13067.854545,
    12464.200000, 11908.672727, 11480.900000, 11024.490909, 10463.400000, 9900.400000,
    9058.177778, 8557.066667, 8310.733333, 7926.400000, 7588.066667, 7294.288889,
    6990.733333, 6670.288889, 6398.672727, 6142.672727, 5835.700000, 5505.490909,
    5185.400000, 5026.672727, 4930.100000, 4814.581818, 4766.400000, 4641.400000,
    4423.218182, 4253.400000, 4021.844444, 3864.733333, 3643.775000, 3528.288889,
    3356.066667, 3121.400000, 2930.511111, 2651.400000, 2518.511111, 2459.200000,
    2433.955556, 2378.600000, 2313.400000, 2284.600000, 2187.511111, 2058.400000,
    1947.400000, 1829.955556, 1683.000000, 1512.400000, 1342.400000, 1161.600000,
    1054.600000, 958.900000, 958.900000, 1010.511111, 1003.800000, 1017.800000,
    982.400000, 941.200000, 964.511111, 900.000000, 879.800000, 864.000000,
    837.200000, 882.400000, 905.400000, 981.400000, 1042.900000, 1075.100000,
    1080.200000, 1065.400000, 1028.000000, 1006.400000, 998.800000, 954.400000,
    894.400000, 845.900000, 729.400000, 638.500000, 596.000000, 517.600000,
    473.900000, 472.400000, 473.200000};
    
    int q1 = 162;
    int q2 = 289;
    fptype wmax = 35315.6;

    int peak_idx;

    __npda_offsetted_x_start = 2.326;
            
    iret = find_ac_quad(scany, q1, q2, wmax, &peak_idx);

  	TEST_ASSERT_EQUAL_INT(0, iret);
  	TEST_ASSERT_EQUAL_INT(181, peak_idx);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_quad()
 *
 * @test             This is to test whether the find_ac_quad()
 *                   function returns error when q1 and q2 are too far, i.e.
 *                   such that active_members would not fit into MAX_AC_HHW.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_quad_q1_q2_too_far()
{
    int iret;
    fptype scany[] = {467.066667, 522.622222, 501.400000, 527.400000, 543.400000,
    445.400000, 397.400000, 422.400000, 396.700000, 353.600000, 351.700000,
    406.900000, 480.622222, 551.200000, 654.200000, 733.000000, 756.000000,
    853.600000, 859.511111, 887.200000, 861.200000, 794.000000, 714.300000,
    674.000000, 645.400000, 637.400000, 626.000000, 659.800000, 703.000000,
    738.800000, 746.000000, 789.400000, 839.854545, 865.200000, 852.309091,
    840.945455, 821.800000, 779.763636, 815.490909, 796.400000, 825.490909,
    910.300000, 885.036364, 835.945455, 787.733333, 759.733333, 810.400000,
    802.525000, 790.733333, 839.177778, 965.288889, 1054.400000, 1071.400000,
    1078.763636, 1062.945455, 1031.581818, 1002.127273, 993.400000, 999.218182,
    1038.490909, 1117.036364, 1160.309091, 1191.100000, 1182.300000, 1131.177778,
    1151.844444, 1163.775000, 1256.622222, 1310.400000, 1342.066667, 1295.400000,
    1304.288889, 1252.511111, 1239.400000, 1236.900000, 1238.100000, 1224.733333,
    1266.200000, 1314.600000, 1367.800000, 1427.600000, 1445.177778, 1475.400000,
    1517.945455, 1538.309091, 1486.945455, 1402.600000, 1424.490909, 1332.127273,
    1259.400000, 1252.400000, 1224.218182, 1235.309091, 1315.200000, 1442.844444,
    1575.400000, 1699.400000, 1774.400000, 1831.400000, 1851.955556, 1902.400000,
    1957.066667, 2066.622222, 2277.400000, 2456.490909, 2639.036364, 2781.200000,
    2894.763636, 2968.400000, 3062.036364, 3171.600000, 3222.581818, 3270.672727,
    3348.733333, 3327.400000, 3292.733333, 3296.066667, 3358.066667, 3390.177778,
    3410.177778, 3420.400000, 3415.955556, 3344.400000, 3324.177778, 3276.700000,
    3193.800000, 3141.200000, 3017.500000, 2878.733333, 2750.200000, 2676.200000,
    2582.200000, 2463.800000, 2313.000000, 2182.400000, 2046.000000, 1895.200000,
    1774.000000, 1697.600000, 1618.000000, 1593.400000, 1635.000000, 1762.800000,
    1963.400000, 2166.400000, 2492.200000, 2829.800000, 3206.800000, 3701.800000,
    4141.800000, 4689.200000, 5165.200000, 5723.800000, 6535.200000, 7441.200000,
    8614.800000, 9870.800000, 11069.200000, 12294.800000, 13565.400000, 14861.200000,
    16186.400000, 17529.400000, 18972.955556, 20568.400000, 21983.400000, 23342.400000,
    24718.900000, 26041.900000, 27317.900000, 28659.400000, 29967.400000, 31060.900000,
    32019.400000, 32779.900000, 33447.900000, 34069.900000, 34553.900000, 34908.400000,
    35164.400000, 35310.288889, 35315.600000, 35190.200000, 34956.600000, 34583.800000,
    34041.600000, 33358.400000, 32605.300000, 31877.300000, 31071.200000, 30122.844444,
    29208.400000, 28263.800000, 27278.000000, 26211.400000, 24918.400000, 23644.955556,
    22449.300000, 21532.100000, 20287.800000, 19370.100000, 18375.200000, 17372.400000,
    16734.218182, 15900.900000, 15102.763636, 14410.581818, 13696.600000, 13067.854545,
    12464.200000, 11908.672727, 11480.900000, 11024.490909, 10463.400000, 9900.400000,
    9058.177778, 8557.066667, 8310.733333, 7926.400000, 7588.066667, 7294.288889,
    6990.733333, 6670.288889, 6398.672727, 6142.672727, 5835.700000, 5505.490909,
    5185.400000, 5026.672727, 4930.100000, 4814.581818, 4766.400000, 4641.400000,
    4423.218182, 4253.400000, 4021.844444, 3864.733333, 3643.775000, 3528.288889,
    3356.066667, 3121.400000, 2930.511111, 2651.400000, 2518.511111, 2459.200000,
    2433.955556, 2378.600000, 2313.400000, 2284.600000, 2187.511111, 2058.400000,
    1947.400000, 1829.955556, 1683.000000, 1512.400000, 1342.400000, 1161.600000,
    1054.600000, 958.900000, 958.900000, 1010.511111, 1003.800000, 1017.800000,
    982.400000, 941.200000, 964.511111, 900.000000, 879.800000, 864.000000,
    837.200000, 882.400000, 905.400000, 981.400000, 1042.900000, 1075.100000,
    1080.200000, 1065.400000, 1028.000000, 1006.400000, 998.800000, 954.400000,
    894.400000, 845.900000, 729.400000, 638.500000, 596.000000, 517.600000,
    473.900000, 472.400000, 473.200000};
    
    int q1 = 162;
    int q2 = 290;
    fptype wmax = 35315.6;

    int peak_idx;

    __npda_offsetted_x_start = 2.326;
            
    iret = find_ac_quad(scany, q1, q2, wmax, &peak_idx);

  	TEST_ASSERT_EQUAL_INT(1, iret);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_quad()
 *
 * @test             This is to test whether the find_ac_quad()
 *                   function returns error when q1 and q2 are too close, i.e.
 *                   such that polyfit would not be able to fit to the data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_quad_q1_q2_too_close()
{
    int iret;
    fptype scany[] = {467.066667, 522.622222, 501.400000, 527.400000, 543.400000,
    445.400000, 397.400000, 422.400000, 396.700000, 353.600000, 351.700000,
    406.900000, 480.622222, 551.200000, 654.200000, 733.000000, 756.000000,
    853.600000, 859.511111, 887.200000, 861.200000, 794.000000, 714.300000,
    674.000000, 645.400000, 637.400000, 626.000000, 659.800000, 703.000000,
    738.800000, 746.000000, 789.400000, 839.854545, 865.200000, 852.309091,
    840.945455, 821.800000, 779.763636, 815.490909, 796.400000, 825.490909,
    910.300000, 885.036364, 835.945455, 787.733333, 759.733333, 810.400000,
    802.525000, 790.733333, 839.177778, 965.288889, 1054.400000, 1071.400000,
    1078.763636, 1062.945455, 1031.581818, 1002.127273, 993.400000, 999.218182,
    1038.490909, 1117.036364, 1160.309091, 1191.100000, 1182.300000, 1131.177778,
    1151.844444, 1163.775000, 1256.622222, 1310.400000, 1342.066667, 1295.400000,
    1304.288889, 1252.511111, 1239.400000, 1236.900000, 1238.100000, 1224.733333,
    1266.200000, 1314.600000, 1367.800000, 1427.600000, 1445.177778, 1475.400000,
    1517.945455, 1538.309091, 1486.945455, 1402.600000, 1424.490909, 1332.127273,
    1259.400000, 1252.400000, 1224.218182, 1235.309091, 1315.200000, 1442.844444,
    1575.400000, 1699.400000, 1774.400000, 1831.400000, 1851.955556, 1902.400000,
    1957.066667, 2066.622222, 2277.400000, 2456.490909, 2639.036364, 2781.200000,
    2894.763636, 2968.400000, 3062.036364, 3171.600000, 3222.581818, 3270.672727,
    3348.733333, 3327.400000, 3292.733333, 3296.066667, 3358.066667, 3390.177778,
    3410.177778, 3420.400000, 3415.955556, 3344.400000, 3324.177778, 3276.700000,
    3193.800000, 3141.200000, 3017.500000, 2878.733333, 2750.200000, 2676.200000,
    2582.200000, 2463.800000, 2313.000000, 2182.400000, 2046.000000, 1895.200000,
    1774.000000, 1697.600000, 1618.000000, 1593.400000, 1635.000000, 1762.800000,
    1963.400000, 2166.400000, 2492.200000, 2829.800000, 3206.800000, 3701.800000,
    4141.800000, 4689.200000, 5165.200000, 5723.800000, 6535.200000, 7441.200000,
    8614.800000, 9870.800000, 11069.200000, 12294.800000, 13565.400000, 14861.200000,
    16186.400000, 17529.400000, 18972.955556, 20568.400000, 21983.400000, 23342.400000,
    24718.900000, 26041.900000, 27317.900000, 28659.400000, 29967.400000, 31060.900000,
    32019.400000, 32779.900000, 33447.900000, 34069.900000, 34553.900000, 34908.400000,
    35164.400000, 35310.288889, 35315.600000, 35190.200000, 34956.600000, 34583.800000,
    34041.600000, 33358.400000, 32605.300000, 31877.300000, 31071.200000, 30122.844444,
    29208.400000, 28263.800000, 27278.000000, 26211.400000, 24918.400000, 23644.955556,
    22449.300000, 21532.100000, 20287.800000, 19370.100000, 18375.200000, 17372.400000,
    16734.218182, 15900.900000, 15102.763636, 14410.581818, 13696.600000, 13067.854545,
    12464.200000, 11908.672727, 11480.900000, 11024.490909, 10463.400000, 9900.400000,
    9058.177778, 8557.066667, 8310.733333, 7926.400000, 7588.066667, 7294.288889,
    6990.733333, 6670.288889, 6398.672727, 6142.672727, 5835.700000, 5505.490909,
    5185.400000, 5026.672727, 4930.100000, 4814.581818, 4766.400000, 4641.400000,
    4423.218182, 4253.400000, 4021.844444, 3864.733333, 3643.775000, 3528.288889,
    3356.066667, 3121.400000, 2930.511111, 2651.400000, 2518.511111, 2459.200000,
    2433.955556, 2378.600000, 2313.400000, 2284.600000, 2187.511111, 2058.400000,
    1947.400000, 1829.955556, 1683.000000, 1512.400000, 1342.400000, 1161.600000,
    1054.600000, 958.900000, 958.900000, 1010.511111, 1003.800000, 1017.800000,
    982.400000, 941.200000, 964.511111, 900.000000, 879.800000, 864.000000,
    837.200000, 882.400000, 905.400000, 981.400000, 1042.900000, 1075.100000,
    1080.200000, 1065.400000, 1028.000000, 1006.400000, 998.800000, 954.400000,
    894.400000, 845.900000, 729.400000, 638.500000, 596.000000, 517.600000,
    473.900000, 472.400000, 473.200000};
    
    int q1 = 162;
    int q2 = 163;
    fptype wmax = 35315.6;

    int peak_idx;

    __npda_offsetted_x_start = 2.326;
            
    iret = find_ac_quad(scany, q1, q2, wmax, &peak_idx);

  	TEST_ASSERT_EQUAL_INT(11, iret);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_quad()
 *
 * @test             This is to test whether the find_ac_quad()
 *                   function returns error when there are not enough active
 *                   members in the data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_quad_not_enough_active_members()
{
    int iret;
    fptype scany[] = {0.0, 200.0, 501.0, 1000.0, 502.0, 0.0};
    
    int q1 = 2;
    int q2 = 4;
    fptype wmax = 1000.0;

    int peak_idx;

    __npda_offsetted_x_start = 2.326;
            
    iret = find_ac_quad(scany, q1, q2, wmax, &peak_idx);

  	TEST_ASSERT_EQUAL_INT(21, iret);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_quad()
 *
 * @test             This is to test whether the find_ac_quad()
 *                   function returns error when the peak is inverted.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_quad_data_inverted_peak()
{
    int iret;
    fptype scany[] = {0.0, 200.0, 701.0, 601.0, 701.0, 0.0};
    
    int q1 = 2;
    int q2 = 4;
    fptype wmax = 1000.0;

    int peak_idx;

    __npda_offsetted_x_start = 2.326;
            
    iret = find_ac_quad(scany, q1, q2, wmax, &peak_idx);

  	TEST_ASSERT_EQUAL_INT(31, iret);
}

/* ************************************************************************** */
/** 
 * @brief            find_ac_quad()
 *
 * @test             This is to test whether the find_ac_quad()
 *                   function returns error when the peak is outside [q1, q2]
 *                   window.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_ac_quad_peak_outside_q1_q2()
{
    int iret;
    fptype scany[] = {0.0, 200.0, 501.0, 601.0, 681.0, 0.0};
    
    int q1 = 2;
    int q2 = 4;
    fptype wmax = 1000.0;

    int peak_idx;

    __npda_offsetted_x_start = 2.326;
            
    iret = find_ac_quad(scany, q1, q2, wmax, &peak_idx);

  	TEST_ASSERT_EQUAL_INT(41, iret);
}

/* ************************************************************************** */
/** 
 * @brief            average_incremental()
 *
 * @test             This is to test whether the average_incremental()
 *                   function returns correct values when scan count is 0 and 
 *                   offset is positive
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_average_incremental_averages_correctly_when_valid_scan_cnt_0_offset_positive()
{
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    int offset = 1;
    int valid_scan_cnt = 0;
    fptype scany[] = {1, 1, 1, 1};
    int scany_len = 4;
    uint16_t npda_avg_len;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);

  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0, __npda_avg[0]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1, __npda_avg[1]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1, __npda_avg[4]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0, __npda_avg[5]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0, __npda_avg[MAX_WINDOW_SIZE-1]);
  	TEST_ASSERT_EQUAL_UINT(5, npda_avg_len);
}

/* ************************************************************************** */
/** 
 * @brief            average_incremental()
 *
 * @test             This is to test whether the average_incremental()
 *                   function returns correct values when scan count is 0 and 
 *                   offset is 0.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_average_incremental_averages_correctly_when_valid_scan_cnt_0_offset_0()
{
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    int offset = 0;
    int valid_scan_cnt = 0;
    fptype scany[] = {1, 1, 1, 1};
    int scany_len = 4;
    uint16_t npda_avg_len;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);

  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1, __npda_avg[0]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1, __npda_avg[3]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0, __npda_avg[4]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0, __npda_avg[MAX_WINDOW_SIZE-1]);
  	TEST_ASSERT_EQUAL_UINT(4, npda_avg_len);
}

/* ************************************************************************** */
/** 
 * @brief            average_incremental()
 *
 * @test             This is to test whether the average_incremental()
 *                   function returns correct values when scan count is 0 and 
 *                   offset is negative.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_average_incremental_averages_correctly_when_valid_scan_cnt_0_offset_negative()
{
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    int offset = -2;
    int valid_scan_cnt = 0;
    fptype scany[] = {1, 1, 1, 1};
    int scany_len = 4;
    uint16_t npda_avg_len;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);

  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1, __npda_avg[0]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1, __npda_avg[1]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0, __npda_avg[2]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0, __npda_avg[MAX_WINDOW_SIZE-1]);
  	TEST_ASSERT_EQUAL_UINT(2, npda_avg_len);
}

/* ************************************************************************** */
/** 
 * @brief            average_incremental()
 *
 * @test             This is to test whether the average_incremental()
 *                   function returns correct values when scan count is 0 and 
 *                   offset is so large that end of scan exceeds avg_scan array.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_average_incremental_averages_correctly_when_valid_scan_cnt_0_offset_large()
{
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    int offset = 998;
    int valid_scan_cnt = 0;
    fptype scany[] = {1, 1, 1, 1};
    int scany_len = 4;
    uint16_t npda_avg_len;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);

  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0, __npda_avg[997]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1, __npda_avg[998]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1, __npda_avg[MAX_WINDOW_SIZE-1]);
  	TEST_ASSERT_EQUAL_UINT(1000, npda_avg_len);
}

/* ************************************************************************** */
/** 
 * @brief            average_incremental()
 *
 * @test             This is to test whether the average_incremental()
 *                   function returns correct values when scan count is not 0 
 *                   and offset is positive
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_average_incremental_averages_correctly_when_valid_scan_cnt_not_0_offset_positive()
{
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    int offset = 1;
    int valid_scan_cnt = 0;
    fptype scany[] = {1, 1, 1, 1};
    int scany_len = 4;
    uint16_t npda_avg_len;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);

    offset = 2;
    valid_scan_cnt = 1;
    scany[0] = 2;
    scany[1] = 2;
    scany[2] = 2;
    scany[3] = 2;
    scany_len = 4;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);
    
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.0, __npda_avg[0]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.0, __npda_avg[1]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.5, __npda_avg[3]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.5, __npda_avg[4]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.0, __npda_avg[5]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.0, __npda_avg[6]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.0, __npda_avg[MAX_WINDOW_SIZE-1]);
  	TEST_ASSERT_EQUAL_UINT(5, npda_avg_len);
}

/* ************************************************************************** */
/** 
 * @brief            average_incremental()
 *
 * @test             This is to test whether the average_incremental()
 *                   function returns correct values when scan count is not 0 
 *                   and offset is 0.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_average_incremental_averages_correctly_when_valid_scan_cnt_not_0_offset_0()
{
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    int offset = 1;
    int valid_scan_cnt = 0;
    fptype scany[] = {1, 1, 1, 1};
    int scany_len = 4;
    uint16_t npda_avg_len;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);

    offset = 0;
    valid_scan_cnt = 1;
    scany[0] = 2;
    scany[1] = 2;
    scany[2] = 2;
    scany[3] = 2;
    scany_len = 4;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);
    
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.0, __npda_avg[0]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.5, __npda_avg[1]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.5, __npda_avg[3]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.0, __npda_avg[4]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.0, __npda_avg[5]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.0, __npda_avg[MAX_WINDOW_SIZE-1]);
  	TEST_ASSERT_EQUAL_UINT(4, npda_avg_len);
}

/* ************************************************************************** */
/** 
 * @brief            average_incremental()
 *
 * @test             This is to test whether the average_incremental()
 *                   function returns correct values when scan count is not 0 
 *                   and offset is negative.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_average_incremental_averages_correctly_when_valid_scan_cnt_not_0_offset_negative()
{
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    int offset = 1;
    int valid_scan_cnt = 0;
    fptype scany[] = {1, 1, 1, 1};
    int scany_len = 4;
    uint16_t npda_avg_len;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);

    offset = -2;
    valid_scan_cnt = 1;
    scany[0] = 2;
    scany[1] = 2;
    scany[2] = 2;
    scany[3] = 2;
    scany_len = 4;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);
    
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.0, __npda_avg[0]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.5, __npda_avg[1]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.0, __npda_avg[2]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.0, __npda_avg[4]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.0, __npda_avg[5]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.0, __npda_avg[MAX_WINDOW_SIZE-1]);
  	TEST_ASSERT_EQUAL_UINT(2, npda_avg_len);
}

/* ************************************************************************** */
/** 
 * @brief            average_incremental()
 *
 * @test             This is to test whether the average_incremental()
 *                   function returns correct values when scan count is not 0 and 
 *                   offset is so large that end of scan exceeds avg_scan array.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_average_incremental_averages_correctly_when_valid_scan_cnt_not_0_offset_large()
{
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    int offset = 998;
    int valid_scan_cnt = 0;
    fptype scany[] = {1, 1, 1, 1};
    int scany_len = 4;
    uint16_t npda_avg_len;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);

    offset = 997;
    valid_scan_cnt = 1;
    scany[0] = 2;
    scany[1] = 2;
    scany[2] = 2;
    scany[3] = 2;
    scany_len = 4;

    average_incremental(scany, scany_len, valid_scan_cnt, offset, &npda_avg_len);
    
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.0, __npda_avg[997]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.5, __npda_avg[998]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 1.5, __npda_avg[MAX_WINDOW_SIZE-1]);
   	TEST_ASSERT_EQUAL_UINT(1000, npda_avg_len);

}

/* ************************************************************************** */
/** 
 * @brief            update_average()
 *
 * @test             This is to test whether the update_average()
 *                   function returns correct values when presented with scan 
 *                   data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_update_average_correct_values()
{
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    int iret;
    fptype scany [] = {467.066667, 522.622222, 501.400000, 527.400000, 543.400000,
    445.400000, 397.400000, 422.400000, 396.700000, 353.600000, 351.700000,
    406.900000, 480.622222, 551.200000, 654.200000, 733.000000, 756.000000,
    853.600000, 859.511111, 887.200000, 861.200000, 794.000000, 714.300000,
    674.000000, 645.400000, 637.400000, 626.000000, 659.800000, 703.000000,
    738.800000, 746.000000, 789.400000, 839.854545, 865.200000, 852.309091,
    840.945455, 821.800000, 779.763636, 815.490909, 796.400000, 825.490909,
    910.300000, 885.036364, 835.945455, 787.733333, 759.733333, 810.400000,
    802.525000, 790.733333, 839.177778, 965.288889, 1054.400000, 1071.400000,
    1078.763636, 1062.945455, 1031.581818, 1002.127273, 993.400000, 999.218182,
    1038.490909, 1117.036364, 1160.309091, 1191.100000, 1182.300000, 1131.177778,
    1151.844444, 1163.775000, 1256.622222, 1310.400000, 1342.066667, 1295.400000,
    1304.288889, 1252.511111, 1239.400000, 1236.900000, 1238.100000, 1224.733333,
    1266.200000, 1314.600000, 1367.800000, 1427.600000, 1445.177778, 1475.400000,
    1517.945455, 1538.309091, 1486.945455, 1402.600000, 1424.490909, 1332.127273,
    1259.400000, 1252.400000, 1224.218182, 1235.309091, 1315.200000, 1442.844444,
    1575.400000, 1699.400000, 1774.400000, 1831.400000, 1851.955556, 1902.400000,
    1957.066667, 2066.622222, 2277.400000, 2456.490909, 2639.036364, 2781.200000,
    2894.763636, 2968.400000, 3062.036364, 3171.600000, 3222.581818, 3270.672727,
    3348.733333, 3327.400000, 3292.733333, 3296.066667, 3358.066667, 3390.177778,
    3410.177778, 3420.400000, 3415.955556, 3344.400000, 3324.177778, 3276.700000,
    3193.800000, 3141.200000, 3017.500000, 2878.733333, 2750.200000, 2676.200000,
    2582.200000, 2463.800000, 2313.000000, 2182.400000, 2046.000000, 1895.200000,
    1774.000000, 1697.600000, 1618.000000, 1593.400000, 1635.000000, 1762.800000,
    1963.400000, 2166.400000, 2492.200000, 2829.800000, 3206.800000, 3701.800000,
    4141.800000, 4689.200000, 5165.200000, 5723.800000, 6535.200000, 7441.200000,
    8614.800000, 9870.800000, 11069.200000, 12294.800000, 13565.400000, 14861.200000,
    16186.400000, 17529.400000, 18972.955556, 20568.400000, 21983.400000, 23342.400000,
    24718.900000, 26041.900000, 27317.900000, 28659.400000, 29967.400000, 31060.900000,
    32019.400000, 32779.900000, 33447.900000, 34069.900000, 34553.900000, 34908.400000,
    35164.400000, 35310.288889, 35315.600000, 35190.200000, 34956.600000, 34583.800000,
    34041.600000, 33358.400000, 32605.300000, 31877.300000, 31071.200000, 30122.844444,
    29208.400000, 28263.800000, 27278.000000, 26211.400000, 24918.400000, 23644.955556,
    22449.300000, 21532.100000, 20287.800000, 19370.100000, 18375.200000, 17372.400000,
    16734.218182, 15900.900000, 15102.763636, 14410.581818, 13696.600000, 13067.854545,
    12464.200000, 11908.672727, 11480.900000, 11024.490909, 10463.400000, 9900.400000,
    9058.177778, 8557.066667, 8310.733333, 7926.400000, 7588.066667, 7294.288889,
    6990.733333, 6670.288889, 6398.672727, 6142.672727, 5835.700000, 5505.490909,
    5185.400000, 5026.672727, 4930.100000, 4814.581818, 4766.400000, 4641.400000,
    4423.218182, 4253.400000, 4021.844444, 3864.733333, 3643.775000, 3528.288889,
    3356.066667, 3121.400000, 2930.511111, 2651.400000, 2518.511111, 2459.200000,
    2433.955556, 2378.600000, 2313.400000, 2284.600000, 2187.511111, 2058.400000,
    1947.400000, 1829.955556, 1683.000000, 1512.400000, 1342.400000, 1161.600000,
    1054.600000, 958.900000, 958.900000, 1010.511111, 1003.800000, 1017.800000,
    982.400000, 941.200000, 964.511111, 900.000000, 879.800000, 864.000000,
    837.200000, 882.400000, 905.400000, 981.400000, 1042.900000, 1075.100000,
    1080.200000, 1065.400000, 1028.000000, 1006.400000, 998.800000, 954.400000,
    894.400000, 845.900000, 729.400000, 638.500000, 596.000000, 517.600000,
    473.900000, 472.400000, 473.200000, 457.000000, 498.600000, 542.200000,
    523.490909, 454.000000, 384.854545, 357.036364, 239.218182, 247.400000,
    239.400000, 356.672727, 321.763636, 408.200000, 481.127273, 534.400000,
    538.400000, 533.511111, 442.900000, 455.511111, 430.025000, 439.511111,
    428.622222, 485.300000, 483.177778, 475.600000, 465.400000, 378.955556,
    360.400000, 382.000000, 347.000000, 385.400000, 382.066667, 369.490909,
    356.218182, 297.700000, 263.945455, 208.200000, 192.127273, 138.100000,
    105.309091, 74.400000, 74.400000, 142.581818, 131.400000, 158.200000,
    182.288889, 122.066667, 135.733333, 120.622222, 130.275000, 203.288889,
    264.844444, 307.400000, 356.400000, 345.400000, 370.854545, 327.500000,
    307.672727, 316.036364, 273.500000, 267.400000, 285.600000, 303.309091,
    266.900000, 205.775000, 186.288889, 181.622222, 130.511111, 120.650000,
    129.288889, 136.511111, 119.400000, 171.622222, 194.400000, 226.400000,
    216.400000, 226.800000, 226.900000, 272.844444, 238.000000, 223.200000,
    254.200000, 204.955556, 202.800000, 193.733333, 156.800000, 96.800000,
    22.511111, -22.100000, -47.100000, -96.377778, -94.600000, -77.933333,
    -32.100000, 29.400000, 132.100000, 152.844444, 178.800000, 46.400000,
    56.200000, 53.177778, 26.200000, 102.600000, 148.300000, 210.400000,
    335.400000, 255.400000, 257.400000, 196.300000, 148.500000, 126.400000};
    int scany_len = 401;
    int valid_scan_cnt = 0;
    int med = 5;
    uint16_t npda_avg_len;
    
    iret = update_average(scany, scany_len, (fptype)med, valid_scan_cnt, &npda_avg_len);
    
    TEST_ASSERT_EQUAL_INT(0, iret);
    
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.0, __npda_avg[18]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 462.066667, __npda_avg[19]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 121.4, __npda_avg[419]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.0, __npda_avg[420]);
    TEST_ASSERT_EQUAL_UINT(420, npda_avg_len);

    fptype scany2 [] = {6.0, 467.066667, 522.622222, 501.400000, 527.400000, 543.400000,
    445.400000, 397.400000, 422.400000, 396.700000, 353.600000, 351.700000,
    406.900000, 480.622222, 551.200000, 654.200000, 733.000000, 756.000000,
    853.600000, 859.511111, 887.200000, 861.200000, 794.000000, 714.300000,
    674.000000, 645.400000, 637.400000, 626.000000, 659.800000, 703.000000,
    738.800000, 746.000000, 789.400000, 839.854545, 865.200000, 852.309091,
    840.945455, 821.800000, 779.763636, 815.490909, 796.400000, 825.490909,
    910.300000, 885.036364, 835.945455, 787.733333, 759.733333, 810.400000,
    802.525000, 790.733333, 839.177778, 965.288889, 1054.400000, 1071.400000,
    1078.763636, 1062.945455, 1031.581818, 1002.127273, 993.400000, 999.218182,
    1038.490909, 1117.036364, 1160.309091, 1191.100000, 1182.300000, 1131.177778,
    1151.844444, 1163.775000, 1256.622222, 1310.400000, 1342.066667, 1295.400000,
    1304.288889, 1252.511111, 1239.400000, 1236.900000, 1238.100000, 1224.733333,
    1266.200000, 1314.600000, 1367.800000, 1427.600000, 1445.177778, 1475.400000,
    1517.945455, 1538.309091, 1486.945455, 1402.600000, 1424.490909, 1332.127273,
    1259.400000, 1252.400000, 1224.218182, 1235.309091, 1315.200000, 1442.844444,
    1575.400000, 1699.400000, 1774.400000, 1831.400000, 1851.955556, 1902.400000,
    1957.066667, 2066.622222, 2277.400000, 2456.490909, 2639.036364, 2781.200000,
    2894.763636, 2968.400000, 3062.036364, 3171.600000, 3222.581818, 3270.672727,
    3348.733333, 3327.400000, 3292.733333, 3296.066667, 3358.066667, 3390.177778,
    3410.177778, 3420.400000, 3415.955556, 3344.400000, 3324.177778, 3276.700000,
    3193.800000, 3141.200000, 3017.500000, 2878.733333, 2750.200000, 2676.200000,
    2582.200000, 2463.800000, 2313.000000, 2182.400000, 2046.000000, 1895.200000,
    1774.000000, 1697.600000, 1618.000000, 1593.400000, 1635.000000, 1762.800000,
    1963.400000, 2166.400000, 2492.200000, 2829.800000, 3206.800000, 3701.800000,
    4141.800000, 4689.200000, 5165.200000, 5723.800000, 6535.200000, 7441.200000,
    8614.800000, 9870.800000, 11069.200000, 12294.800000, 13565.400000, 14861.200000,
    16186.400000, 17529.400000, 18972.955556, 20568.400000, 21983.400000, 23342.400000,
    24718.900000, 26041.900000, 27317.900000, 28659.400000, 29967.400000, 31060.900000,
    32019.400000, 32779.900000, 33447.900000, 34069.900000, 34553.900000, 34908.400000,
    35164.400000, 35310.288889, 35315.600000, 35190.200000, 34956.600000, 34583.800000,
    34041.600000, 33358.400000, 32605.300000, 31877.300000, 31071.200000, 30122.844444,
    29208.400000, 28263.800000, 27278.000000, 26211.400000, 24918.400000, 23644.955556,
    22449.300000, 21532.100000, 20287.800000, 19370.100000, 18375.200000, 17372.400000,
    16734.218182, 15900.900000, 15102.763636, 14410.581818, 13696.600000, 13067.854545,
    12464.200000, 11908.672727, 11480.900000, 11024.490909, 10463.400000, 9900.400000,
    9058.177778, 8557.066667, 8310.733333, 7926.400000, 7588.066667, 7294.288889,
    6990.733333, 6670.288889, 6398.672727, 6142.672727, 5835.700000, 5505.490909,
    5185.400000, 5026.672727, 4930.100000, 4814.581818, 4766.400000, 4641.400000,
    4423.218182, 4253.400000, 4021.844444, 3864.733333, 3643.775000, 3528.288889,
    3356.066667, 3121.400000, 2930.511111, 2651.400000, 2518.511111, 2459.200000,
    2433.955556, 2378.600000, 2313.400000, 2284.600000, 2187.511111, 2058.400000,
    1947.400000, 1829.955556, 1683.000000, 1512.400000, 1342.400000, 1161.600000,
    1054.600000, 958.900000, 958.900000, 1010.511111, 1003.800000, 1017.800000,
    982.400000, 941.200000, 964.511111, 900.000000, 879.800000, 864.000000,
    837.200000, 882.400000, 905.400000, 981.400000, 1042.900000, 1075.100000,
    1080.200000, 1065.400000, 1028.000000, 1006.400000, 998.800000, 954.400000,
    894.400000, 845.900000, 729.400000, 638.500000, 596.000000, 517.600000,
    473.900000, 472.400000, 473.200000, 457.000000, 498.600000, 542.200000,
    523.490909, 454.000000, 384.854545, 357.036364, 239.218182, 247.400000,
    239.400000, 356.672727, 321.763636, 408.200000, 481.127273, 534.400000,
    538.400000, 533.511111, 442.900000, 455.511111, 430.025000, 439.511111,
    428.622222, 485.300000, 483.177778, 475.600000, 465.400000, 378.955556,
    360.400000, 382.000000, 347.000000, 385.400000, 382.066667, 369.490909,
    356.218182, 297.700000, 263.945455, 208.200000, 192.127273, 138.100000,
    105.309091, 74.400000, 74.400000, 142.581818, 131.400000, 158.200000,
    182.288889, 122.066667, 135.733333, 120.622222, 130.275000, 203.288889,
    264.844444, 307.400000, 356.400000, 345.400000, 370.854545, 327.500000,
    307.672727, 316.036364, 273.500000, 267.400000, 285.600000, 303.309091,
    266.900000, 205.775000, 186.288889, 181.622222, 130.511111, 120.650000,
    129.288889, 136.511111, 119.400000, 171.622222, 194.400000, 226.400000,
    216.400000, 226.800000, 226.900000, 272.844444, 238.000000, 223.200000,
    254.200000, 204.955556, 202.800000, 193.733333, 156.800000, 96.800000,
    22.511111, -22.100000, -47.100000, -96.377778, -94.600000, -77.933333,
    -32.100000, 29.400000, 132.100000, 152.844444, 178.800000, 46.400000,
    56.200000, 53.177778, 26.200000, 102.600000, 148.300000, 210.400000,
    335.400000, 255.400000, 257.400000, 196.300000, 148.500000, 136.400000};
    scany_len = 402;
    valid_scan_cnt = 1;
    med = 5;

    iret = update_average(scany2, scany_len, (fptype)med, valid_scan_cnt, &npda_avg_len);
    
    TEST_ASSERT_EQUAL_INT(0, iret);

  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.5, __npda_avg[18]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 462.066667, __npda_avg[19]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 126.4, __npda_avg[419]);
  	TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.0, __npda_avg[420]);
    TEST_ASSERT_EQUAL_UINT(420, npda_avg_len);
}

/* ************************************************************************** */
/** 
 * @brief            update_average()
 *
 * @test             This is to test whether the update_average()
 *                   function returns error when maximum value is too far to
 *                   the left.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_update_average_returns_error_maxpos_to_left()
{
    int iret;
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    fptype scany [] = {200.0, 150.0, 100.0, 50.0};
    int scany_len = 4;
    int valid_scan_cnt = 0;
    int med = 5;
    uint16_t npda_avg_len;
    
    iret = update_average(scany, scany_len, (fptype)med, valid_scan_cnt, &npda_avg_len);
    
    TEST_ASSERT_EQUAL_INT(1, iret);

}

/* ************************************************************************** */
/** 
 * @brief            update_average()
 *
 * @test             This is to test whether the update_average()
 *                   function returns error when maximum value is too far to
 *                   the right.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_update_average_returns_error_maxpos_to_right()
{
    int iret;
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    fptype scany [] = {50.0, 100.0, 150.0, 200.0};
    int scany_len = 4;
    int valid_scan_cnt = 0;
    int med = 5;
    uint16_t npda_avg_len;
    
    iret = update_average(scany, scany_len, (fptype)med, valid_scan_cnt, &npda_avg_len);
    
    TEST_ASSERT_EQUAL_INT(1, iret);
}

/* ************************************************************************** */
/** 
 * @brief            update_average()
 *
 * @test             This is to test whether the update_average()
 *                   function returns error when q1 is too far to the left.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_update_average_returns_error_q2_too_far_to_right()
{
    int iret;
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    fptype scany [] = {50.0, 100.0, 150.0, 100.0};
    int scany_len = 4;
    int valid_scan_cnt = 0;
    int med = 5;
    uint16_t npda_avg_len;
    
    iret = update_average(scany, scany_len, (fptype)med, valid_scan_cnt, &npda_avg_len);
    
    TEST_ASSERT_EQUAL_INT(12, iret);
}

/* ************************************************************************** */
/** 
 * @brief            update_average()
 *
 * @test             This is to test whether the update_average()
 *                   function returns error when q1 and q2 are too far apart.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_update_average_q1_q2_too_far()
{
    int iret;
    memset(__npda_avg, 1, MAX_WINDOW_SIZE*sizeof(fptype));
    fptype scany [200];
    int i;
    for(i=0; i<200; i++)
    {
        scany[i] = 200;
    }
    scany[0] = 10;
    scany[1] = 10;
    scany[120] = 210;
    scany[198] = 10;
    scany[199] = 10;
    int scany_len = 200;
    int valid_scan_cnt = 0;
    int med = 5;
    uint16_t npda_avg_len;
    
    iret = update_average(scany, scany_len, (fptype)med, valid_scan_cnt, &npda_avg_len);
    
    TEST_ASSERT_EQUAL_INT(21, iret);
}

/* ************************************************************************** */
/** 
 * @brief            vmax()
 *
 * @test             This is to test whether the vmax()
 *                   function returns correct values when presented with 
 *                   "normal" data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_vmax_normal_data()
{
    fptype vector[] = {0.0, 2.0, 3.1, 1.2};
    int vector_len = 4;
    int maxpos;
    
    fptype v_max = vmax(vector, vector_len, &maxpos);

    TEST_ASSERT_EQUAL_INT(2, maxpos);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, 3.1, v_max);
}

/* ************************************************************************** */
/** 
 * @brief            vmax()
 *
 * @test             This is to test whether the vmax()
 *                   function returns correct values when presented with 
 *                   peak in the leftmost idx.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_vmax_peak_to_the_left()
{
    fptype vector[] = {4.21, 2.0, 3.1, 1.2};
    int vector_len = 4;
    int maxpos;
    
    fptype v_max = vmax(vector, vector_len, &maxpos);

    TEST_ASSERT_EQUAL_INT(0, maxpos);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, 4.21, v_max);
}

/* ************************************************************************** */
/** 
 * @brief            vmax()
 *
 * @test             This is to test whether the vmax()
 *                   function returns correct values when presented with 
 *                   peak in the rightmost idx.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_vmax_peak_to_the_right()
{
    fptype vector[] = {0.0, 2.0, 3.1, 4.21};
    int vector_len = 4;
    int maxpos;
    
    fptype v_max = vmax(vector, vector_len, &maxpos);

    TEST_ASSERT_EQUAL_INT(3, maxpos);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, 4.21, v_max);
}

/* ************************************************************************** */
/** 
 * @brief            vmax()
 *
 * @test             This is to test whether the vmax()
 *                   function returns correct values when presented with 
 *                   two peaks.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_vmax_double_peak()
{
    fptype vector[] = {0.0, 4.21, 3.1, 4.21};
    int vector_len = 4;
    int maxpos;
    
    fptype v_max = vmax(vector, vector_len, &maxpos);

    TEST_ASSERT_EQUAL_INT(1, maxpos);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, 4.21, v_max);
}

/* ************************************************************************** */
/** 
 * @brief            conv()
 *
 * @test             This is to test whether the conv()
 *                   function returns correct values when presented with 
 *                   two sets of sample data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_conv_sample_data()
{
    fptype a_vect[] = {0.042892140170877, 0.045044869127107, 0.047823178891416, 0.047064734446971, 0.047050345558083, 0.047188204143941,
0.048166040844278, 0.048800020642258, 0.050603616601854, 0.051585005490743, 0.053586047578285, 0.054622121652359,
0.054167448251685, 0.052332591349328, 0.050827239497476, 0.049596582931820, 0.048167795053031, 0.044856067780305,
0.044020970137207, 0.043907645221382, 0.045189874177612, 0.048358894379632, 0.050226821989059, 0.053295357342595,
0.055544377544615, 0.056372296736534, 0.056437273167510, 0.055323547578284, 0.052845737813975, 0.050849894379632,
0.050525448251686, 0.050745677207915, 0.052969609867847, 0.054660471820710, 0.058287593032830, 0.061228586298824,
0.064606623335861, 0.065293360709598, 0.066189986972224, 0.066476263066499, 0.065313055995793, 0.066216909531147,
0.067400364076601, 0.067133185625422, 0.066001603133840, 0.066632678891416, 0.067262081248319, 0.069897017275255,
0.072392030743269, 0.074766404480642, 0.077932840507577, 0.082476488655727, 0.086633609867847, 0.089949327039565,
0.093290653638891, 0.094483306837544, 0.093824347241584, 0.093317998756736, 0.091724589665826, 0.091251246231484,
0.093325744547982, 0.094306350608588, 0.092816498756735, 0.093815670473908, 0.094489353975591, 0.094238081248318,
0.094213126702864, 0.095282922999160, 0.096489960036197, 0.097458343874581, 0.097993756332494, 0.098442581248319,
0.099489946568184, 0.100502027376264, 0.100448892696130, 0.100540694042932, 0.102254296736534, 0.102007717611954,
0.101756013908251, 0.103441764750002, 0.105880458352696, 0.109280566096803, 0.112945367443605, 0.117716128386366,
0.121948343874581, 0.125760396063134, 0.130209973504211, 0.134380997073234, 0.137092862393100, 0.138303885962124,
0.142417098083336, 0.146229057679295, 0.149078202460441, 0.152192495389733, 0.154010296736534, 0.156529825356063,
0.158667643537881, 0.162852209194447, 0.167059724345962, 0.170340741180978, 0.171007710877948, 0.173238986972225,
0.175324919632157, 0.175966694042931, 0.175079077881315, 0.173898619968857, 0.173295374177611, 0.170854855659093,
0.170225677207915, 0.170762465086702, 0.171969374177611, 0.173862626702863, 0.176062997073234, 0.179777071147309,
0.186253434783672, 0.192895333773571, 0.197591050945288, 0.201716061046298, 0.205690444884682, 0.210849333773571,
0.216943630069868, 0.223850296736534, 0.233455333773571, 0.241923434783672, 0.250181084615323, 0.258579037477275,
0.269037677207913, 0.278495057679294, 0.287965690675926, 0.297042667106903, 0.305834848925085, 0.314485454985691,
0.323971481921717, 0.334018815255051, 0.344974148588383, 0.356389111551347, 0.365504222662459, 0.372936296736533,
0.380475852292088, 0.387951778218013, 0.394809407847645, 0.400168963403199, 0.404450222662459, 0.406833555995793,
0.409602667106903, 0.412336000440237, 0.412976667106904, 0.413503333773570, 0.412723481921718, 0.411077111551348,
0.407720667106904, 0.404005481921719, 0.400178000440238, 0.396463185625423, 0.390386593032832, 0.384226444884684,
0.379855212561451, 0.376328667106905, 0.374643636803875, 0.374059151955390, 0.374722970137207, 0.378548182258418,
0.385153576197811, 0.398815636803868, 0.417622545894776, 0.442826404480633, 0.474328970137197, 0.511791697409922,
0.553195353975572, 0.599257798420019, 0.652782397746615, 0.719490788318994, 0.797876909531110, 0.888201286635493,
0.977680586298792, 1.082783353975535, 1.193547623335808, 1.313228896063079, 1.435677704143894, 1.575886478554653,
1.711088424682592, 1.846141071147255, 1.978688370810553, 2.121110202460375, 2.273033993706166, 2.437416518958685,
2.605810040844211, 2.749293279901460, 2.878055414581598, 3.011889145221327, 3.128487057679250, 3.248832929733116,
3.362627596399784, 3.455430384278588, 3.540021961719671, 3.619042002123711, 3.676530929733142, 3.720059468453691,
3.747954099766827, 3.760070027376262, 3.755665219295461, 3.736719138487386, 3.708891926366174, 3.664441010541270,
3.604159805154076, 3.527575557679334, 3.438033874177650, 3.335986747915032, 3.234151252965536, 3.135555421315700,
3.031275185625463, 2.914518734447023, 2.798651071147369, 2.680363064413359, 2.567503327039606, 2.440453347241640,
2.309203744548048, 2.190426970137261, 2.062578741181030, 1.942872889329166, 1.837182175524465, 1.729734229396513,
1.626350168790444, 1.520216404480680, 1.434172694042972, 1.349345104817380, 1.272492054312317, 1.196237347241614,
1.124821535793806, 1.061599845558113, 1.000314758016015, 0.946885185625449, 0.894741791686053, 0.846916217611976,
0.800860007174258, 0.758318182258432, 0.722178296736551, 0.687835407847660, 0.656791158689405, 0.628247926366175,
0.599695926366175, 0.575193426366175, 0.550998646904891, 0.529145852292099, 0.508234370810617, 0.487643212561458,
0.467003502123744, 0.447321461719706, 0.426934720978967, 0.410127380911624, 0.394251502123744, 0.377679555995800,
0.361538303470547, 0.346609374177618, 0.331366781585022, 0.319779192359434, 0.304696347241591, 0.293457832090073,
0.280660707510949, 0.265359165423409, 0.251380364076607, 0.236700626702869, 0.224148776534517, 0.213043636803878,
0.203432458352700, 0.194937906164147, 0.187043039160779, 0.179267833773573, 0.173304737813977, 0.167047205827445,
0.162893508857747, 0.158874909531148, 0.154199488655728, 0.147701495389735, 0.140777784952025, 0.133413347241587,
0.128207050945290, 0.124642397746635, 0.121964625019363, 0.119562337140574, 0.116996013908252, 0.114084727712966,
0.111931300103537, 0.108546444884683, 0.107682353975592, 0.106988000440238, 0.105991498756736, 0.105929475187712,
0.103330020642259, 0.101549360709599, 0.099504593032831, 0.098054559362797, 0.098189005490743, 0.095920635120373,
0.094038815255053, 0.091718768117006, 0.089698379228117, 0.087779231079969, 0.086886229396467, 0.085125481921720,
0.083576027376265, 0.081233219295457, 0.080075468453705, 0.079002555995794, 0.078897252965490, 0.078789924682662,
0.075192734446973, 0.072639525692764, 0.069832044211283, 0.066811657005895, 0.065251454985693, 0.064016616601854,
0.062800887645625, 0.062433862393100, 0.060950747914986, 0.061031747914985, 0.059425057679295, 0.059211630069867,
0.056837529059768, 0.055943518958755, 0.057120747914985, 0.056055273167510, 0.055331729396467, 0.054289210877948,
0.054811683941921, 0.052995044211282, 0.051729603133840, 0.050631394379632, 0.049577880911619, 0.047673525692763,
0.046908273167511, 0.044431047578286, 0.042032571147309, 0.039634337140574, 0.038566391012628, 0.036364148588387,
0.034842970137208, 0.032894835457073, 0.033524823672561, 0.033159259699497, 0.033052828723065, 0.033906848925086,
0.033062246231484, 0.032470150271888, 0.031257441517679, 0.030057997073235, 0.028710889329128, 0.026626315255053,
0.026291926366163, 0.027506323672559, 0.028908995389732, 0.027669310204547, 0.028312970137207, 0.028517475187712,
0.027882377544616, 0.026005266433504, 0.026408108184345, 0.025861727712965, 0.026316500440237, 0.027361037477273,
0.028477778218015, 0.028943852292089, 0.029546185625422, 0.029582444884682, 0.030681670473908, 0.030229889329126,
0.031626616601853, 0.031646478554715, 0.031540889329127, 0.031752700776937, 0.031009407847645, 0.031110236130473,
0.029111630069869, 0.026547852292090, 0.025463037477275, 0.023922518958757, 0.023232000440238, 0.021633555995795,
0.019463630069868, 0.019883407847644, 0.020013222662460, 0.019237778218016, 0.017873852292089, 0.016960444884683,
0.016522815255052, 0.018386963403200, 0.019516741180978, 0.020675185625421, 0.023222518958756, 0.022532963403200,
0.024104518958756, 0.023420963403201, 0.024021555995792, 0.026108074514311, 0.024402296736535, 0.022218074514311,
0.019566444884684, 0.017772741180978, 0.016877555995793, 0.017641259699496, 0.018054815255052, 0.017862074514312,
0.018525852292089, 0.019023778218016, 0.018678667106904, 0.018136296736534, 0.018243926366164, 0.017153185625423,
0.016880518958756, 0.016113259699497, 0.015766815255052, 0.018164667106903, 0.017649555995793, 0.018326296736533,
0.018840074514311, 0.018837852292089, 0.019341926366163, 0.019448370810609, 0.017850222662460, 0.017502741180979,
0.016344444884682, 0.015668667106904, 0.016292000440237, 0.016556667106904, 0.017426667106904, 0.015845926366165,
0.012256512224750, 0.012070074514312, 0.012631616601853, 0.014379407847644, 0.014718323672561, 0.014277192359429,
0.014803192359429, 0.015169010541248, 0.015838896063133, 0.016877791686028, 0.018082795053032, 0.018139283268520,
0.018645064413301, 0.018098788319026, 0.016794759699497, 0.017870394379631, 0.017704323672561, 0.018685246231483,
0.017525247914986, 0.017781327039564, 0.015598471820710, 0.014799758015995, 0.014722182258419, 0.014558778218016,
0.013950970137208, 0.013772155322393, 0.012120635120373, 0.011636276534513, 0.011858431416668, 0.012930394379631,
0.013366694042931, 0.013714296736533, 0.013704364076601, 0.013470596399834, 0.012936074514312, 0.012964502123739,
0.012065587982325, 0.012781444884682, 0.012414007174244, 0.013120397746634, 0.014447397746634, 0.015647619968857,
0.015843111551349, 0.015075182258419, 0.013637933100171, 0.012830589665828, 0.011356586298824, 0.011170801787039,
0.011649965086702, 0.012190387645624, 0.014531946568183, 0.013644199093436, 0.011831187308925, 0.010203582931821,
0.008990470137207, 0.009679219295456, 0.011007589665826, 0.012139503807240, 0.011772943201181, 0.010957188992426,
0.009640490339228, 0.010127926366162, 0.009578589665827, 0.010179695726432, 0.008963872494111, 0.006820567780306,
0.006446965086702, 0.007104360709597, 0.009015973504209, 0.009189401113638, 0.008272505490743, 0.008615404480641,
0.009395246231483, 0.009893539160776, 0.011466081248318, 0.012537986972224, 0.013545325356063, 0.012931532426769,
0.013776377544614, 0.014323278218016, 0.012813951618690, 0.011266821989059, 0.010133259699497, 0.008246741180979,
0.007060370810608, 0.007763981921719, 0.010335508857745, 0.010464778218015, 0.010466389329126, 0.011048222662460,
0.010663677207914, 0.011015912898150, 0.011340518958756, 0.009857475187713, 0.009770000440237, 0.009067353975592,
0.008363259699496, 0.010302741180978, 0.010048296736533, 0.012402185625423, 0.013235953302190, 0.013567407847644,
0.014584963403201, 0.015328781585018, 0.016679960036197, 0.015422417948656, 0.014312963403200, 0.013469313571551,
0.012635145221383, 0.010857098083336, 0.009740660372898, 0.010035003807240, 0.011552027376263, 0.011458633436871,
0.012077832090069, 0.012391175524412, 0.012573099766837, 0.012625017275254, 0.012713926366163, 0.013736855659092,
0.014699293369530, 0.014116096399834, 0.014575752965490, 0.016035954985691, 0.016261481921718, 0.015555252965490,
0.014883333773571, 0.013783443201181, 0.012976259699497, 0.012488431416669, 0.011655130069867, 0.012637466770203,
0.014035130069868, 0.014418510541246, 0.017186949935186, 0.019109643537880, 0.020526419632156, 0.021532949935187,
0.021553535793773, 0.020628377544615, 0.019344478554717, 0.017797497073234, 0.017976539160776, 0.017084630069868,
0.016372990339227, 0.018782943201179, 0.020975135120371, 0.022054034110271, 0.021818204143942, 0.020204101450338,
0.020804316938554, 0.020690606500843, 0.022448195726432, 0.024527488655724, 0.025960290002527, 0.026119328723065,
0.027558922999160, 0.027723732763471, 0.028103731079967, 0.029718675524412, 0.030542357342594, 0.029822640170878,
0.028847704143941, 0.029691429733166, 0.030122111551348, 0.031678438150674, 0.032290035793773, 0.031980731079968,
0.032301709194447, 0.031685271484008, 0.032227172157409, 0.031018552628790, 0.028842667106905, 0.026237111551349,
0.024923917948655, 0.023592736130474, 0.023788032426769, 0.022436990339228, 0.020740493706231, 0.020595690675927,
0.019981313571551, 0.019183798420036, 0.019153535793773, 0.017453052628790, 0.016922653638890, 0.017069434783672,
0.017322290002527, 0.018017367443605, 0.018132054312291, 0.016393852292091, 0.014772786635524, 0.013108244547983,
0.011146619968857, 0.010841468453706, 0.009524320305558, 0.009432593032830, 0.010065091349328, 0.010453731079968,
0.011304121652358, 0.011048685625423, 0.009649912898150, 0.009354694042932, 0.007722407847645, 0.006546160372898,
0.005413741180979, 0.005041266433503, 0.005795167106904, 0.005413436467173, 0.006108121652359, 0.005967463403200,
0.005926269800508, 0.007011259699496, 0.008954801787038, 0.009531933100170, 0.010718029059766, 0.009757539160777,
0.007150034110272, 0.005180000440238, 0.004799111551348, 0.005142795053032, 0.005277369127106, 0.004528364076601,
0.007589180574917, 0.007827327039564, 0.007658613234850, 0.007328904480642, 0.005572828723066, 0.004288981921719,
0.002421576197814, 0.002591279901516, 0.004165981921719, 0.004217259699497, 0.003638889329126, 0.004604444884682,
0.004291315255052, 0.005241185625423, 0.003601904480642, 0.002081722662460, 0.000662215928453, 0.002063998756736,
0.001136404480642, 0.001727481921718, 0.003586337140574, 0.004716705827444, 0.004397630069867, 0.004611333773570,
0.004786741180978, 0.004887630069868, 0.004076796736533, 0.005333185625423, 0.003526555995793, 0.004389000440237,
0.004378889329126, 0.006149481921718, 0.005668815255053, 0.003943407847645, 0.004131185625423, 0.003241148588387,
0.002711481921719, 0.002047481921720, 0.001702722662460, 0.000531407847645, 0.001801315255052, 0.003107259699496,
0.002042741180979, 0.004074370810606, 0.007110444884681, 0.009596444884682, 0.010136296736534, 0.008373185625423,
0.006943704143942, 0.005410222662461, 0.004803111551349, 0.004517259699497, 0.003130444884682, 0.003206518958756,
0.002271481921720, 0.004024000440236, 0.005558222662459, 0.006649481921719, 0.006780667106905, 0.006258518958756,
0.004702074514312, 0.003686000440238, 0.003697259699497, 0.002497037477275, -0.000003925485688, -0.000858147707910,
-0.002729703263466, -0.002205332893096, 0.000224889329126, 0.001267852292090, 0.002812222662459, 0.003419778218014,
0.004797926366163, 0.005723185625423, 0.005339926366163, 0.004571259699497, 0.004229333773571, 0.002386889329126,
0.000296889329128, -0.000217110670874, 0.000526296736533, 0.001093778218015, 0.000740741180978, 0.003686815255052,
0.004382000440237, 0.005081333773571, 0.006974296736533, 0.008184222662460, 0.006271481921720, 0.005814889329126,
0.004781259699498, 0.001278370810609, 0.000101407847645, -0.000585999559762, -0.001348740300503, -0.000345258819022,
0.001091926366163, 0.001664000440237, 0.002414741180977, 0.004022074514311, 0.004673555995793, 0.005999778218015,
0.005970667106906, 0.005310000440237, 0.004590222662460, 0.004204889329127, 0.002726148588386, 0.003045852292089,
0.002900222662459, 0.002844518958756, 0.003038593032831, 0.001981778218015, 0.001402889329127, 0.001357185625422,
0.000690667106904, 0.000686815255053, 0.000457481921719, 0.000068667106904, -0.000110787438550, 0.000704667106904,
0.001076101450338, 0.002697502123740, 0.003792808521045, 0.005066909531146, 0.005959859026096, 0.007345428049665,
0.007858175524412, 0.007228869127107, 0.006594424682662, 0.002572269800508, -0.001759120771883, -0.003531103936866,
-0.006266565216327, -0.006189979357742, -0.006131646024408, -0.005101745351009, -0.002454747034512, 0.001153407847643,
0.005134136803873, 0.005907791686029, 0.005795327039564, 0.006268283268521, 0.004602263066501, 0.003379704143942,
0.000916997073234, -0.000480164542927, -0.003484888448651, -0.003868773970537, -0.003634167909931, -0.002029683061446,
-0.002117070266834, 0.000811737813974, 0.001422660372897, 0.002008734446971, 0.003019727712964, 0.002558882595121,
0.000027751281989, -0.002167723465486, -0.002996679694442, -0.003867002926766, -0.001794046697811, -0.001644292489054,
-0.001817938953702, -0.001735952421715, -0.000895366563130, -0.002063534913297, -0.000790585418349, -0.000792975990739,
-0.001461124138887, -0.000007204946968, 0.000256625019362, 0.002060869127105, 0.003273380911618, 0.004957091349328,
0.006187239497476, 0.004875832090070, 0.002498687308925, 0.000529212561451, -0.001459258819021, -0.003200329526091,
-0.004865629189392, -0.006418396866159, -0.006469758819023, -0.005279676327439, -0.004636975990740, -0.004432235249998,
-0.003913427169190, -0.003706565216328, -0.003081077000840, -0.002201864879628, -0.003109110670873, -0.003975683061446,
-0.005187467573229, -0.004691575317338, -0.004255952421716, -0.003229231882995, -0.002821851411615, -0.003637225148988,
-0.004663056798819, -0.004866713364477, -0.003492915384679, -0.003464585418348, -0.002269245351009, -0.001205925485689,
0.000830687308923, 0.002762613234850, 0.003833333773570, 0.001632714244952, -0.000622915384677, -0.002736578684341,
-0.002151258819022, -0.000575851411615, 0.000273704143941, 0.001016963403200, 0.000492168790406, -0.000979999559762,
-0.001578127505889, -0.002752046697810, -0.001511184744949, -0.000613184744947, -0.001932154441916, -0.003011999559761,
-0.004152147707911, -0.003657992825756, -0.002647332893096, -0.001035110670874, 0.001123407847644, 0.001638667106904,
0.001740963403200, 0.002257852292089, 0.003331185625422, 0.003893630069867, 0.002454889329126, 0.001614667106904,
-0.000337703263465, -0.002084740300502, -0.003130740300504, -0.003015184744947, -0.004670666226429, -0.004721332893095,
-0.005739629189392, -0.005371258819022, -0.004754444004207, -0.004342073633836, -0.002671999559764, -0.000061332893096,
-0.000514221781985, -0.002653555115317, -0.003829555115318, -0.005669629189392, -0.005146369930133, -0.004111258819023,
-0.004259406967169, -0.004697258819021, -0.003792888448652, -0.003092962522726, -0.002033703263466, -0.001749481041244,
-0.003506928852691, -0.004140962522725, -0.005231757135520, -0.005271460839224, -0.004419494509258, -0.004775528179291,
-0.004550342994106, -0.004607932219695, -0.004378039963803, -0.002724039963803, 0.000417576197813, 0.001137468453706,
0.001601636803874, 0.000959252965490, 0.001187683941922, -0.000582208313971, -0.000983447371211, -0.000851706630470,
-0.001313171276934, -0.004229730199492, -0.005908767236530, -0.006275534913298, -0.005625797539560, -0.005288019761783,
-0.005343494509257, -0.003881090468854, -0.003259716731480, -0.004013952421715, -0.004218524812288, -0.003437622455386,
-0.002089265553029, -0.001811905283669, -0.001363905283668, -0.002278644340907, -0.002724888448651, -0.001584592152355,
-0.002478390132153, -0.002694019761783, -0.003651077000840, -0.004890033229796, -0.005672396866160, -0.006209240300503,
-0.004751151074915, -0.002481534913298, -0.002181151074914, -0.002074949054712, -0.000901238617002, 0.001064549261786,
0.000423657005894, 0.000619704143941, -0.000680073633836, -0.002138602253365, -0.005391989458751, -0.006040147707911,
-0.004800450738215, -0.003597002926766, -0.002626087101851, -0.000997341310605, -0.000482013027776, 0.000220545894783,
0.002266758015994, 0.002222815255052, 0.002799976871213, 0.001422515591753, 0.000916848925086, -0.000646996192758,
-0.002296060165823, -0.003975130872893, -0.005229026495789, -0.005653545014308, -0.003867245351009, -0.001514120771884,
-0.000372713364477, 0.001206473504210, 0.001827118285355, 0.002492195726433, 0.001400774851012, 0.000439266433504,
-0.001586166226429, -0.001398228515991, -0.001165373297137, -0.001323851411614, -0.003279002926765, -0.004707543330806,
-0.002901097202861, -0.001871898549662, -0.002383811007574, -0.002621895182659, -0.004754871613634, -0.005387893499157,
-0.005866292489056, -0.004759750401514, -0.003879541647306, -0.002051433903197};
    int i;
    for( i=0; i<1000; i++)
    {
        a_vect[i] = a_vect[i] * 10000;
    }

    fptype convolved_out[1000];
    fptype exp_convolved_out[] = {0.031403313084742, 0.033210484563530, 0.035028669890748, 0.036875720531201, 0.038733547790049, 0.040573118053865,
0.042375889084764, 0.044119125999798, 0.045776944323443, 0.047352184931326, 0.048866191911487, 0.050327615212925,
0.051771569566232, 0.053193011484321, 0.054624534893639, 0.056057158561079, 0.057508325612934, 0.058930124708480,
0.060331228644353, 0.061707294249129, 0.062289009098106, 0.062862531391417, 0.063423851272720, 0.064010358192264,
0.064590520313750, 0.065190606410532, 0.065795903850140, 0.066449573522218, 0.067130742324400, 0.067855478575084,
0.068623794735808, 0.069483013943202, 0.070457885277935, 0.071559687393073, 0.072783388885175, 0.074085155601491,
0.075431594610431, 0.076852392217288, 0.078276482485535, 0.079705694887305, 0.081158078730340, 0.082581412755878,
0.083954956423154, 0.085301366308319, 0.086630215984816, 0.087948807961343, 0.089269694016567, 0.090628489925868,
0.092047587050818, 0.093508706799396, 0.094970123128527, 0.096417955562855, 0.097825820245743, 0.099202814869272,
0.100496811411060, 0.101723220803050, 0.102904185613363, 0.104053617814154, 0.105166081051539, 0.106286154248704,
0.107454077955734, 0.108652858384728, 0.109886227562438, 0.111204817311286, 0.112619225731849, 0.114094634878644,
0.115648190868284, 0.117246270683730, 0.118871751116080, 0.120504160696478, 0.122186440684248, 0.123896169578484,
0.125629898355185, 0.127412556542536, 0.129223993520036, 0.131116769816589, 0.133116460993954, 0.135254878087570,
0.137550426232479, 0.139965016132419, 0.142404792894682, 0.144914858234675, 0.147532395921121, 0.150181469032370,
0.152833321529103, 0.155489613612934, 0.158146960937704, 0.160743350212411, 0.163299060804990, 0.165831759348061,
0.168354458354863, 0.170876393699731, 0.173389612297792, 0.175920389910518, 0.178538470198464, 0.181247636885107,
0.183987881388028, 0.186786272888818, 0.189642361775105, 0.192547203780976, 0.195509834120008, 0.198535070802237,
0.201678279303399, 0.204913988710773, 0.208262338692578, 0.211746915254899, 0.215407942324117, 0.219246657322537,
0.223300987160679, 0.227600679387437, 0.232098828849766, 0.236807366699185, 0.241765479433041, 0.246985132781967,
0.252511924816528, 0.258347196107428, 0.264461077891769, 0.270788838686255, 0.277331771349073, 0.284102922129525,
0.291131850712029, 0.298354915724113, 0.305745232634030, 0.313280431416338, 0.320976320186779, 0.328817150424109,
0.336733122261386, 0.344730734542309, 0.352729175578084, 0.360667701034981, 0.368478858133459, 0.376117947764472,
0.383552519336254, 0.390734848736784, 0.397552245083474, 0.403980221924097, 0.410065700035557, 0.415816011173677,
0.421252096652350, 0.426362114636812, 0.431146817230460, 0.435650326648321, 0.439884013578327, 0.444013091118882,
0.448161380184245, 0.452479186771336, 0.457093885367541, 0.462192701939209, 0.467916757233066, 0.474433660843368,
0.481967054044966, 0.490853790786345, 0.501402242231987, 0.513946355283816, 0.528594206747375, 0.545764571807617,
0.565757925113461, 0.588924168528433, 0.615470627678740, 0.645880004654741, 0.680240908653637, 0.718729833852727,
0.761456998548461, 0.808760057778770, 0.860924829292807, 0.918294694031480, 0.981094633004216, 1.048972538368497,
1.121735835899790, 1.199512365657228, 1.282013267482560, 1.369263606902420, 1.461075087743510, 1.556968713584399,
1.656703343078939, 1.760012709474095, 1.866282969988080, 1.975012399458213, 2.085614678122530, 2.197493429687742,
2.310006390418922, 2.422480084282884, 2.534338147324197, 2.644778139399568, 2.753033339438908, 2.858301306539244,
2.959837447469642, 3.056909439628986, 3.149057293916326, 3.235882906911377, 3.316807486086995, 3.391058243964869,
3.458166570224741, 3.517640901800078, 3.569392166957423, 3.612716360171101, 3.647297094435232, 3.673105642132185,
3.689879858282746, 3.697437377700092, 3.696155394801773, 3.686081509244058, 3.667450509045243, 3.640184242136125,
3.604671667581388, 3.560961634286366, 3.509397874605175, 3.450730110130094, 3.385603768657242, 3.314383953991143,
3.237740802945456, 3.156080877755616, 3.069882463866640, 2.979930244174367, 2.886727708568936, 2.790755498323250,
2.692817929574528, 2.593484433948482, 2.493362299027131, 2.393024518561324, 2.292990047338270, 2.193793492091334,
2.095777813298607, 1.999431393880976, 1.905174980961143, 1.813401453940961, 1.724407711291712, 1.638476750668737,
1.555617572511977, 1.475852586352922, 1.399306211155193, 1.326172836869157, 1.256416312485041, 1.190066526797852,
1.126971635649273, 1.067392131003472, 1.011266348430584, 0.958365027268878, 0.908743996775996, 0.862126963366978,
0.818208674369465, 0.776928150001812, 0.738171022648340, 0.701932841710580, 0.667810953405672, 0.635745143872483,
0.605547979687961, 0.577159675376329, 0.550478035389671, 0.525309634362324, 0.501620593912620, 0.479242090549045,
0.458111903006719, 0.438092523036859, 0.419118378896069, 0.401093279246292, 0.383920879555067, 0.367583201127682,
0.352025674268275, 0.337199838750503, 0.323095525080128, 0.309628054807822, 0.296801008397287, 0.284545048574432,
0.272883573270005, 0.261810585857924, 0.251317125190556, 0.241397288498675, 0.232012016274502, 0.223104662844952,
0.214648094303701, 0.206658587614860, 0.199149553862497, 0.192049708169368, 0.185362864195762, 0.179008493159888,
0.173046085206985, 0.167399902410096, 0.162107823110267, 0.157188381807790, 0.152609499667398, 0.148356551359224,
0.144400344422120, 0.140706786336362, 0.137258459619468, 0.134029687766746, 0.130940817486907, 0.128000108876800,
0.125163856104079, 0.122426608469025, 0.119771031978111, 0.117196288169766, 0.114711474999068, 0.112360677852436,
0.110126310174239, 0.108039814368024, 0.106028310984830, 0.104085179818312, 0.102155470937938, 0.100259309854687,
0.098437954514838, 0.096658257703342, 0.094912364923176, 0.093217042146903, 0.091556808688874, 0.089890177941253,
0.088232518755059, 0.086571336470496, 0.084953379986337, 0.083347317563579, 0.081777758712355, 0.080203235786997,
0.078595941796124, 0.076996997876426, 0.075421079978535, 0.073853261061897, 0.072297544508317, 0.070742225741641,
0.069215399720485, 0.067715162026163, 0.066243142857728, 0.064832164988079, 0.063431915095801, 0.062046894019058,
0.060650004008026, 0.059241779135279, 0.057880745525091, 0.056531503687905, 0.055228360117791, 0.054002857446793,
0.052834008968189, 0.051671294461798, 0.050549867560597, 0.049450234947185, 0.048378889795861, 0.047286131052908,
0.046243190437549, 0.045209402928196, 0.044241695950073, 0.043325492233221, 0.042429073426726, 0.041583901967970,
0.040788111657316, 0.040038963971303, 0.039329026847828, 0.038672620640034, 0.038093313090147, 0.037564141980732,
0.037081286879975, 0.036664963397016, 0.036276628946791, 0.035959652172849, 0.035670947803123, 0.035394124647891,
0.035127180809317, 0.034877016388426, 0.034642333269264, 0.034411061898568, 0.034123082209832, 0.033841346131492,
0.033555895831142, 0.033233409061913, 0.032891831606563, 0.032531696785700, 0.032170953837178, 0.031850244652338,
0.031559262884528, 0.031312420161792, 0.031106180736719, 0.030859341197690, 0.030612846757718, 0.030375761173916,
0.030138692096728, 0.029939459752879, 0.029726305127578, 0.029511058114767, 0.029242225069161, 0.028950254206309,
0.028632674079326, 0.028308883110613, 0.027973526216764, 0.027629325582134, 0.027291148265345, 0.026968345289372,
0.026628322223551, 0.026294542481663, 0.025945915348882, 0.025586708367366, 0.025232359597430, 0.024867214745263,
0.024514493960062, 0.024208349564850, 0.023934685796794, 0.023723283419809, 0.023544094028461, 0.023395834331894,
0.023272341322059, 0.023181658669844, 0.023101369734558, 0.023006334292515, 0.022886692752624, 0.022766794005320,
0.022678292941951, 0.022605683978432, 0.022552346858338, 0.022434280345968, 0.022228141995443, 0.021993304292229,
0.021720042919104, 0.021489700087373, 0.021238272988809, 0.020993312191290, 0.020751003047615, 0.020484359304350,
0.020266907251519, 0.020112615850699, 0.020031098569381, 0.019985723917403, 0.019968774625197, 0.019932584520490,
0.019869706348955, 0.019833600851126, 0.019788168271429, 0.019758275984855, 0.019721249675901, 0.019704657389262,
0.019652233637271, 0.019607181236024, 0.019565443639829, 0.019533644273583, 0.019495178175610, 0.019409010983129,
0.019300923578192, 0.019168665984290, 0.019026810414282, 0.018901069133978, 0.018772115054489, 0.018645978605536,
0.018546262396551, 0.018445713965815, 0.018352567820346, 0.018267247511343, 0.018149524628900, 0.018035409184129,
0.017895658016022, 0.017793375736757, 0.017774522446752, 0.017776437473522, 0.017770410057412, 0.017720136463321,
0.017639406209613, 0.017552708092220, 0.017429370724027, 0.017294130138731, 0.017154414724170, 0.017006261355414,
0.016882630981209, 0.016748806352020, 0.016579234458812, 0.016393904492245, 0.016210582413441, 0.016020060670908,
0.015856487476720, 0.015697486376194, 0.015555918387209, 0.015397420274953, 0.015255212357647, 0.015135043108756,
0.015004206637325, 0.014884160316704, 0.014749596968144, 0.014573807475537, 0.014412533250903, 0.014262707560125,
0.014136258685859, 0.013989624325509, 0.013815928103179, 0.013640751004788, 0.013479657667222, 0.013332555004295,
0.013224549982532, 0.013138384770620, 0.013091928732341, 0.013029256431426, 0.012997247733984, 0.012973048237117,
0.012909183377914, 0.012806523459100, 0.012689285384855, 0.012558907179415, 0.012435935494618, 0.012340067211275,
0.012317320200401, 0.012301704974145, 0.012279975056609, 0.012263514498897, 0.012204675231938, 0.012173764319155,
0.012184536088940, 0.012198023771274, 0.012229228208117, 0.012232515349350, 0.012196988557547, 0.012174577572336,
0.012153057765144, 0.012188715156407, 0.012264894169906, 0.012340933256170, 0.012449389869515, 0.012565816139756,
0.012734642217935, 0.012924538758334, 0.013103677390406, 0.013258436464573, 0.013366052081407, 0.013438811156120,
0.013504809533433, 0.013565065039187, 0.013634984623615, 0.013692385005500, 0.013732575716629, 0.013761184829414,
0.013778091789460, 0.013810415486364, 0.013832754167902, 0.013867555328542, 0.013950294324970, 0.014051968190947,
0.014182246674386, 0.014371307768876, 0.014584479007961, 0.014771495400847, 0.014900040046827, 0.015006724267685,
0.015097962854400, 0.015167461933957, 0.015225750025723, 0.015291587692974, 0.015374451996859, 0.015489396796137,
0.015654698823774, 0.015869305731902, 0.016126143814965, 0.016373024041741, 0.016632984481123, 0.016843809326469,
0.017026348110415, 0.017182526034760, 0.017330039493238, 0.017454069496841, 0.017546037026154, 0.017708530641614,
0.017935789319375, 0.018204130035571, 0.018489227242015, 0.018780146084755, 0.019102726233530, 0.019418060123733,
0.019738250781566, 0.020099767489754, 0.020479772199324, 0.020862970502184, 0.021275927858367, 0.021698362930970,
0.022133256579324, 0.022586762939156, 0.023047448041158, 0.023515121687930, 0.023964927746644, 0.024411765283817,
0.024871295263563, 0.025379310048696, 0.025917412402778, 0.026475494433812, 0.027057090405424, 0.027637076485446,
0.028240326109436, 0.028800688098865, 0.029290669285532, 0.029718349896744, 0.030062103070473, 0.030335504750745,
0.030573220655583, 0.030753195544668, 0.030884534528949, 0.031008834310373, 0.031121315185853, 0.031220621385880,
0.031286992328971, 0.031307988981439, 0.031299972367159, 0.031220250350079, 0.031078083518906, 0.030904194707823,
0.030713152826689, 0.030496133405947, 0.030214889472650, 0.029881076964846, 0.029456784995026, 0.028967373187547,
0.028408027791985, 0.027825590594909, 0.027213747235590, 0.026594757145983, 0.025977062015669, 0.025322458554776,
0.024626510030606, 0.023937794894154, 0.023236366129075, 0.022497886769095, 0.021731032731844, 0.020930290605908,
0.020135885592952, 0.019346282512206, 0.018571346537219, 0.017815312262168, 0.017060315737566, 0.016359052429076,
0.015745564727750, 0.015203546496489, 0.014721540987358, 0.014262476633993, 0.013768423504310, 0.013275525333999,
0.012815471669966, 0.012372431329704, 0.011950780314254, 0.011536968329704, 0.011187380975879, 0.010883908589782,
0.010598608418443, 0.010316864008776, 0.010011253772363, 0.009681082857816, 0.009323862706305, 0.009006165862468,
0.008749426746846, 0.008525603862680, 0.008327176586125, 0.008151940951487, 0.007995527359329, 0.007858782019629,
0.007682353474059, 0.007471365458890, 0.007218240843778, 0.006993438194522, 0.006775521975268, 0.006570864611905,
0.006426419054974, 0.006322784101216, 0.006233490443612, 0.006154053425001, 0.006064808119098, 0.005986045733957,
0.005881445757042, 0.005803849217011, 0.005697993650427, 0.005592193940819, 0.005457975279819, 0.005354527154841,
0.005232149873373, 0.005105474646476, 0.005034984985435, 0.004987217557772, 0.004937998811742, 0.004870314592799,
0.004792918531029, 0.004706326855246, 0.004587397276308, 0.004490512402223, 0.004380222269481, 0.004313978565478,
0.004337675742917, 0.004435468662355, 0.004583511661805, 0.004703110257879, 0.004775641251706, 0.004825402851848,
0.004877449850780, 0.004908599973127, 0.004920568447717, 0.004916022492482, 0.004922006499314, 0.004982911365368,
0.005093546833325, 0.005197120939306, 0.005319936578935, 0.005423553568868, 0.005467111919972, 0.005472381036646,
0.005482412828680, 0.005464646481182, 0.005393267798204, 0.005296546123489, 0.005170103800302, 0.005018916174392,
0.004932162990506, 0.004839276412117, 0.004767845567318, 0.004672766280797, 0.004611878214061, 0.004601135111229,
0.004582206589743, 0.004566212501712, 0.004553883633252, 0.004518966988036, 0.004448166685581, 0.004381746395730,
0.004298427881655, 0.004196909835217, 0.004104223165439, 0.004027685241824, 0.003916236849549, 0.003783949489409,
0.003690505088356, 0.003666173465518, 0.003647508944329, 0.003659195318453, 0.003671865959988, 0.003631980111808,
0.003594618250696, 0.003539272584311, 0.003481320277006, 0.003404275487273, 0.003322713049507, 0.003232886706359,
0.003156636997330, 0.003121964830835, 0.003131870994396, 0.003188897333262, 0.003249614102625, 0.003323685283754,
0.003430283525909, 0.003542389094792, 0.003656067281101, 0.003758966631603, 0.003810455533484, 0.003839004047031,
0.003841623005509, 0.003813897793360, 0.003751419801896, 0.003672374518896, 0.003588743310145, 0.003518114199358,
0.003447397897238, 0.003398447264379, 0.003376788924290, 0.003370871310190, 0.003350921788945, 0.003344390063748,
0.003360941979110, 0.003348816887111, 0.003345179313458, 0.003362115054299, 0.003366292971721, 0.003351100987653,
0.003371537557507, 0.003337035271828, 0.003245169528528, 0.003178163807676, 0.003070736933914, 0.002960098569148,
0.002845631922990, 0.002714398165046, 0.002592178896281, 0.002517364257380, 0.002500397398181, 0.002474299588311,
0.002442932294503, 0.002407354396272, 0.002353596484453, 0.002297957293240, 0.002215238555783, 0.002114819961718,
0.001983893742541, 0.001833835189143, 0.001684146987659, 0.001558959168459, 0.001424578252796, 0.001359502358729,
0.001316801222073, 0.001287973140030, 0.001293081203966, 0.001294659385361, 0.001257648474335, 0.001186759128201,
0.001099488078486, 0.000976427069776, 0.000877757009409, 0.000749239487274, 0.000596687153248, 0.000423519716467,
0.000253605190506, 0.000044475755409, -0.000143809040314, -0.000313309569317, -0.000476930737255, -0.000538500450230,
-0.000517235068292, -0.000433192799369, -0.000280246303523, -0.000099679564320, 0.000104503360028, 0.000270448525498,
0.000351312255683, 0.000338439358563, 0.000225462315653, 0.000073400956605, -0.000103240942072, -0.000315650264180,
-0.000501139591008, -0.000647369376196, -0.000743649158268, -0.000819029063870, -0.000841547956333, -0.000863521877903,
-0.000887868583207, -0.000932888402340, -0.000998885931658, -0.001137835997465, -0.001313705222992, -0.001494689013591,
-0.001688106591006, -0.001856600632351, -0.001974329161114, -0.002070793794408, -0.002175801760572, -0.002273940740019,
-0.002387393831835, -0.002503445327782, -0.002593574813795, -0.002662612140625, -0.002703307011915, -0.002678115424611,
-0.002643705567818, -0.002635049511357, -0.002644403828021, -0.002709587872295, -0.002761269984802, -0.002808068386207,
-0.002850163299645, -0.002895173659517, -0.002955402365372, -0.003003463822793, -0.003008322222143, -0.002992898948494,
-0.002917764630344, -0.002795785221486, -0.002670825212539, -0.002543740679919, -0.002444591626717, -0.002366618170133,
-0.002289488974866, -0.002193683502984, -0.002072195000686, -0.001945943727051, -0.001828498808888, -0.001715441303420,
-0.001564433199028, -0.001384892075783, -0.001207335964654, -0.001052743644774, -0.000941170254050, -0.000881880379276,
-0.000853702267507, -0.000816051529201, -0.000798865466108, -0.000789735181279, -0.000834163837160, -0.000882675768976,
-0.000950620117650, -0.001037576915456, -0.001134940029583, -0.001219172442566, -0.001326186782473, -0.001429371980675,
-0.001515864007281, -0.001604000595468, -0.001701640959391, -0.001815718823189, -0.001952176161217, -0.002113171847817,
-0.002250708625748, -0.002350192666776, -0.002420113396347, -0.002463548260607, -0.002559418668767, -0.002681215379369,
-0.002799309317103, -0.002901369007796, -0.002971039981287, -0.003059384855673, -0.003163303698766, -0.003296205423383,
-0.003460040778293, -0.003597326856543, -0.003671103810010, -0.003728443900268, -0.003781394036645, -0.003839497053245,
-0.003851037293404, -0.003864611155554, -0.003840612518436, -0.003776224676566, -0.003696999892236, -0.003670615778571,
-0.003647352508014, -0.003635721476453, -0.003601604169527, -0.003575698087441, -0.003568874883630, -0.003548125288258,
-0.003547622555474, -0.003607074276426, -0.003662067235736, -0.003666757549964, -0.003628909580894, -0.003556168172144,
-0.003487770511712, -0.003456570403363, -0.003433038699502, -0.003383239880553, -0.003366819287935, -0.003367200717696,
-0.003403651181477, -0.003467563933271, -0.003516464987431, -0.003568861953149, -0.003581185060495, -0.003555594261820,
-0.003541247104102, -0.003518252386627, -0.003476599103252, -0.003395046279393, -0.003323955644739, -0.003272827649247,
-0.003292626898071, -0.003342734160309, -0.003453705753047, -0.003562445385470, -0.003651735746679, -0.003687157467247,
-0.003697222510136, -0.003677512899237, -0.003635547989003, -0.003524956451721, -0.003344893722685, -0.003155514855706,
-0.002963503819769, -0.002798080764159, -0.002637462965872, -0.002528558676628, -0.002460409865652, -0.002412023191633,
-0.002388360401200, -0.002394182600071, -0.002398179091367, -0.002367858554394, -0.002325720549652, -0.002237679038654,
-0.002127098152206, -0.002019349568428, -0.001909680213958, -0.001811060315934, -0.001732226237541, -0.001632323604888,
-0.001520704637160, -0.001409614414811, -0.001367042041320, -0.001398008724759, -0.001407998338832, -0.001404964969280,
-0.001434566696253, -0.001504524791271, -0.001602612662784, -0.001718505688546, -0.001824944711310, -0.001893070741582,
-0.001896367002940, -0.001864362606975, -0.001823349200097, -0.001805284866011, -0.001804387779100, -0.001830277861652,
-0.001860866189514, -0.001898589659194, -0.001965819560192, -0.002023650814021, -0.002082435171012, -0.002107692419646,
-0.002116109677631, -0.002090438245422, -0.002031097440465, -0.001939370067189, -0.001824464102503, -0.001702501582115,
-0.001612467023020, -0.001562267165137, -0.001527871643192, -0.001515750476749};

    for( i=0; i<1000; i++)
    {
        exp_convolved_out[i] = exp_convolved_out[i] * 10000000000;
    }

    int lena = 1000;
    int lenb = 40;
    fptype maxval;
    int maxpos;
    
    conv(convolved_out, a_vect, a_vect + 181, lena, lenb, &maxval, &maxpos);

    for( i=0; i<1000; i++)
    {
        TEST_ASSERT_FLOAT_WITHIN(10000.0, exp_convolved_out[i], convolved_out[i]);
    }
    TEST_ASSERT_FLOAT_WITHIN(10000.0, 36974373777.0, maxval);
    TEST_ASSERT_EQUAL_INT(199, maxpos);
  
}

/* ************************************************************************** */
/** 
 * @brief            find_pc_peak_candidates()
 *
 * @test             This is to test whether the find_pc_peak_candidates()
 *                   function returns correct values when presented with 
 *                   sample data with a single peak.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_pc_peak_candidates_single_peak(void)
{
    fptype searchdata[] = {1.0, 1.0, 2.2, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.2,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 2.2, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2};
    int AC_idx = 0;
    int pc_peak_cnt = 0;

    find_pc_peak_candidates(searchdata, 1000, AC_idx, &pc_peak_cnt);
    
    TEST_ASSERT_EQUAL_INT(1, pc_peak_cnt);
    TEST_ASSERT_EQUAL_INT(252, __npda_pcpc[0]);
}

/* ************************************************************************** */
/** 
 * @brief            find_pc_peak_candidates()
 *
 * @test             This is to test whether the find_pc_peak_candidates()
 *                   function returns correct values when presented with 
 *                   flat data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_pc_peak_candidates_flat_data(void)
{
    fptype searchdata[] = {1.0, 1.0, 2.2, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.2,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 2.2, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2};
    int AC_idx = 120;
    int pc_peak_cnt = 0;

    find_pc_peak_candidates(searchdata, 1000, AC_idx, &pc_peak_cnt);
    
    TEST_ASSERT_EQUAL_INT(0, pc_peak_cnt);
}

/* ************************************************************************** */
/** 
 * @brief            find_pc_peak_candidates()
 *
 * @test             This is to test whether the find_pc_peak_candidates()
 *                   function rejects negative peaks.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_pc_peak_candidates_rejects_negative_peaks(void)
{
    fptype searchdata[] = {1.0, 1.0, 2.2, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.2,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 2.2, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, -0.2, -0.1, -0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2};
    int AC_idx = 120;
    int pc_peak_cnt = 0;

    find_pc_peak_candidates(searchdata, 1000, AC_idx, &pc_peak_cnt);
    
    TEST_ASSERT_EQUAL_INT(0, pc_peak_cnt);
}

/* ************************************************************************** */
/** 
 * @brief            find_pc_peak_candidates()
 *
 * @test             This is to test whether the find_pc_peak_candidates()
 *                   function correctly identifies peak candidates in data that
 *                   contains multiple peaks.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_pc_peak_candidates_multiple_peaks(void)
{
    fptype searchdata[] = {1.0, 1.0, 2.2, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.2,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 2.2, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.3, -0.2, -0.1, -0.2, 0.3, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2,
    0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2};
    int AC_idx = 100;
    int pc_peak_cnt = 0;

    find_pc_peak_candidates(searchdata, 1000, AC_idx, &pc_peak_cnt);
    
    TEST_ASSERT_EQUAL_INT(3, pc_peak_cnt);
    TEST_ASSERT_EQUAL_INT(252, __npda_pcpc[0]);
    TEST_ASSERT_EQUAL_INT(674, __npda_pcpc[1]);
    TEST_ASSERT_EQUAL_INT(678, __npda_pcpc[2]);
}

/* ************************************************************************** */
/** 
 * @brief            find_pc_peak()
 *
 * @test             This is to test whether the find_pc_peak()
 *                   function correctly identifies peak candidates in "normal"
 *                   data. Verified against find_all_peaks_jr2().
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_pc_peak_normal_data(void)
{
    int iret;
    fptype searchdata[] = {0.018879500800000, 0.019983977600000, 0.021102784000000, 0.022259398400000, 0.023444292800000, 0.024608083200000,
0.025750880000000, 0.026857507200000, 0.027907664000000, 0.028911200000000, 0.029901177600000, 0.030882131200000,
0.031882825600000, 0.032903708800000, 0.033941382400000, 0.034980387200000, 0.036049027200000, 0.037081238400000,
0.038114892800000, 0.039147580800000, 0.039758326400000, 0.040418748800000, 0.041115456000000, 0.041880976000000,
0.042672700800000, 0.043515932800000, 0.044366406400000, 0.045242694400000, 0.046116614400000, 0.046993737600000,
0.047868000000000, 0.048788483200000, 0.049807078400000, 0.050929840000000, 0.052170620800000, 0.053496880000000,
0.054888064000000, 0.056341331000000, 0.057815008000000, 0.059289075000000, 0.060756390000000, 0.062202502000000,
0.063599507000000, 0.064936634000000, 0.066246970000000, 0.067562963000000, 0.068872550000000, 0.070221088000000,
0.071618726000000, 0.073054931000000, 0.074479974000000, 0.075898445000000, 0.077289581000000, 0.078640870000000,
0.079922848000000, 0.081156986000000, 0.082355091000000, 0.083566963000000, 0.084751200000000, 0.085950899000000,
0.087218074000000, 0.088488019000000, 0.089782176000000, 0.091139091000000, 0.092534189000000, 0.093966989000000,
0.095447674000000, 0.096993408000000, 0.098582490000000, 0.100227328000000, 0.101972730000000, 0.103790605000000,
0.105636019000000, 0.107556518000000, 0.109523661000000, 0.111584768000000, 0.113741504000000, 0.116078733000000,
0.118588314000000, 0.121257088000000, 0.123967155000000, 0.126747802000000, 0.129656384000000, 0.132626278000000,
0.135606694000000, 0.138571891000000, 0.141526029000000, 0.144387226000000, 0.147193037000000, 0.149956262000000,
0.152673229000000, 0.155336909000000, 0.157943654000000, 0.160552294000000, 0.163261120000000, 0.166058419000000,
0.168880333000000, 0.171751706000000, 0.174682317000000, 0.177668403000000, 0.180721037000000, 0.183871795000000,
0.187161907000000, 0.190572493000000, 0.194176883000000, 0.197967616000000, 0.201998170000000, 0.206233498000000,
0.210689024000000, 0.215395046000000, 0.220293043000000, 0.225398298000000, 0.230764621000000, 0.236371942000000,
0.242248550000000, 0.248387738000000, 0.254785792000000, 0.261368320000000, 0.268156262000000, 0.275144038000000,
0.282404198000000, 0.289870080000000, 0.297500160000000, 0.305295258000000, 0.313240653000000, 0.321339264000000,
0.329515955000000, 0.337763968000000, 0.345990118000000, 0.354133299000000, 0.362161306000000, 0.370022758000000,
0.377694362000000, 0.385096832000000, 0.392101504000000, 0.398683622000000, 0.404867584000000, 0.410662298000000,
0.416083456000000, 0.421132518000000, 0.425821210000000, 0.430183270000000, 0.434257310000000, 0.438235550000000,
0.442244350000000, 0.446431180000000, 0.450914360000000, 0.455925760000000, 0.461665130000000, 0.468269410000000,
0.476003120000000, 0.485123120000000, 0.495929960000000, 0.508778090000000, 0.523823510000000, 0.541439590000000,
0.561988200000000, 0.585680030000000, 0.612934600000000, 0.643990680000000, 0.678965250000000, 0.718170520000000,
0.761776790000000, 0.810061820000000, 0.863452980000000, 0.922643660000000, 0.987507000000000, 1.057749300000000,
1.133102490000000, 1.213710230000000, 1.299240960000000, 1.389693340000000, 1.484801230000000, 1.584126260000000,
1.687368500000000, 1.794169650000000, 1.904014750000000, 2.016371300000000, 2.130644380000000, 2.246195610000000,
2.362360830000000, 2.478493290000000, 2.593979390000000, 2.707979880000000, 2.819649950000000, 2.928170190000000,
3.032924770000000, 3.133085900000000, 3.228088730000000, 3.317607220000000, 3.400958160000000, 3.477423700000000,
3.546493300000000, 3.607662600000000, 3.660862300000000, 3.705301400000000, 3.740647400000000, 3.766994500000000,
3.783758200000000, 3.791191200000000, 3.789533600000000, 3.778831200000000, 3.759133500000000, 3.730454500000000,
3.693104300000000, 3.646747000000000, 3.592339000000000, 3.530465700000000, 3.461894600000000, 3.387026020000000,
3.306561540000000, 3.220984420000000, 3.130794800000000, 3.036796110000000, 2.939576930000000, 2.839738570000000,
2.737935970000000, 2.634690360000000, 2.530610790000000, 2.426381520000000, 2.322491800000000, 2.219439310000000,
2.117625450000000, 2.017546240000000, 1.919703240000000, 1.824495210000000, 1.732104400000000, 1.642904990000000,
1.556918990000000, 1.474140880000000, 1.394749540000000, 1.318966270000000, 1.246765360000000, 1.178197500000000,
1.113054620000000, 1.051694900000000, 0.993982870000000, 0.939687220000000, 0.888935630000000, 0.841265770000000,
0.796441600000000, 0.754302770000000, 0.714829260000000, 0.678005250000000, 0.643386780000000, 0.610971290000000,
0.580392040000000, 0.551738420000000, 0.524877570000000, 0.499584670000000, 0.475843990000000, 0.453459300000000,
0.432402690000000, 0.412466253000000, 0.393558989000000, 0.375558630000000, 0.358429389000000, 0.342208538000000,
0.326832691000000, 0.312155469000000, 0.298181197000000, 0.284863693000000, 0.272188851000000, 0.260097024000000,
0.248604032000000, 0.237691546000000, 0.227379482000000, 0.217632998000000, 0.208448218000000, 0.199733734000000,
0.191486336000000, 0.183683469000000, 0.176340966000000, 0.169377920000000, 0.162802330000000, 0.156570278000000,
0.150742810000000, 0.145228390000000, 0.140114790000000, 0.135388915000000, 0.131020634000000, 0.126977728000000,
0.123251341000000, 0.119763226000000, 0.116528986000000, 0.113545062000000, 0.110698611000000, 0.107999693000000,
0.105389658000000, 0.102841427000000, 0.100334234000000, 0.097857011000000, 0.095446438000000, 0.093177459000000,
0.091007661000000, 0.088977997000000, 0.087002918000000, 0.085090445000000, 0.083177126000000, 0.081317485000000,
0.079530893000000, 0.077787482000000, 0.076040787000000, 0.074323475000000, 0.072591578000000, 0.070872602000000,
0.069137280000000, 0.067384640000000, 0.065648499000000, 0.063930701000000, 0.062230554000000, 0.060528486000000,
0.058830067000000, 0.057141248000000, 0.055455136000000, 0.053720371000000, 0.051949904000000, 0.050149155200000,
0.048329513600000, 0.046574051200000, 0.044884972800000, 0.043277811200000, 0.041736108800000, 0.040258364800000,
0.038798780800000, 0.037339097600000, 0.035939548800000, 0.034534819200000, 0.033182409600000, 0.031942345600000,
0.030771817600000, 0.029625632000000, 0.028535718400000, 0.027472099200000, 0.026465769600000, 0.025441913600000,
0.024490310400000, 0.023546432000000, 0.022672694400000, 0.021810190400000, 0.020959104000000, 0.020146009600000,
0.019382099200000, 0.018662798400000, 0.017994772800000, 0.017336968000000, 0.016749636800000, 0.016207076800000,
0.015732155200000, 0.015318035200000, 0.014941566400000, 0.014622000000000, 0.014307476800000, 0.014002596800000,
0.013739867200000, 0.013527364800000, 0.013348134400000, 0.013207248800000, 0.012999438400000, 0.012746557600000,
0.012404677600000, 0.011994784000000, 0.011545715200000, 0.011061592800000, 0.010574044000000, 0.010123404000000,
0.009703872800000, 0.009370180000000, 0.009101837600000, 0.008811636000000, 0.008525325600000, 0.008242357600000,
0.007953658400000, 0.007681502400000, 0.007379134400000, 0.007074675200000, 0.006687449200000, 0.006271581600000,
0.005819542400000, 0.005357756400000, 0.004889510400000, 0.004417407600000, 0.003948472800000, 0.003503797600000,
0.003035771600000, 0.002595666600000, 0.002169183600000, 0.001724831000000, 0.001266148800000, 0.000811579000000,
0.000354121000000, -0.000055658700000, -0.000418923200000, -0.000700808800000, -0.000981546800000, -0.001243528000000,
-0.001489510600000, -0.001726670800000, -0.001936565200000, -0.002152095200000, -0.002345472600000, -0.002523513000000,
-0.002677815800000, -0.002782601800000, -0.002843662200000, -0.002930027200000, -0.003092642000000, -0.003272184400000,
-0.003498479600000, -0.003691230400000, -0.003881456000000, -0.004060352400000, -0.004242436400000, -0.004426637200000,
-0.004561247600000, -0.004628178000000, -0.004602373600000, -0.004556177200000, -0.004464890000000, -0.004381013600000,
-0.004329798800000, -0.004271759200000, -0.004235148000000, -0.004200823600000, -0.004181644000000, -0.004145030000000,
-0.004150599200000, -0.004149406800000, -0.004132157600000, -0.004118086400000, -0.004102824800000, -0.004140317600000,
-0.004215878400000, -0.004339209600000, -0.004470498800000, -0.004581594400000, -0.004691540000000, -0.004781468400000,
-0.004860107200000, -0.004925401600000, -0.004975774000000, -0.005064638000000, -0.005216519200000, -0.005393370000000,
-0.005643028400000, -0.005905836400000, -0.006124847200000, -0.006356573200000, -0.006584460400000, -0.006826268000000,
-0.007082203200000, -0.007307995200000, -0.007540373600000, -0.007741073600000, -0.007908614400000, -0.008074746400000,
-0.008212280000000, -0.008331977600000, -0.008491381600000, -0.008685304800000, -0.008868776800000, -0.009061790400000,
-0.009229811200000, -0.009411692800000, -0.009582207200000, -0.009787665600000, -0.010000955200000, -0.010182332000000,
-0.010396177600000, -0.010622613600000, -0.010881720800000, -0.011140923200000, -0.011365292000000, -0.011556160000000,
-0.011701552000000, -0.011836608800000, -0.011978508800000, -0.012135145600000, -0.012271745600000, -0.012390611200000,
-0.012494703200000, -0.012530115200000, -0.012473189600000, -0.012403505600000, -0.012269003200000, -0.012101756800000,
-0.011963302400000, -0.011872748800000, -0.011799052000000, -0.011771496800000, -0.011764888000000, -0.011779069600000,
-0.011732644800000, -0.011702832000000, -0.011696592800000, -0.011697072800000, -0.011749696800000, -0.011772863200000,
-0.011724289600000, -0.011637841600000, -0.011510764000000, -0.011382868000000, -0.011261403200000, -0.011098859200000,
-0.010926992000000, -0.010709317600000, -0.010467764000000, -0.010260959200000, -0.010047440000000, -0.009836706400000,
-0.009591051200000, -0.009380514400000, -0.009191315200000, -0.009033700800000, -0.008925616800000, -0.008866592000000,
-0.008820864000000, -0.008783222400000, -0.008732116000000, -0.008722501600000, -0.008694868000000, -0.008686252000000,
-0.008703965600000, -0.008722774400000, -0.008752337600000, -0.008764307200000, -0.008741510400000, -0.008666635200000,
-0.008586732000000, -0.008462613600000, -0.008313321600000, -0.008160351200000, -0.008074212800000, -0.008008738400000,
-0.007937740000000, -0.007869688800000, -0.007793700000000, -0.007709883200000, -0.007638170400000, -0.007571109600000,
-0.007467991200000, -0.007321755200000, -0.007121938400000, -0.006928236000000, -0.006708136400000, -0.006494087200000,
-0.006270504800000, -0.006041791200000, -0.005797751600000, -0.005573435200000, -0.005380404400000, -0.005131699200000,
-0.004860617200000, -0.004599349600000, -0.004354274000000, -0.004127196800000, -0.003872851200000, -0.003587249600000,
-0.003263302400000, -0.002870048600000, -0.002482465400000, -0.002078788000000, -0.001656888300000, -0.001227822900000,
-0.000804528500000, -0.000368254800000, 0.000103338500000, 0.000543645000000, 0.000951982000000, 0.001343872400000,
0.001731301600000, 0.002172161800000, 0.002655627400000, 0.003150441800000, 0.003661038800000, 0.004174247200000,
0.004705169600000, 0.005169640800000, 0.005551997600000, 0.005868804400000, 0.006108073600000, 0.006268595200000,
0.006356183200000, 0.006374760400000, 0.006335529600000, 0.006279948400000, 0.006199497200000, 0.006113978800000,
0.006008690800000, 0.005866728400000, 0.005709683200000, 0.005492904800000, 0.005204534400000, 0.004907802400000,
0.004607962400000, 0.004305795200000, 0.003930328000000, 0.003487236800000, 0.002951463400000, 0.002344997000000,
0.001664265100000, 0.000950591700000, 0.000212343800000, -0.000532266200000, -0.001289048400000, -0.002089471200000,
-0.002915165600000, -0.003713227600000, -0.004494177200000, -0.005302013200000, -0.006129204000000, -0.007008750400000,
-0.007896792000000, -0.008767309600000, -0.009628329600000, -0.010437633600000, -0.011203283200000, -0.011877676800000,
-0.012438174400000, -0.012877160800000, -0.013268471200000, -0.013638718400000, -0.014016425600000, -0.014385672000000,
-0.014726945600000, -0.015077246400000, -0.015436987200000, -0.015834281600000, -0.016182012800000, -0.016490129600000,
-0.016755228800000, -0.016984784000000, -0.017215400000000, -0.017471499200000, -0.017772372800000, -0.018058681600000,
-0.018280017600000, -0.018476916800000, -0.018670584000000, -0.018880134400000, -0.019078696000000, -0.019251700800000,
-0.019449684800000, -0.019649449600000, -0.019820052800000, -0.019942816000000, -0.020063924800000, -0.020171496000000,
-0.020221350400000, -0.020245316800000, -0.020247420800000, -0.020259268800000, -0.020317406400000, -0.020374630400000,
-0.020455041600000, -0.020528611200000, -0.020653582400000, -0.020795459200000, -0.020972516800000, -0.021123273600000,
-0.021269006400000, -0.021406668800000, -0.021498054400000, -0.021556638400000, -0.021602089600000, -0.021655099200000,
-0.021658080000000, -0.021634835200000, -0.021638625600000, -0.021649556800000, -0.021723216000000, -0.021795044800000,
-0.021775368000000, -0.021673209600000, -0.021521316800000, -0.021402659200000, -0.021342465600000, -0.021313140800000,
-0.021266441600000, -0.021209246400000, -0.021148708800000, -0.021137622400000, -0.021184462400000, -0.021201792000000,
-0.021179995200000, -0.021138547200000, -0.021075449600000, -0.021013430400000, -0.021015137600000, -0.021041924800000,
-0.021078636800000, -0.021142667200000, -0.021233955200000, -0.021364240000000, -0.021558140800000, -0.021779712000000,
-0.021903868800000, -0.021999393600000, -0.022045174400000, -0.022088321600000, -0.022106462400000, -0.022072745600000,
-0.022047017600000, -0.022025993600000, -0.021990844800000, -0.021966016000000, -0.022020993600000, -0.022079984000000,
-0.022152395200000, -0.022206763200000, -0.022213236800000, -0.022168608000000, -0.022166600000000, -0.022197004800000,
-0.022185252800000, -0.022119086400000, -0.022080897600000, -0.022009468800000, -0.021951342400000, -0.021958057600000,
-0.021979528000000, -0.022012212800000, -0.021999313600000, -0.022007230400000, -0.022080011200000, -0.022216660800000,
-0.022371790400000, -0.022517348800000, -0.022605372800000, -0.022608635200000, -0.022570680000000, -0.022488964800000,
-0.022350704000000, -0.022210977600000, -0.022073609600000, -0.021960099200000, -0.021966112000000, -0.022054112000000,
-0.022183742400000, -0.022382716800000, -0.022621214400000, -0.022875972800000, -0.023120256000000, -0.023334105600000,
-0.023549518400000, -0.023749852800000, -0.023889657600000, -0.024003870400000, -0.024126235200000, -0.024239664000000,
-0.024366254400000, -0.024544270400000, -0.024710321600000, -0.024823368000000, -0.024924009600000, -0.025014307200000,
-0.025016230400000, -0.025045411200000, -0.025139308800000, -0.025187264000000, -0.025256974400000, -0.025327611200000,
-0.025417126400000, -0.025539337600000, -0.025660488000000, -0.025731408000000, -0.025733099200000, -0.025738633600000,
-0.025784481600000, -0.025864361600000, -0.025996580800000, -0.026129676800000, -0.026275798400000, -0.026411248000000,
-0.026530086400000, -0.026654580800000, -0.026752329600000, -0.026786307200000, -0.026825184000000, -0.026791534400000,
-0.026740340800000, -0.026679856000000, -0.026620516800000, -0.026617998400000, -0.026692904000000, -0.026814203200000,
-0.026960588800000, -0.027137712000000, -0.027287958400000, -0.027465488000000, -0.027646208000000, -0.027826550400000,
-0.027985270400000, -0.028209161600000, -0.028425244800000, -0.028650723200000, -0.028890780800000, -0.029047001600000,
-0.029109081600000, -0.029098400000000, -0.029016224000000, -0.028864668800000, -0.028665702400000, -0.028509926400000,
-0.028406307200000, -0.028383507200000, -0.028451971200000, -0.028557539200000, -0.028645171200000, -0.028769110400000,
-0.028867059200000, -0.028984028800000, -0.029100611200000, -0.029239398400000, -0.029357689600000, -0.029462870400000,
-0.029569772800000, -0.029696704000000, -0.029829072000000, -0.030015078400000, -0.030209510400000, -0.030383718400000,
-0.030539276800000, -0.030633308800000, -0.030657939200000, -0.030649584000000, -0.030673443200000, -0.030709526400000,
-0.030811622400000, -0.030938512000000, -0.031054662400000, -0.031160105600000, -0.031211772800000, -0.031188953600000,
-0.031132060800000, -0.031039609600000, -0.030930816000000, -0.030882153600000, -0.030830793600000, -0.030799056000000,
-0.030771174400000, -0.030790700800000, -0.030854412800000, -0.030893628800000, -0.030905635200000, -0.030881142400000,
-0.030782188800000, -0.030633222400000, -0.030479744000000, -0.030328275200000, -0.030187612800000, -0.030039564800000,
-0.029902867200000, -0.029728291200000, -0.029541417600000, -0.029390380800000, -0.029254105600000, -0.029126496000000,
-0.028975401600000, -0.028803046400000, -0.028652192000000, -0.028535846400000, -0.028456908800000, -0.028412364800000,
-0.028385964800000, -0.028336496000000, -0.028302569600000, -0.028277702400000, -0.028316716800000, -0.028358406400000,
-0.028414806400000, -0.028485430400000, -0.028600902400000, -0.028686259200000, -0.028814499200000, -0.028955820800000,
-0.029090547200000, -0.029212937600000, -0.029307872000000, -0.029418425600000, -0.029538396800000, -0.029694057600000,
-0.029820838400000, -0.029916691200000, -0.029981670400000, -0.030051481600000, -0.030162579200000, -0.030321155200000,
-0.030478342400000, -0.030601782400000, -0.030665926400000, -0.030715350400000, -0.030737849600000, -0.030787312000000,
-0.030846076800000, -0.030854169600000, -0.030785929600000, -0.030723689600000, -0.030666867200000, -0.030635900800000,
-0.030534064000000, -0.030465472000000, -0.030374726400000, -0.030243123200000, -0.030110204800000, -0.030057561600000,
-0.030019606400000, -0.029990326400000, -0.029907836800000, -0.029825619200000, -0.029787545600000, -0.029779987200000,
-0.029815968000000, -0.029937651200000, -0.030044400000000, -0.030096841600000, -0.030101254400000, -0.030050227200000,
-0.030003084800000, -0.029966998400000, -0.029941875200000, -0.029828041600000, -0.029729273600000, -0.029659414400000,
-0.029643238400000, -0.029684393600000, -0.029770550400000, -0.029869257600000, -0.029960585600000, -0.029518860800000,
-0.029092451200000, -0.028636467200000, -0.028153081600000, -0.027615446400000, -0.027026316800000, -0.026429675200000,
-0.025852048000000, -0.025224628800000, -0.024563249600000, -0.023830233600000, -0.023080627200000, -0.022241827200000,
-0.021367793600000, -0.020486260800000, -0.019567673600000, -0.018570777600000, -0.017519427200000, -0.016459944000000,
-0.015416257600000};
    uint16_t searchdata_len = 949;
    int i;
    for(i=1; i<searchdata_len; i++)
    {
        searchdata[i] = searchdata[i] * 10000000000;
    }
    fptype AC_height = 37911912000.0;
    int AC_idx = 199;
    int pc_peak_cnt = 1;
    __npda_pcpc[0] = 583;
    __npda_offsetted_x_start = 2.000;
    
    int PC_idx;
    fptype PC_weight;
    fptype thickness;
    
    iret = find_pc_peak(searchdata, searchdata_len, AC_height, AC_idx, pc_peak_cnt, &PC_idx, &PC_weight, &thickness);
    
    TEST_ASSERT_EQUAL_INT(0, iret);
    TEST_ASSERT_EQUAL_INT(584, PC_idx);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.237378243260007, PC_weight);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, 0.538576500000000, thickness);
}

/* ************************************************************************** */
/** 
 * @brief            find_pc_peak()
 *
 * @test             This is to test whether the find_pc_peak()
 *                   function returns error when AC peak value is 0.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_pc_peak_AC_is_0(void)
{
    int iret;
    fptype searchdata[] = {1.0, 1.0, 2.0, 1.0, 1.0};
    uint16_t searchdata_len = 5;
    fptype AC_height = 0.0;
    int AC_idx = 1;
    int pc_peak_cnt = 1;
    __npda_pcpc[0] = 2;
    __npda_offsetted_x_start = 2.000;
    
    int PC_idx;
    fptype PC_weight;
    fptype thickness;
    
    iret = find_pc_peak(searchdata, searchdata_len, AC_height, AC_idx, pc_peak_cnt, &PC_idx, &PC_weight, &thickness);
    
    TEST_ASSERT_EQUAL_INT(1, iret);
}

/* ************************************************************************** */
/** 
 * @brief            find_pc_peak()
 *
 * @test             This is to test whether the find_pc_peak()
 *                   function returns error when no peak candidates are present.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_find_pc_peak_no_peak_candidates(void)
{
    int iret;
    fptype searchdata[] = {1.0, 1.0, 2.0, 1.0, 1.0};
    uint16_t searchdata_len = 5;
    fptype AC_height = 2.0;
    int AC_idx = 1;
    int pc_peak_cnt = 0;
    __npda_offsetted_x_start = 2.000;
    
    int PC_idx;
    fptype PC_weight;
    fptype thickness;
    
    iret = find_pc_peak(searchdata, searchdata_len, AC_height, AC_idx, pc_peak_cnt, &PC_idx, &PC_weight, &thickness);
    
    TEST_ASSERT_EQUAL_INT(2, iret);
}

/* ************************************************************************** */
/** 
 * @brief            vmin()
 *
 * @test             This is to test whether the vmin()
 *                   function returns correct values when presented with 
 *                   "normal" data.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_vmin_normal_data()
{
    fptype vector[] = {0.0, -2.0, -3.1, -1.2};
    int vector_len = 4;
    int minpos;
    
    fptype v_min = vmin(vector, vector_len, &minpos);

    TEST_ASSERT_EQUAL_INT(2, minpos);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, -3.1, v_min);
}

/* ************************************************************************** */
/** 
 * @brief            vmin()
 *
 * @test             This is to test whether the vmin()
 *                   function returns correct values when presented with 
 *                   peak in the leftmost idx.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_vmin_peak_to_the_left()
{
    fptype vector[] = {-4.21, -2.0, -3.1, 1.2};
    int vector_len = 4;
    int minpos;
    
    fptype v_min = vmin(vector, vector_len, &minpos);

    TEST_ASSERT_EQUAL_INT(0, minpos);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, -4.21, v_min);
}

/* ************************************************************************** */
/** 
 * @brief            vmin()
 *
 * @test             This is to test whether the vmin()
 *                   function returns correct values when presented with 
 *                   peak in the rightmost idx.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_vmin_peak_to_the_right()
{
    fptype vector[] = {0.0, 2.0, -3.1, -4.21};
    int vector_len = 4;
    int minpos;
    
    fptype v_min = vmin(vector, vector_len, &minpos);

    TEST_ASSERT_EQUAL_INT(3, minpos);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, -4.21, v_min);
}

/* ************************************************************************** */
/** 
 * @brief            vmin()
 *
 * @test             This is to test whether the vmin()
 *                   function returns correct values when presented with 
 *                   two peaks.
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_vmin_double_peak()
{
    fptype vector[] = {0.0, -4.21, 3.1, -4.21};
    int vector_len = 4;
    int minpos;
    
    fptype v_min = vmin(vector, vector_len, &minpos);

    TEST_ASSERT_EQUAL_INT(1, minpos);
    TEST_ASSERT_FLOAT_WITHIN(0.00001, -4.21, v_min);
}

/* ************************************************************************** */
/** 
 * @brief            median()
 *
 * @test             This is to test whether the median()
 *                   function returns correct values when presented with 
 *                   "normal" data, where one of the values is median (i.e.
 *                   data has odd number of elements).
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_median_odd_data()
{

    fptype vector[] = {0.1, -4.21, 3.1, -5.47, 74.5};
    int vector_len = 5;
    fptype median_help[5];
    fptype med;
    
    med = median(vector, vector_len, median_help);

    TEST_ASSERT_FLOAT_WITHIN(0.0001, 0.1, med);
}

/* ************************************************************************** */
/** 
 * @brief            median()
 *
 * @test             This is to test whether the median()
 *                   function returns correct values when presented with 
 *                   "normal" data, where it has to take an average of two
 *                   values (i.e. data has even number of elements).
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_median_even_data()
{

    fptype vector[] = {0.1, -4.21, 3.1, -5.47};
    int vector_len = 4;
    fptype median_help[4];
    fptype med;
    
    med = median(vector, vector_len, median_help);

    TEST_ASSERT_FLOAT_WITHIN(0.0001, -2.055, med);
}

/* ************************************************************************** */
/** 
 * @brief            median_uint16_t()
 *
 * @test             This is to test whether the median_uint16_t()
 *                   function returns correct values when presented with 
 *                   "normal" data, where one of the values is median (i.e.
 *                   data has odd number of elements).
 * 
 * @note             None.
 */
/* ************************************************************************** */
void test_median_uint16_t_odd_data()
{

    uint16_t vector[] = {0, 4, 2, 1, 75};
    int vector_len = 5;
    uint16_t med;
    
    med = median_uint16_t(vector, vector_len);

    TEST_ASSERT_EQUAL_UINT(2, med);
}

/* ************************************************************************** */
/** 
 * @brief            median_uint16_t()
 *
 * @test             This is to test whether the median_uint16_t()
 *                   function returns correct values when presented with 
 *                   "normal" data, where it has to take an average of two
 *                   values (i.e. data has even number of elements).
 * 
 * @note             In case of even data, lower of the two middle elements is returned.
 */
/* ************************************************************************** */
void test_median_uint16_t_even_data()
{

    uint16_t vector[] = {0, 4, 2, 1};
    int vector_len = 4;
    uint16_t med;
    
    med = median_uint16_t(vector, vector_len);

    TEST_ASSERT_EQUAL_UINT(1, med);
}
#endif //TEST_FILE_C
